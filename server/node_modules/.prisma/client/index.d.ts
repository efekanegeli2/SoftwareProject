
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ExamAttempt
 * 
 */
export type ExamAttempt = $Result.DefaultSelection<Prisma.$ExamAttemptPayload>
/**
 * Model ActiveExam
 * 
 */
export type ActiveExam = $Result.DefaultSelection<Prisma.$ActiveExamPayload>
/**
 * Model ExamResult
 * 
 */
export type ExamResult = $Result.DefaultSelection<Prisma.$ExamResultPayload>
/**
 * Model McqQuestion
 * 
 */
export type McqQuestion = $Result.DefaultSelection<Prisma.$McqQuestionPayload>
/**
 * Model ListeningScenario
 * 
 */
export type ListeningScenario = $Result.DefaultSelection<Prisma.$ListeningScenarioPayload>
/**
 * Model ListeningQuestion
 * 
 */
export type ListeningQuestion = $Result.DefaultSelection<Prisma.$ListeningQuestionPayload>
/**
 * Model WritingTopic
 * 
 */
export type WritingTopic = $Result.DefaultSelection<Prisma.$WritingTopicPayload>
/**
 * Model SpeakingSet
 * 
 */
export type SpeakingSet = $Result.DefaultSelection<Prisma.$SpeakingSetPayload>
/**
 * Model SpeakingPrompt
 * 
 */
export type SpeakingPrompt = $Result.DefaultSelection<Prisma.$SpeakingPromptPayload>
/**
 * Model CheatingEvent
 * 
 */
export type CheatingEvent = $Result.DefaultSelection<Prisma.$CheatingEventPayload>
/**
 * Model AudioResponse
 * 
 */
export type AudioResponse = $Result.DefaultSelection<Prisma.$AudioResponsePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.examAttempt`: Exposes CRUD operations for the **ExamAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamAttempts
    * const examAttempts = await prisma.examAttempt.findMany()
    * ```
    */
  get examAttempt(): Prisma.ExamAttemptDelegate<ExtArgs>;

  /**
   * `prisma.activeExam`: Exposes CRUD operations for the **ActiveExam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActiveExams
    * const activeExams = await prisma.activeExam.findMany()
    * ```
    */
  get activeExam(): Prisma.ActiveExamDelegate<ExtArgs>;

  /**
   * `prisma.examResult`: Exposes CRUD operations for the **ExamResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamResults
    * const examResults = await prisma.examResult.findMany()
    * ```
    */
  get examResult(): Prisma.ExamResultDelegate<ExtArgs>;

  /**
   * `prisma.mcqQuestion`: Exposes CRUD operations for the **McqQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more McqQuestions
    * const mcqQuestions = await prisma.mcqQuestion.findMany()
    * ```
    */
  get mcqQuestion(): Prisma.McqQuestionDelegate<ExtArgs>;

  /**
   * `prisma.listeningScenario`: Exposes CRUD operations for the **ListeningScenario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ListeningScenarios
    * const listeningScenarios = await prisma.listeningScenario.findMany()
    * ```
    */
  get listeningScenario(): Prisma.ListeningScenarioDelegate<ExtArgs>;

  /**
   * `prisma.listeningQuestion`: Exposes CRUD operations for the **ListeningQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ListeningQuestions
    * const listeningQuestions = await prisma.listeningQuestion.findMany()
    * ```
    */
  get listeningQuestion(): Prisma.ListeningQuestionDelegate<ExtArgs>;

  /**
   * `prisma.writingTopic`: Exposes CRUD operations for the **WritingTopic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WritingTopics
    * const writingTopics = await prisma.writingTopic.findMany()
    * ```
    */
  get writingTopic(): Prisma.WritingTopicDelegate<ExtArgs>;

  /**
   * `prisma.speakingSet`: Exposes CRUD operations for the **SpeakingSet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpeakingSets
    * const speakingSets = await prisma.speakingSet.findMany()
    * ```
    */
  get speakingSet(): Prisma.SpeakingSetDelegate<ExtArgs>;

  /**
   * `prisma.speakingPrompt`: Exposes CRUD operations for the **SpeakingPrompt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpeakingPrompts
    * const speakingPrompts = await prisma.speakingPrompt.findMany()
    * ```
    */
  get speakingPrompt(): Prisma.SpeakingPromptDelegate<ExtArgs>;

  /**
   * `prisma.cheatingEvent`: Exposes CRUD operations for the **CheatingEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CheatingEvents
    * const cheatingEvents = await prisma.cheatingEvent.findMany()
    * ```
    */
  get cheatingEvent(): Prisma.CheatingEventDelegate<ExtArgs>;

  /**
   * `prisma.audioResponse`: Exposes CRUD operations for the **AudioResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioResponses
    * const audioResponses = await prisma.audioResponse.findMany()
    * ```
    */
  get audioResponse(): Prisma.AudioResponseDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ExamAttempt: 'ExamAttempt',
    ActiveExam: 'ActiveExam',
    ExamResult: 'ExamResult',
    McqQuestion: 'McqQuestion',
    ListeningScenario: 'ListeningScenario',
    ListeningQuestion: 'ListeningQuestion',
    WritingTopic: 'WritingTopic',
    SpeakingSet: 'SpeakingSet',
    SpeakingPrompt: 'SpeakingPrompt',
    CheatingEvent: 'CheatingEvent',
    AudioResponse: 'AudioResponse',
    Notification: 'Notification',
    PasswordResetToken: 'PasswordResetToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "examAttempt" | "activeExam" | "examResult" | "mcqQuestion" | "listeningScenario" | "listeningQuestion" | "writingTopic" | "speakingSet" | "speakingPrompt" | "cheatingEvent" | "audioResponse" | "notification" | "passwordResetToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ExamAttempt: {
        payload: Prisma.$ExamAttemptPayload<ExtArgs>
        fields: Prisma.ExamAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          findFirst: {
            args: Prisma.ExamAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          findMany: {
            args: Prisma.ExamAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>[]
          }
          create: {
            args: Prisma.ExamAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          createMany: {
            args: Prisma.ExamAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>[]
          }
          delete: {
            args: Prisma.ExamAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          update: {
            args: Prisma.ExamAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          deleteMany: {
            args: Prisma.ExamAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          aggregate: {
            args: Prisma.ExamAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamAttempt>
          }
          groupBy: {
            args: Prisma.ExamAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<ExamAttemptCountAggregateOutputType> | number
          }
        }
      }
      ActiveExam: {
        payload: Prisma.$ActiveExamPayload<ExtArgs>
        fields: Prisma.ActiveExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActiveExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActiveExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveExamPayload>
          }
          findFirst: {
            args: Prisma.ActiveExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActiveExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveExamPayload>
          }
          findMany: {
            args: Prisma.ActiveExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveExamPayload>[]
          }
          create: {
            args: Prisma.ActiveExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveExamPayload>
          }
          createMany: {
            args: Prisma.ActiveExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActiveExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveExamPayload>[]
          }
          delete: {
            args: Prisma.ActiveExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveExamPayload>
          }
          update: {
            args: Prisma.ActiveExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveExamPayload>
          }
          deleteMany: {
            args: Prisma.ActiveExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActiveExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActiveExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveExamPayload>
          }
          aggregate: {
            args: Prisma.ActiveExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActiveExam>
          }
          groupBy: {
            args: Prisma.ActiveExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActiveExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActiveExamCountArgs<ExtArgs>
            result: $Utils.Optional<ActiveExamCountAggregateOutputType> | number
          }
        }
      }
      ExamResult: {
        payload: Prisma.$ExamResultPayload<ExtArgs>
        fields: Prisma.ExamResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>
          }
          findFirst: {
            args: Prisma.ExamResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>
          }
          findMany: {
            args: Prisma.ExamResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>[]
          }
          create: {
            args: Prisma.ExamResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>
          }
          createMany: {
            args: Prisma.ExamResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>[]
          }
          delete: {
            args: Prisma.ExamResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>
          }
          update: {
            args: Prisma.ExamResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>
          }
          deleteMany: {
            args: Prisma.ExamResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamResultPayload>
          }
          aggregate: {
            args: Prisma.ExamResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamResult>
          }
          groupBy: {
            args: Prisma.ExamResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamResultCountArgs<ExtArgs>
            result: $Utils.Optional<ExamResultCountAggregateOutputType> | number
          }
        }
      }
      McqQuestion: {
        payload: Prisma.$McqQuestionPayload<ExtArgs>
        fields: Prisma.McqQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.McqQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.McqQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqQuestionPayload>
          }
          findFirst: {
            args: Prisma.McqQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.McqQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqQuestionPayload>
          }
          findMany: {
            args: Prisma.McqQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqQuestionPayload>[]
          }
          create: {
            args: Prisma.McqQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqQuestionPayload>
          }
          createMany: {
            args: Prisma.McqQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.McqQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqQuestionPayload>[]
          }
          delete: {
            args: Prisma.McqQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqQuestionPayload>
          }
          update: {
            args: Prisma.McqQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqQuestionPayload>
          }
          deleteMany: {
            args: Prisma.McqQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.McqQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.McqQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqQuestionPayload>
          }
          aggregate: {
            args: Prisma.McqQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMcqQuestion>
          }
          groupBy: {
            args: Prisma.McqQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<McqQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.McqQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<McqQuestionCountAggregateOutputType> | number
          }
        }
      }
      ListeningScenario: {
        payload: Prisma.$ListeningScenarioPayload<ExtArgs>
        fields: Prisma.ListeningScenarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListeningScenarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningScenarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListeningScenarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningScenarioPayload>
          }
          findFirst: {
            args: Prisma.ListeningScenarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningScenarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListeningScenarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningScenarioPayload>
          }
          findMany: {
            args: Prisma.ListeningScenarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningScenarioPayload>[]
          }
          create: {
            args: Prisma.ListeningScenarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningScenarioPayload>
          }
          createMany: {
            args: Prisma.ListeningScenarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListeningScenarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningScenarioPayload>[]
          }
          delete: {
            args: Prisma.ListeningScenarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningScenarioPayload>
          }
          update: {
            args: Prisma.ListeningScenarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningScenarioPayload>
          }
          deleteMany: {
            args: Prisma.ListeningScenarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListeningScenarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ListeningScenarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningScenarioPayload>
          }
          aggregate: {
            args: Prisma.ListeningScenarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListeningScenario>
          }
          groupBy: {
            args: Prisma.ListeningScenarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListeningScenarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListeningScenarioCountArgs<ExtArgs>
            result: $Utils.Optional<ListeningScenarioCountAggregateOutputType> | number
          }
        }
      }
      ListeningQuestion: {
        payload: Prisma.$ListeningQuestionPayload<ExtArgs>
        fields: Prisma.ListeningQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListeningQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListeningQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningQuestionPayload>
          }
          findFirst: {
            args: Prisma.ListeningQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListeningQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningQuestionPayload>
          }
          findMany: {
            args: Prisma.ListeningQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningQuestionPayload>[]
          }
          create: {
            args: Prisma.ListeningQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningQuestionPayload>
          }
          createMany: {
            args: Prisma.ListeningQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListeningQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningQuestionPayload>[]
          }
          delete: {
            args: Prisma.ListeningQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningQuestionPayload>
          }
          update: {
            args: Prisma.ListeningQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningQuestionPayload>
          }
          deleteMany: {
            args: Prisma.ListeningQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListeningQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ListeningQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningQuestionPayload>
          }
          aggregate: {
            args: Prisma.ListeningQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListeningQuestion>
          }
          groupBy: {
            args: Prisma.ListeningQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListeningQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListeningQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<ListeningQuestionCountAggregateOutputType> | number
          }
        }
      }
      WritingTopic: {
        payload: Prisma.$WritingTopicPayload<ExtArgs>
        fields: Prisma.WritingTopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WritingTopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WritingTopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WritingTopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WritingTopicPayload>
          }
          findFirst: {
            args: Prisma.WritingTopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WritingTopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WritingTopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WritingTopicPayload>
          }
          findMany: {
            args: Prisma.WritingTopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WritingTopicPayload>[]
          }
          create: {
            args: Prisma.WritingTopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WritingTopicPayload>
          }
          createMany: {
            args: Prisma.WritingTopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WritingTopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WritingTopicPayload>[]
          }
          delete: {
            args: Prisma.WritingTopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WritingTopicPayload>
          }
          update: {
            args: Prisma.WritingTopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WritingTopicPayload>
          }
          deleteMany: {
            args: Prisma.WritingTopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WritingTopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WritingTopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WritingTopicPayload>
          }
          aggregate: {
            args: Prisma.WritingTopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWritingTopic>
          }
          groupBy: {
            args: Prisma.WritingTopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<WritingTopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.WritingTopicCountArgs<ExtArgs>
            result: $Utils.Optional<WritingTopicCountAggregateOutputType> | number
          }
        }
      }
      SpeakingSet: {
        payload: Prisma.$SpeakingSetPayload<ExtArgs>
        fields: Prisma.SpeakingSetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpeakingSetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpeakingSetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSetPayload>
          }
          findFirst: {
            args: Prisma.SpeakingSetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpeakingSetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSetPayload>
          }
          findMany: {
            args: Prisma.SpeakingSetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSetPayload>[]
          }
          create: {
            args: Prisma.SpeakingSetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSetPayload>
          }
          createMany: {
            args: Prisma.SpeakingSetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpeakingSetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSetPayload>[]
          }
          delete: {
            args: Prisma.SpeakingSetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSetPayload>
          }
          update: {
            args: Prisma.SpeakingSetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSetPayload>
          }
          deleteMany: {
            args: Prisma.SpeakingSetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpeakingSetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpeakingSetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSetPayload>
          }
          aggregate: {
            args: Prisma.SpeakingSetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpeakingSet>
          }
          groupBy: {
            args: Prisma.SpeakingSetGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpeakingSetGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpeakingSetCountArgs<ExtArgs>
            result: $Utils.Optional<SpeakingSetCountAggregateOutputType> | number
          }
        }
      }
      SpeakingPrompt: {
        payload: Prisma.$SpeakingPromptPayload<ExtArgs>
        fields: Prisma.SpeakingPromptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpeakingPromptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingPromptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpeakingPromptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingPromptPayload>
          }
          findFirst: {
            args: Prisma.SpeakingPromptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingPromptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpeakingPromptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingPromptPayload>
          }
          findMany: {
            args: Prisma.SpeakingPromptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingPromptPayload>[]
          }
          create: {
            args: Prisma.SpeakingPromptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingPromptPayload>
          }
          createMany: {
            args: Prisma.SpeakingPromptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpeakingPromptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingPromptPayload>[]
          }
          delete: {
            args: Prisma.SpeakingPromptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingPromptPayload>
          }
          update: {
            args: Prisma.SpeakingPromptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingPromptPayload>
          }
          deleteMany: {
            args: Prisma.SpeakingPromptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpeakingPromptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpeakingPromptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingPromptPayload>
          }
          aggregate: {
            args: Prisma.SpeakingPromptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpeakingPrompt>
          }
          groupBy: {
            args: Prisma.SpeakingPromptGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpeakingPromptGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpeakingPromptCountArgs<ExtArgs>
            result: $Utils.Optional<SpeakingPromptCountAggregateOutputType> | number
          }
        }
      }
      CheatingEvent: {
        payload: Prisma.$CheatingEventPayload<ExtArgs>
        fields: Prisma.CheatingEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheatingEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatingEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheatingEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatingEventPayload>
          }
          findFirst: {
            args: Prisma.CheatingEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatingEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheatingEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatingEventPayload>
          }
          findMany: {
            args: Prisma.CheatingEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatingEventPayload>[]
          }
          create: {
            args: Prisma.CheatingEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatingEventPayload>
          }
          createMany: {
            args: Prisma.CheatingEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CheatingEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatingEventPayload>[]
          }
          delete: {
            args: Prisma.CheatingEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatingEventPayload>
          }
          update: {
            args: Prisma.CheatingEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatingEventPayload>
          }
          deleteMany: {
            args: Prisma.CheatingEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CheatingEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CheatingEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatingEventPayload>
          }
          aggregate: {
            args: Prisma.CheatingEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheatingEvent>
          }
          groupBy: {
            args: Prisma.CheatingEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheatingEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheatingEventCountArgs<ExtArgs>
            result: $Utils.Optional<CheatingEventCountAggregateOutputType> | number
          }
        }
      }
      AudioResponse: {
        payload: Prisma.$AudioResponsePayload<ExtArgs>
        fields: Prisma.AudioResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioResponsePayload>
          }
          findFirst: {
            args: Prisma.AudioResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioResponsePayload>
          }
          findMany: {
            args: Prisma.AudioResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioResponsePayload>[]
          }
          create: {
            args: Prisma.AudioResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioResponsePayload>
          }
          createMany: {
            args: Prisma.AudioResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioResponsePayload>[]
          }
          delete: {
            args: Prisma.AudioResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioResponsePayload>
          }
          update: {
            args: Prisma.AudioResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioResponsePayload>
          }
          deleteMany: {
            args: Prisma.AudioResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AudioResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioResponsePayload>
          }
          aggregate: {
            args: Prisma.AudioResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioResponse>
          }
          groupBy: {
            args: Prisma.AudioResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioResponseCountArgs<ExtArgs>
            result: $Utils.Optional<AudioResponseCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    examResults: number
    attempts: number
    notifications: number
    resetTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examResults?: boolean | UserCountOutputTypeCountExamResultsArgs
    attempts?: boolean | UserCountOutputTypeCountAttemptsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    resetTokens?: boolean | UserCountOutputTypeCountResetTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExamResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamResultWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAttemptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }


  /**
   * Count Type ExamAttemptCountOutputType
   */

  export type ExamAttemptCountOutputType = {
    cheatingEvents: number
    audioResponses: number
  }

  export type ExamAttemptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cheatingEvents?: boolean | ExamAttemptCountOutputTypeCountCheatingEventsArgs
    audioResponses?: boolean | ExamAttemptCountOutputTypeCountAudioResponsesArgs
  }

  // Custom InputTypes
  /**
   * ExamAttemptCountOutputType without action
   */
  export type ExamAttemptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttemptCountOutputType
     */
    select?: ExamAttemptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamAttemptCountOutputType without action
   */
  export type ExamAttemptCountOutputTypeCountCheatingEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheatingEventWhereInput
  }

  /**
   * ExamAttemptCountOutputType without action
   */
  export type ExamAttemptCountOutputTypeCountAudioResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioResponseWhereInput
  }


  /**
   * Count Type ListeningScenarioCountOutputType
   */

  export type ListeningScenarioCountOutputType = {
    questions: number
    attempts: number
  }

  export type ListeningScenarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | ListeningScenarioCountOutputTypeCountQuestionsArgs
    attempts?: boolean | ListeningScenarioCountOutputTypeCountAttemptsArgs
  }

  // Custom InputTypes
  /**
   * ListeningScenarioCountOutputType without action
   */
  export type ListeningScenarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningScenarioCountOutputType
     */
    select?: ListeningScenarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ListeningScenarioCountOutputType without action
   */
  export type ListeningScenarioCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListeningQuestionWhereInput
  }

  /**
   * ListeningScenarioCountOutputType without action
   */
  export type ListeningScenarioCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAttemptWhereInput
  }


  /**
   * Count Type WritingTopicCountOutputType
   */

  export type WritingTopicCountOutputType = {
    attempts: number
  }

  export type WritingTopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempts?: boolean | WritingTopicCountOutputTypeCountAttemptsArgs
  }

  // Custom InputTypes
  /**
   * WritingTopicCountOutputType without action
   */
  export type WritingTopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingTopicCountOutputType
     */
    select?: WritingTopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WritingTopicCountOutputType without action
   */
  export type WritingTopicCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAttemptWhereInput
  }


  /**
   * Count Type SpeakingSetCountOutputType
   */

  export type SpeakingSetCountOutputType = {
    prompts: number
    attempts: number
  }

  export type SpeakingSetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompts?: boolean | SpeakingSetCountOutputTypeCountPromptsArgs
    attempts?: boolean | SpeakingSetCountOutputTypeCountAttemptsArgs
  }

  // Custom InputTypes
  /**
   * SpeakingSetCountOutputType without action
   */
  export type SpeakingSetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSetCountOutputType
     */
    select?: SpeakingSetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpeakingSetCountOutputType without action
   */
  export type SpeakingSetCountOutputTypeCountPromptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakingPromptWhereInput
  }

  /**
   * SpeakingSetCountOutputType without action
   */
  export type SpeakingSetCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAttemptWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    emailVerifiedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    emailVerifiedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    name: number
    createdAt: number
    updatedAt: number
    emailVerifiedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    emailVerifiedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    emailVerifiedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    emailVerifiedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    role: string
    name: string | null
    createdAt: Date
    updatedAt: Date
    emailVerifiedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailVerifiedAt?: boolean
    examResults?: boolean | User$examResultsArgs<ExtArgs>
    attempts?: boolean | User$attemptsArgs<ExtArgs>
    activeExam?: boolean | User$activeExamArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    resetTokens?: boolean | User$resetTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailVerifiedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailVerifiedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examResults?: boolean | User$examResultsArgs<ExtArgs>
    attempts?: boolean | User$attemptsArgs<ExtArgs>
    activeExam?: boolean | User$activeExamArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    resetTokens?: boolean | User$resetTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      examResults: Prisma.$ExamResultPayload<ExtArgs>[]
      attempts: Prisma.$ExamAttemptPayload<ExtArgs>[]
      activeExam: Prisma.$ActiveExamPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      resetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      role: string
      name: string | null
      createdAt: Date
      updatedAt: Date
      emailVerifiedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examResults<T extends User$examResultsArgs<ExtArgs> = {}>(args?: Subset<T, User$examResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "findMany"> | Null>
    attempts<T extends User$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, User$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    activeExam<T extends User$activeExamArgs<ExtArgs> = {}>(args?: Subset<T, User$activeExamArgs<ExtArgs>>): Prisma__ActiveExamClient<$Result.GetResult<Prisma.$ActiveExamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    resetTokens<T extends User$resetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$resetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.examResults
   */
  export type User$examResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    where?: ExamResultWhereInput
    orderBy?: ExamResultOrderByWithRelationInput | ExamResultOrderByWithRelationInput[]
    cursor?: ExamResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamResultScalarFieldEnum | ExamResultScalarFieldEnum[]
  }

  /**
   * User.attempts
   */
  export type User$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    where?: ExamAttemptWhereInput
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    cursor?: ExamAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * User.activeExam
   */
  export type User$activeExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveExam
     */
    select?: ActiveExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveExamInclude<ExtArgs> | null
    where?: ActiveExamWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.resetTokens
   */
  export type User$resetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ExamAttempt
   */

  export type AggregateExamAttempt = {
    _count: ExamAttemptCountAggregateOutputType | null
    _avg: ExamAttemptAvgAggregateOutputType | null
    _sum: ExamAttemptSumAggregateOutputType | null
    _min: ExamAttemptMinAggregateOutputType | null
    _max: ExamAttemptMaxAggregateOutputType | null
  }

  export type ExamAttemptAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    listeningScenarioId: number | null
    writingTopicId: number | null
    speakingSetId: number | null
    speakingScore: number | null
  }

  export type ExamAttemptSumAggregateOutputType = {
    id: number | null
    userId: number | null
    listeningScenarioId: number | null
    writingTopicId: number | null
    speakingSetId: number | null
    speakingScore: number | null
  }

  export type ExamAttemptMinAggregateOutputType = {
    id: number | null
    userId: number | null
    status: string | null
    createdAt: Date | null
    submittedAt: Date | null
    mcqQuestionIds: string | null
    listeningScenarioId: number | null
    writingTopicId: number | null
    speakingSetId: number | null
    mcqAnswers: string | null
    listeningAnswers: string | null
    writingAnswer: string | null
    speakingTranscript: string | null
    speakingScore: number | null
  }

  export type ExamAttemptMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    status: string | null
    createdAt: Date | null
    submittedAt: Date | null
    mcqQuestionIds: string | null
    listeningScenarioId: number | null
    writingTopicId: number | null
    speakingSetId: number | null
    mcqAnswers: string | null
    listeningAnswers: string | null
    writingAnswer: string | null
    speakingTranscript: string | null
    speakingScore: number | null
  }

  export type ExamAttemptCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    createdAt: number
    submittedAt: number
    mcqQuestionIds: number
    listeningScenarioId: number
    writingTopicId: number
    speakingSetId: number
    mcqAnswers: number
    listeningAnswers: number
    writingAnswer: number
    speakingTranscript: number
    speakingScore: number
    _all: number
  }


  export type ExamAttemptAvgAggregateInputType = {
    id?: true
    userId?: true
    listeningScenarioId?: true
    writingTopicId?: true
    speakingSetId?: true
    speakingScore?: true
  }

  export type ExamAttemptSumAggregateInputType = {
    id?: true
    userId?: true
    listeningScenarioId?: true
    writingTopicId?: true
    speakingSetId?: true
    speakingScore?: true
  }

  export type ExamAttemptMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    createdAt?: true
    submittedAt?: true
    mcqQuestionIds?: true
    listeningScenarioId?: true
    writingTopicId?: true
    speakingSetId?: true
    mcqAnswers?: true
    listeningAnswers?: true
    writingAnswer?: true
    speakingTranscript?: true
    speakingScore?: true
  }

  export type ExamAttemptMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    createdAt?: true
    submittedAt?: true
    mcqQuestionIds?: true
    listeningScenarioId?: true
    writingTopicId?: true
    speakingSetId?: true
    mcqAnswers?: true
    listeningAnswers?: true
    writingAnswer?: true
    speakingTranscript?: true
    speakingScore?: true
  }

  export type ExamAttemptCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    createdAt?: true
    submittedAt?: true
    mcqQuestionIds?: true
    listeningScenarioId?: true
    writingTopicId?: true
    speakingSetId?: true
    mcqAnswers?: true
    listeningAnswers?: true
    writingAnswer?: true
    speakingTranscript?: true
    speakingScore?: true
    _all?: true
  }

  export type ExamAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamAttempt to aggregate.
     */
    where?: ExamAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAttempts to fetch.
     */
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamAttempts
    **/
    _count?: true | ExamAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamAttemptMaxAggregateInputType
  }

  export type GetExamAttemptAggregateType<T extends ExamAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateExamAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamAttempt[P]>
      : GetScalarType<T[P], AggregateExamAttempt[P]>
  }




  export type ExamAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAttemptWhereInput
    orderBy?: ExamAttemptOrderByWithAggregationInput | ExamAttemptOrderByWithAggregationInput[]
    by: ExamAttemptScalarFieldEnum[] | ExamAttemptScalarFieldEnum
    having?: ExamAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamAttemptCountAggregateInputType | true
    _avg?: ExamAttemptAvgAggregateInputType
    _sum?: ExamAttemptSumAggregateInputType
    _min?: ExamAttemptMinAggregateInputType
    _max?: ExamAttemptMaxAggregateInputType
  }

  export type ExamAttemptGroupByOutputType = {
    id: number
    userId: number
    status: string
    createdAt: Date
    submittedAt: Date | null
    mcqQuestionIds: string | null
    listeningScenarioId: number | null
    writingTopicId: number | null
    speakingSetId: number | null
    mcqAnswers: string | null
    listeningAnswers: string | null
    writingAnswer: string | null
    speakingTranscript: string | null
    speakingScore: number | null
    _count: ExamAttemptCountAggregateOutputType | null
    _avg: ExamAttemptAvgAggregateOutputType | null
    _sum: ExamAttemptSumAggregateOutputType | null
    _min: ExamAttemptMinAggregateOutputType | null
    _max: ExamAttemptMaxAggregateOutputType | null
  }

  type GetExamAttemptGroupByPayload<T extends ExamAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], ExamAttemptGroupByOutputType[P]>
        }
      >
    >


  export type ExamAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    submittedAt?: boolean
    mcqQuestionIds?: boolean
    listeningScenarioId?: boolean
    writingTopicId?: boolean
    speakingSetId?: boolean
    mcqAnswers?: boolean
    listeningAnswers?: boolean
    writingAnswer?: boolean
    speakingTranscript?: boolean
    speakingScore?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    listeningScenario?: boolean | ExamAttempt$listeningScenarioArgs<ExtArgs>
    writingTopic?: boolean | ExamAttempt$writingTopicArgs<ExtArgs>
    speakingSet?: boolean | ExamAttempt$speakingSetArgs<ExtArgs>
    result?: boolean | ExamAttempt$resultArgs<ExtArgs>
    cheatingEvents?: boolean | ExamAttempt$cheatingEventsArgs<ExtArgs>
    audioResponses?: boolean | ExamAttempt$audioResponsesArgs<ExtArgs>
    activeExam?: boolean | ExamAttempt$activeExamArgs<ExtArgs>
    _count?: boolean | ExamAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examAttempt"]>

  export type ExamAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    submittedAt?: boolean
    mcqQuestionIds?: boolean
    listeningScenarioId?: boolean
    writingTopicId?: boolean
    speakingSetId?: boolean
    mcqAnswers?: boolean
    listeningAnswers?: boolean
    writingAnswer?: boolean
    speakingTranscript?: boolean
    speakingScore?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    listeningScenario?: boolean | ExamAttempt$listeningScenarioArgs<ExtArgs>
    writingTopic?: boolean | ExamAttempt$writingTopicArgs<ExtArgs>
    speakingSet?: boolean | ExamAttempt$speakingSetArgs<ExtArgs>
  }, ExtArgs["result"]["examAttempt"]>

  export type ExamAttemptSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    submittedAt?: boolean
    mcqQuestionIds?: boolean
    listeningScenarioId?: boolean
    writingTopicId?: boolean
    speakingSetId?: boolean
    mcqAnswers?: boolean
    listeningAnswers?: boolean
    writingAnswer?: boolean
    speakingTranscript?: boolean
    speakingScore?: boolean
  }

  export type ExamAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    listeningScenario?: boolean | ExamAttempt$listeningScenarioArgs<ExtArgs>
    writingTopic?: boolean | ExamAttempt$writingTopicArgs<ExtArgs>
    speakingSet?: boolean | ExamAttempt$speakingSetArgs<ExtArgs>
    result?: boolean | ExamAttempt$resultArgs<ExtArgs>
    cheatingEvents?: boolean | ExamAttempt$cheatingEventsArgs<ExtArgs>
    audioResponses?: boolean | ExamAttempt$audioResponsesArgs<ExtArgs>
    activeExam?: boolean | ExamAttempt$activeExamArgs<ExtArgs>
    _count?: boolean | ExamAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExamAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    listeningScenario?: boolean | ExamAttempt$listeningScenarioArgs<ExtArgs>
    writingTopic?: boolean | ExamAttempt$writingTopicArgs<ExtArgs>
    speakingSet?: boolean | ExamAttempt$speakingSetArgs<ExtArgs>
  }

  export type $ExamAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamAttempt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      listeningScenario: Prisma.$ListeningScenarioPayload<ExtArgs> | null
      writingTopic: Prisma.$WritingTopicPayload<ExtArgs> | null
      speakingSet: Prisma.$SpeakingSetPayload<ExtArgs> | null
      result: Prisma.$ExamResultPayload<ExtArgs> | null
      cheatingEvents: Prisma.$CheatingEventPayload<ExtArgs>[]
      audioResponses: Prisma.$AudioResponsePayload<ExtArgs>[]
      activeExam: Prisma.$ActiveExamPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      status: string
      createdAt: Date
      submittedAt: Date | null
      mcqQuestionIds: string | null
      listeningScenarioId: number | null
      writingTopicId: number | null
      speakingSetId: number | null
      mcqAnswers: string | null
      listeningAnswers: string | null
      writingAnswer: string | null
      speakingTranscript: string | null
      speakingScore: number | null
    }, ExtArgs["result"]["examAttempt"]>
    composites: {}
  }

  type ExamAttemptGetPayload<S extends boolean | null | undefined | ExamAttemptDefaultArgs> = $Result.GetResult<Prisma.$ExamAttemptPayload, S>

  type ExamAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamAttemptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamAttemptCountAggregateInputType | true
    }

  export interface ExamAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamAttempt'], meta: { name: 'ExamAttempt' } }
    /**
     * Find zero or one ExamAttempt that matches the filter.
     * @param {ExamAttemptFindUniqueArgs} args - Arguments to find a ExamAttempt
     * @example
     * // Get one ExamAttempt
     * const examAttempt = await prisma.examAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamAttemptFindUniqueArgs>(args: SelectSubset<T, ExamAttemptFindUniqueArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExamAttempt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamAttemptFindUniqueOrThrowArgs} args - Arguments to find a ExamAttempt
     * @example
     * // Get one ExamAttempt
     * const examAttempt = await prisma.examAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExamAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptFindFirstArgs} args - Arguments to find a ExamAttempt
     * @example
     * // Get one ExamAttempt
     * const examAttempt = await prisma.examAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamAttemptFindFirstArgs>(args?: SelectSubset<T, ExamAttemptFindFirstArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExamAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptFindFirstOrThrowArgs} args - Arguments to find a ExamAttempt
     * @example
     * // Get one ExamAttempt
     * const examAttempt = await prisma.examAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExamAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamAttempts
     * const examAttempts = await prisma.examAttempt.findMany()
     * 
     * // Get first 10 ExamAttempts
     * const examAttempts = await prisma.examAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examAttemptWithIdOnly = await prisma.examAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamAttemptFindManyArgs>(args?: SelectSubset<T, ExamAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExamAttempt.
     * @param {ExamAttemptCreateArgs} args - Arguments to create a ExamAttempt.
     * @example
     * // Create one ExamAttempt
     * const ExamAttempt = await prisma.examAttempt.create({
     *   data: {
     *     // ... data to create a ExamAttempt
     *   }
     * })
     * 
     */
    create<T extends ExamAttemptCreateArgs>(args: SelectSubset<T, ExamAttemptCreateArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExamAttempts.
     * @param {ExamAttemptCreateManyArgs} args - Arguments to create many ExamAttempts.
     * @example
     * // Create many ExamAttempts
     * const examAttempt = await prisma.examAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamAttemptCreateManyArgs>(args?: SelectSubset<T, ExamAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamAttempts and returns the data saved in the database.
     * @param {ExamAttemptCreateManyAndReturnArgs} args - Arguments to create many ExamAttempts.
     * @example
     * // Create many ExamAttempts
     * const examAttempt = await prisma.examAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamAttempts and only return the `id`
     * const examAttemptWithIdOnly = await prisma.examAttempt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExamAttempt.
     * @param {ExamAttemptDeleteArgs} args - Arguments to delete one ExamAttempt.
     * @example
     * // Delete one ExamAttempt
     * const ExamAttempt = await prisma.examAttempt.delete({
     *   where: {
     *     // ... filter to delete one ExamAttempt
     *   }
     * })
     * 
     */
    delete<T extends ExamAttemptDeleteArgs>(args: SelectSubset<T, ExamAttemptDeleteArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExamAttempt.
     * @param {ExamAttemptUpdateArgs} args - Arguments to update one ExamAttempt.
     * @example
     * // Update one ExamAttempt
     * const examAttempt = await prisma.examAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamAttemptUpdateArgs>(args: SelectSubset<T, ExamAttemptUpdateArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExamAttempts.
     * @param {ExamAttemptDeleteManyArgs} args - Arguments to filter ExamAttempts to delete.
     * @example
     * // Delete a few ExamAttempts
     * const { count } = await prisma.examAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamAttemptDeleteManyArgs>(args?: SelectSubset<T, ExamAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamAttempts
     * const examAttempt = await prisma.examAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamAttemptUpdateManyArgs>(args: SelectSubset<T, ExamAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamAttempt.
     * @param {ExamAttemptUpsertArgs} args - Arguments to update or create a ExamAttempt.
     * @example
     * // Update or create a ExamAttempt
     * const examAttempt = await prisma.examAttempt.upsert({
     *   create: {
     *     // ... data to create a ExamAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamAttempt we want to update
     *   }
     * })
     */
    upsert<T extends ExamAttemptUpsertArgs>(args: SelectSubset<T, ExamAttemptUpsertArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExamAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptCountArgs} args - Arguments to filter ExamAttempts to count.
     * @example
     * // Count the number of ExamAttempts
     * const count = await prisma.examAttempt.count({
     *   where: {
     *     // ... the filter for the ExamAttempts we want to count
     *   }
     * })
    **/
    count<T extends ExamAttemptCountArgs>(
      args?: Subset<T, ExamAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAttemptAggregateArgs>(args: Subset<T, ExamAttemptAggregateArgs>): Prisma.PrismaPromise<GetExamAttemptAggregateType<T>>

    /**
     * Group by ExamAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamAttemptGroupByArgs['orderBy'] }
        : { orderBy?: ExamAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamAttempt model
   */
  readonly fields: ExamAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    listeningScenario<T extends ExamAttempt$listeningScenarioArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttempt$listeningScenarioArgs<ExtArgs>>): Prisma__ListeningScenarioClient<$Result.GetResult<Prisma.$ListeningScenarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    writingTopic<T extends ExamAttempt$writingTopicArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttempt$writingTopicArgs<ExtArgs>>): Prisma__WritingTopicClient<$Result.GetResult<Prisma.$WritingTopicPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    speakingSet<T extends ExamAttempt$speakingSetArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttempt$speakingSetArgs<ExtArgs>>): Prisma__SpeakingSetClient<$Result.GetResult<Prisma.$SpeakingSetPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    result<T extends ExamAttempt$resultArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttempt$resultArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    cheatingEvents<T extends ExamAttempt$cheatingEventsArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttempt$cheatingEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheatingEventPayload<ExtArgs>, T, "findMany"> | Null>
    audioResponses<T extends ExamAttempt$audioResponsesArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttempt$audioResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioResponsePayload<ExtArgs>, T, "findMany"> | Null>
    activeExam<T extends ExamAttempt$activeExamArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttempt$activeExamArgs<ExtArgs>>): Prisma__ActiveExamClient<$Result.GetResult<Prisma.$ActiveExamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamAttempt model
   */ 
  interface ExamAttemptFieldRefs {
    readonly id: FieldRef<"ExamAttempt", 'Int'>
    readonly userId: FieldRef<"ExamAttempt", 'Int'>
    readonly status: FieldRef<"ExamAttempt", 'String'>
    readonly createdAt: FieldRef<"ExamAttempt", 'DateTime'>
    readonly submittedAt: FieldRef<"ExamAttempt", 'DateTime'>
    readonly mcqQuestionIds: FieldRef<"ExamAttempt", 'String'>
    readonly listeningScenarioId: FieldRef<"ExamAttempt", 'Int'>
    readonly writingTopicId: FieldRef<"ExamAttempt", 'Int'>
    readonly speakingSetId: FieldRef<"ExamAttempt", 'Int'>
    readonly mcqAnswers: FieldRef<"ExamAttempt", 'String'>
    readonly listeningAnswers: FieldRef<"ExamAttempt", 'String'>
    readonly writingAnswer: FieldRef<"ExamAttempt", 'String'>
    readonly speakingTranscript: FieldRef<"ExamAttempt", 'String'>
    readonly speakingScore: FieldRef<"ExamAttempt", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ExamAttempt findUnique
   */
  export type ExamAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempt to fetch.
     */
    where: ExamAttemptWhereUniqueInput
  }

  /**
   * ExamAttempt findUniqueOrThrow
   */
  export type ExamAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempt to fetch.
     */
    where: ExamAttemptWhereUniqueInput
  }

  /**
   * ExamAttempt findFirst
   */
  export type ExamAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempt to fetch.
     */
    where?: ExamAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAttempts to fetch.
     */
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamAttempts.
     */
    cursor?: ExamAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamAttempts.
     */
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * ExamAttempt findFirstOrThrow
   */
  export type ExamAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempt to fetch.
     */
    where?: ExamAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAttempts to fetch.
     */
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamAttempts.
     */
    cursor?: ExamAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamAttempts.
     */
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * ExamAttempt findMany
   */
  export type ExamAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempts to fetch.
     */
    where?: ExamAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAttempts to fetch.
     */
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamAttempts.
     */
    cursor?: ExamAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAttempts.
     */
    skip?: number
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * ExamAttempt create
   */
  export type ExamAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamAttempt.
     */
    data: XOR<ExamAttemptCreateInput, ExamAttemptUncheckedCreateInput>
  }

  /**
   * ExamAttempt createMany
   */
  export type ExamAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamAttempts.
     */
    data: ExamAttemptCreateManyInput | ExamAttemptCreateManyInput[]
  }

  /**
   * ExamAttempt createManyAndReturn
   */
  export type ExamAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExamAttempts.
     */
    data: ExamAttemptCreateManyInput | ExamAttemptCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamAttempt update
   */
  export type ExamAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamAttempt.
     */
    data: XOR<ExamAttemptUpdateInput, ExamAttemptUncheckedUpdateInput>
    /**
     * Choose, which ExamAttempt to update.
     */
    where: ExamAttemptWhereUniqueInput
  }

  /**
   * ExamAttempt updateMany
   */
  export type ExamAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamAttempts.
     */
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyInput>
    /**
     * Filter which ExamAttempts to update
     */
    where?: ExamAttemptWhereInput
  }

  /**
   * ExamAttempt upsert
   */
  export type ExamAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamAttempt to update in case it exists.
     */
    where: ExamAttemptWhereUniqueInput
    /**
     * In case the ExamAttempt found by the `where` argument doesn't exist, create a new ExamAttempt with this data.
     */
    create: XOR<ExamAttemptCreateInput, ExamAttemptUncheckedCreateInput>
    /**
     * In case the ExamAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamAttemptUpdateInput, ExamAttemptUncheckedUpdateInput>
  }

  /**
   * ExamAttempt delete
   */
  export type ExamAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter which ExamAttempt to delete.
     */
    where: ExamAttemptWhereUniqueInput
  }

  /**
   * ExamAttempt deleteMany
   */
  export type ExamAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamAttempts to delete
     */
    where?: ExamAttemptWhereInput
  }

  /**
   * ExamAttempt.listeningScenario
   */
  export type ExamAttempt$listeningScenarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningScenario
     */
    select?: ListeningScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningScenarioInclude<ExtArgs> | null
    where?: ListeningScenarioWhereInput
  }

  /**
   * ExamAttempt.writingTopic
   */
  export type ExamAttempt$writingTopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingTopic
     */
    select?: WritingTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WritingTopicInclude<ExtArgs> | null
    where?: WritingTopicWhereInput
  }

  /**
   * ExamAttempt.speakingSet
   */
  export type ExamAttempt$speakingSetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSet
     */
    select?: SpeakingSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSetInclude<ExtArgs> | null
    where?: SpeakingSetWhereInput
  }

  /**
   * ExamAttempt.result
   */
  export type ExamAttempt$resultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    where?: ExamResultWhereInput
  }

  /**
   * ExamAttempt.cheatingEvents
   */
  export type ExamAttempt$cheatingEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatingEvent
     */
    select?: CheatingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatingEventInclude<ExtArgs> | null
    where?: CheatingEventWhereInput
    orderBy?: CheatingEventOrderByWithRelationInput | CheatingEventOrderByWithRelationInput[]
    cursor?: CheatingEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheatingEventScalarFieldEnum | CheatingEventScalarFieldEnum[]
  }

  /**
   * ExamAttempt.audioResponses
   */
  export type ExamAttempt$audioResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioResponse
     */
    select?: AudioResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioResponseInclude<ExtArgs> | null
    where?: AudioResponseWhereInput
    orderBy?: AudioResponseOrderByWithRelationInput | AudioResponseOrderByWithRelationInput[]
    cursor?: AudioResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioResponseScalarFieldEnum | AudioResponseScalarFieldEnum[]
  }

  /**
   * ExamAttempt.activeExam
   */
  export type ExamAttempt$activeExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveExam
     */
    select?: ActiveExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveExamInclude<ExtArgs> | null
    where?: ActiveExamWhereInput
  }

  /**
   * ExamAttempt without action
   */
  export type ExamAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
  }


  /**
   * Model ActiveExam
   */

  export type AggregateActiveExam = {
    _count: ActiveExamCountAggregateOutputType | null
    _avg: ActiveExamAvgAggregateOutputType | null
    _sum: ActiveExamSumAggregateOutputType | null
    _min: ActiveExamMinAggregateOutputType | null
    _max: ActiveExamMaxAggregateOutputType | null
  }

  export type ActiveExamAvgAggregateOutputType = {
    userId: number | null
    attemptId: number | null
  }

  export type ActiveExamSumAggregateOutputType = {
    userId: number | null
    attemptId: number | null
  }

  export type ActiveExamMinAggregateOutputType = {
    userId: number | null
    attemptId: number | null
    createdAt: Date | null
    mcqCorrect: string | null
    listeningCorrect: string | null
  }

  export type ActiveExamMaxAggregateOutputType = {
    userId: number | null
    attemptId: number | null
    createdAt: Date | null
    mcqCorrect: string | null
    listeningCorrect: string | null
  }

  export type ActiveExamCountAggregateOutputType = {
    userId: number
    attemptId: number
    createdAt: number
    mcqCorrect: number
    listeningCorrect: number
    _all: number
  }


  export type ActiveExamAvgAggregateInputType = {
    userId?: true
    attemptId?: true
  }

  export type ActiveExamSumAggregateInputType = {
    userId?: true
    attemptId?: true
  }

  export type ActiveExamMinAggregateInputType = {
    userId?: true
    attemptId?: true
    createdAt?: true
    mcqCorrect?: true
    listeningCorrect?: true
  }

  export type ActiveExamMaxAggregateInputType = {
    userId?: true
    attemptId?: true
    createdAt?: true
    mcqCorrect?: true
    listeningCorrect?: true
  }

  export type ActiveExamCountAggregateInputType = {
    userId?: true
    attemptId?: true
    createdAt?: true
    mcqCorrect?: true
    listeningCorrect?: true
    _all?: true
  }

  export type ActiveExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActiveExam to aggregate.
     */
    where?: ActiveExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveExams to fetch.
     */
    orderBy?: ActiveExamOrderByWithRelationInput | ActiveExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActiveExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActiveExams
    **/
    _count?: true | ActiveExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActiveExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActiveExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActiveExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActiveExamMaxAggregateInputType
  }

  export type GetActiveExamAggregateType<T extends ActiveExamAggregateArgs> = {
        [P in keyof T & keyof AggregateActiveExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActiveExam[P]>
      : GetScalarType<T[P], AggregateActiveExam[P]>
  }




  export type ActiveExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActiveExamWhereInput
    orderBy?: ActiveExamOrderByWithAggregationInput | ActiveExamOrderByWithAggregationInput[]
    by: ActiveExamScalarFieldEnum[] | ActiveExamScalarFieldEnum
    having?: ActiveExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActiveExamCountAggregateInputType | true
    _avg?: ActiveExamAvgAggregateInputType
    _sum?: ActiveExamSumAggregateInputType
    _min?: ActiveExamMinAggregateInputType
    _max?: ActiveExamMaxAggregateInputType
  }

  export type ActiveExamGroupByOutputType = {
    userId: number
    attemptId: number
    createdAt: Date
    mcqCorrect: string
    listeningCorrect: string
    _count: ActiveExamCountAggregateOutputType | null
    _avg: ActiveExamAvgAggregateOutputType | null
    _sum: ActiveExamSumAggregateOutputType | null
    _min: ActiveExamMinAggregateOutputType | null
    _max: ActiveExamMaxAggregateOutputType | null
  }

  type GetActiveExamGroupByPayload<T extends ActiveExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActiveExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActiveExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActiveExamGroupByOutputType[P]>
            : GetScalarType<T[P], ActiveExamGroupByOutputType[P]>
        }
      >
    >


  export type ActiveExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    attemptId?: boolean
    createdAt?: boolean
    mcqCorrect?: boolean
    listeningCorrect?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activeExam"]>

  export type ActiveExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    attemptId?: boolean
    createdAt?: boolean
    mcqCorrect?: boolean
    listeningCorrect?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activeExam"]>

  export type ActiveExamSelectScalar = {
    userId?: boolean
    attemptId?: boolean
    createdAt?: boolean
    mcqCorrect?: boolean
    listeningCorrect?: boolean
  }

  export type ActiveExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
  }
  export type ActiveExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
  }

  export type $ActiveExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActiveExam"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      attempt: Prisma.$ExamAttemptPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      attemptId: number
      createdAt: Date
      mcqCorrect: string
      listeningCorrect: string
    }, ExtArgs["result"]["activeExam"]>
    composites: {}
  }

  type ActiveExamGetPayload<S extends boolean | null | undefined | ActiveExamDefaultArgs> = $Result.GetResult<Prisma.$ActiveExamPayload, S>

  type ActiveExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActiveExamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActiveExamCountAggregateInputType | true
    }

  export interface ActiveExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActiveExam'], meta: { name: 'ActiveExam' } }
    /**
     * Find zero or one ActiveExam that matches the filter.
     * @param {ActiveExamFindUniqueArgs} args - Arguments to find a ActiveExam
     * @example
     * // Get one ActiveExam
     * const activeExam = await prisma.activeExam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActiveExamFindUniqueArgs>(args: SelectSubset<T, ActiveExamFindUniqueArgs<ExtArgs>>): Prisma__ActiveExamClient<$Result.GetResult<Prisma.$ActiveExamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActiveExam that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActiveExamFindUniqueOrThrowArgs} args - Arguments to find a ActiveExam
     * @example
     * // Get one ActiveExam
     * const activeExam = await prisma.activeExam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActiveExamFindUniqueOrThrowArgs>(args: SelectSubset<T, ActiveExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActiveExamClient<$Result.GetResult<Prisma.$ActiveExamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActiveExam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveExamFindFirstArgs} args - Arguments to find a ActiveExam
     * @example
     * // Get one ActiveExam
     * const activeExam = await prisma.activeExam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActiveExamFindFirstArgs>(args?: SelectSubset<T, ActiveExamFindFirstArgs<ExtArgs>>): Prisma__ActiveExamClient<$Result.GetResult<Prisma.$ActiveExamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActiveExam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveExamFindFirstOrThrowArgs} args - Arguments to find a ActiveExam
     * @example
     * // Get one ActiveExam
     * const activeExam = await prisma.activeExam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActiveExamFindFirstOrThrowArgs>(args?: SelectSubset<T, ActiveExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActiveExamClient<$Result.GetResult<Prisma.$ActiveExamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActiveExams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActiveExams
     * const activeExams = await prisma.activeExam.findMany()
     * 
     * // Get first 10 ActiveExams
     * const activeExams = await prisma.activeExam.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const activeExamWithUserIdOnly = await prisma.activeExam.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends ActiveExamFindManyArgs>(args?: SelectSubset<T, ActiveExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiveExamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActiveExam.
     * @param {ActiveExamCreateArgs} args - Arguments to create a ActiveExam.
     * @example
     * // Create one ActiveExam
     * const ActiveExam = await prisma.activeExam.create({
     *   data: {
     *     // ... data to create a ActiveExam
     *   }
     * })
     * 
     */
    create<T extends ActiveExamCreateArgs>(args: SelectSubset<T, ActiveExamCreateArgs<ExtArgs>>): Prisma__ActiveExamClient<$Result.GetResult<Prisma.$ActiveExamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActiveExams.
     * @param {ActiveExamCreateManyArgs} args - Arguments to create many ActiveExams.
     * @example
     * // Create many ActiveExams
     * const activeExam = await prisma.activeExam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActiveExamCreateManyArgs>(args?: SelectSubset<T, ActiveExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActiveExams and returns the data saved in the database.
     * @param {ActiveExamCreateManyAndReturnArgs} args - Arguments to create many ActiveExams.
     * @example
     * // Create many ActiveExams
     * const activeExam = await prisma.activeExam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActiveExams and only return the `userId`
     * const activeExamWithUserIdOnly = await prisma.activeExam.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActiveExamCreateManyAndReturnArgs>(args?: SelectSubset<T, ActiveExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiveExamPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActiveExam.
     * @param {ActiveExamDeleteArgs} args - Arguments to delete one ActiveExam.
     * @example
     * // Delete one ActiveExam
     * const ActiveExam = await prisma.activeExam.delete({
     *   where: {
     *     // ... filter to delete one ActiveExam
     *   }
     * })
     * 
     */
    delete<T extends ActiveExamDeleteArgs>(args: SelectSubset<T, ActiveExamDeleteArgs<ExtArgs>>): Prisma__ActiveExamClient<$Result.GetResult<Prisma.$ActiveExamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActiveExam.
     * @param {ActiveExamUpdateArgs} args - Arguments to update one ActiveExam.
     * @example
     * // Update one ActiveExam
     * const activeExam = await prisma.activeExam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActiveExamUpdateArgs>(args: SelectSubset<T, ActiveExamUpdateArgs<ExtArgs>>): Prisma__ActiveExamClient<$Result.GetResult<Prisma.$ActiveExamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActiveExams.
     * @param {ActiveExamDeleteManyArgs} args - Arguments to filter ActiveExams to delete.
     * @example
     * // Delete a few ActiveExams
     * const { count } = await prisma.activeExam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActiveExamDeleteManyArgs>(args?: SelectSubset<T, ActiveExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActiveExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActiveExams
     * const activeExam = await prisma.activeExam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActiveExamUpdateManyArgs>(args: SelectSubset<T, ActiveExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActiveExam.
     * @param {ActiveExamUpsertArgs} args - Arguments to update or create a ActiveExam.
     * @example
     * // Update or create a ActiveExam
     * const activeExam = await prisma.activeExam.upsert({
     *   create: {
     *     // ... data to create a ActiveExam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActiveExam we want to update
     *   }
     * })
     */
    upsert<T extends ActiveExamUpsertArgs>(args: SelectSubset<T, ActiveExamUpsertArgs<ExtArgs>>): Prisma__ActiveExamClient<$Result.GetResult<Prisma.$ActiveExamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActiveExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveExamCountArgs} args - Arguments to filter ActiveExams to count.
     * @example
     * // Count the number of ActiveExams
     * const count = await prisma.activeExam.count({
     *   where: {
     *     // ... the filter for the ActiveExams we want to count
     *   }
     * })
    **/
    count<T extends ActiveExamCountArgs>(
      args?: Subset<T, ActiveExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActiveExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActiveExam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActiveExamAggregateArgs>(args: Subset<T, ActiveExamAggregateArgs>): Prisma.PrismaPromise<GetActiveExamAggregateType<T>>

    /**
     * Group by ActiveExam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActiveExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActiveExamGroupByArgs['orderBy'] }
        : { orderBy?: ActiveExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActiveExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActiveExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActiveExam model
   */
  readonly fields: ActiveExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActiveExam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActiveExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    attempt<T extends ExamAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttemptDefaultArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActiveExam model
   */ 
  interface ActiveExamFieldRefs {
    readonly userId: FieldRef<"ActiveExam", 'Int'>
    readonly attemptId: FieldRef<"ActiveExam", 'Int'>
    readonly createdAt: FieldRef<"ActiveExam", 'DateTime'>
    readonly mcqCorrect: FieldRef<"ActiveExam", 'String'>
    readonly listeningCorrect: FieldRef<"ActiveExam", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ActiveExam findUnique
   */
  export type ActiveExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveExam
     */
    select?: ActiveExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveExamInclude<ExtArgs> | null
    /**
     * Filter, which ActiveExam to fetch.
     */
    where: ActiveExamWhereUniqueInput
  }

  /**
   * ActiveExam findUniqueOrThrow
   */
  export type ActiveExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveExam
     */
    select?: ActiveExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveExamInclude<ExtArgs> | null
    /**
     * Filter, which ActiveExam to fetch.
     */
    where: ActiveExamWhereUniqueInput
  }

  /**
   * ActiveExam findFirst
   */
  export type ActiveExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveExam
     */
    select?: ActiveExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveExamInclude<ExtArgs> | null
    /**
     * Filter, which ActiveExam to fetch.
     */
    where?: ActiveExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveExams to fetch.
     */
    orderBy?: ActiveExamOrderByWithRelationInput | ActiveExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActiveExams.
     */
    cursor?: ActiveExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActiveExams.
     */
    distinct?: ActiveExamScalarFieldEnum | ActiveExamScalarFieldEnum[]
  }

  /**
   * ActiveExam findFirstOrThrow
   */
  export type ActiveExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveExam
     */
    select?: ActiveExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveExamInclude<ExtArgs> | null
    /**
     * Filter, which ActiveExam to fetch.
     */
    where?: ActiveExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveExams to fetch.
     */
    orderBy?: ActiveExamOrderByWithRelationInput | ActiveExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActiveExams.
     */
    cursor?: ActiveExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActiveExams.
     */
    distinct?: ActiveExamScalarFieldEnum | ActiveExamScalarFieldEnum[]
  }

  /**
   * ActiveExam findMany
   */
  export type ActiveExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveExam
     */
    select?: ActiveExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveExamInclude<ExtArgs> | null
    /**
     * Filter, which ActiveExams to fetch.
     */
    where?: ActiveExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveExams to fetch.
     */
    orderBy?: ActiveExamOrderByWithRelationInput | ActiveExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActiveExams.
     */
    cursor?: ActiveExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveExams.
     */
    skip?: number
    distinct?: ActiveExamScalarFieldEnum | ActiveExamScalarFieldEnum[]
  }

  /**
   * ActiveExam create
   */
  export type ActiveExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveExam
     */
    select?: ActiveExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveExamInclude<ExtArgs> | null
    /**
     * The data needed to create a ActiveExam.
     */
    data: XOR<ActiveExamCreateInput, ActiveExamUncheckedCreateInput>
  }

  /**
   * ActiveExam createMany
   */
  export type ActiveExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActiveExams.
     */
    data: ActiveExamCreateManyInput | ActiveExamCreateManyInput[]
  }

  /**
   * ActiveExam createManyAndReturn
   */
  export type ActiveExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveExam
     */
    select?: ActiveExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActiveExams.
     */
    data: ActiveExamCreateManyInput | ActiveExamCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveExamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActiveExam update
   */
  export type ActiveExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveExam
     */
    select?: ActiveExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveExamInclude<ExtArgs> | null
    /**
     * The data needed to update a ActiveExam.
     */
    data: XOR<ActiveExamUpdateInput, ActiveExamUncheckedUpdateInput>
    /**
     * Choose, which ActiveExam to update.
     */
    where: ActiveExamWhereUniqueInput
  }

  /**
   * ActiveExam updateMany
   */
  export type ActiveExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActiveExams.
     */
    data: XOR<ActiveExamUpdateManyMutationInput, ActiveExamUncheckedUpdateManyInput>
    /**
     * Filter which ActiveExams to update
     */
    where?: ActiveExamWhereInput
  }

  /**
   * ActiveExam upsert
   */
  export type ActiveExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveExam
     */
    select?: ActiveExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveExamInclude<ExtArgs> | null
    /**
     * The filter to search for the ActiveExam to update in case it exists.
     */
    where: ActiveExamWhereUniqueInput
    /**
     * In case the ActiveExam found by the `where` argument doesn't exist, create a new ActiveExam with this data.
     */
    create: XOR<ActiveExamCreateInput, ActiveExamUncheckedCreateInput>
    /**
     * In case the ActiveExam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActiveExamUpdateInput, ActiveExamUncheckedUpdateInput>
  }

  /**
   * ActiveExam delete
   */
  export type ActiveExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveExam
     */
    select?: ActiveExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveExamInclude<ExtArgs> | null
    /**
     * Filter which ActiveExam to delete.
     */
    where: ActiveExamWhereUniqueInput
  }

  /**
   * ActiveExam deleteMany
   */
  export type ActiveExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActiveExams to delete
     */
    where?: ActiveExamWhereInput
  }

  /**
   * ActiveExam without action
   */
  export type ActiveExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveExam
     */
    select?: ActiveExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveExamInclude<ExtArgs> | null
  }


  /**
   * Model ExamResult
   */

  export type AggregateExamResult = {
    _count: ExamResultCountAggregateOutputType | null
    _avg: ExamResultAvgAggregateOutputType | null
    _sum: ExamResultSumAggregateOutputType | null
    _min: ExamResultMinAggregateOutputType | null
    _max: ExamResultMaxAggregateOutputType | null
  }

  export type ExamResultAvgAggregateOutputType = {
    id: number | null
    attemptId: number | null
    userId: number | null
    score: number | null
    grammarScore: number | null
    writingScore: number | null
    speakingScore: number | null
    listeningScore: number | null
  }

  export type ExamResultSumAggregateOutputType = {
    id: number | null
    attemptId: number | null
    userId: number | null
    score: number | null
    grammarScore: number | null
    writingScore: number | null
    speakingScore: number | null
    listeningScore: number | null
  }

  export type ExamResultMinAggregateOutputType = {
    id: number | null
    attemptId: number | null
    userId: number | null
    score: number | null
    grammarScore: number | null
    writingScore: number | null
    speakingScore: number | null
    listeningScore: number | null
    level: string | null
    createdAt: Date | null
  }

  export type ExamResultMaxAggregateOutputType = {
    id: number | null
    attemptId: number | null
    userId: number | null
    score: number | null
    grammarScore: number | null
    writingScore: number | null
    speakingScore: number | null
    listeningScore: number | null
    level: string | null
    createdAt: Date | null
  }

  export type ExamResultCountAggregateOutputType = {
    id: number
    attemptId: number
    userId: number
    score: number
    grammarScore: number
    writingScore: number
    speakingScore: number
    listeningScore: number
    level: number
    createdAt: number
    _all: number
  }


  export type ExamResultAvgAggregateInputType = {
    id?: true
    attemptId?: true
    userId?: true
    score?: true
    grammarScore?: true
    writingScore?: true
    speakingScore?: true
    listeningScore?: true
  }

  export type ExamResultSumAggregateInputType = {
    id?: true
    attemptId?: true
    userId?: true
    score?: true
    grammarScore?: true
    writingScore?: true
    speakingScore?: true
    listeningScore?: true
  }

  export type ExamResultMinAggregateInputType = {
    id?: true
    attemptId?: true
    userId?: true
    score?: true
    grammarScore?: true
    writingScore?: true
    speakingScore?: true
    listeningScore?: true
    level?: true
    createdAt?: true
  }

  export type ExamResultMaxAggregateInputType = {
    id?: true
    attemptId?: true
    userId?: true
    score?: true
    grammarScore?: true
    writingScore?: true
    speakingScore?: true
    listeningScore?: true
    level?: true
    createdAt?: true
  }

  export type ExamResultCountAggregateInputType = {
    id?: true
    attemptId?: true
    userId?: true
    score?: true
    grammarScore?: true
    writingScore?: true
    speakingScore?: true
    listeningScore?: true
    level?: true
    createdAt?: true
    _all?: true
  }

  export type ExamResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamResult to aggregate.
     */
    where?: ExamResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamResults to fetch.
     */
    orderBy?: ExamResultOrderByWithRelationInput | ExamResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamResults
    **/
    _count?: true | ExamResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamResultMaxAggregateInputType
  }

  export type GetExamResultAggregateType<T extends ExamResultAggregateArgs> = {
        [P in keyof T & keyof AggregateExamResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamResult[P]>
      : GetScalarType<T[P], AggregateExamResult[P]>
  }




  export type ExamResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamResultWhereInput
    orderBy?: ExamResultOrderByWithAggregationInput | ExamResultOrderByWithAggregationInput[]
    by: ExamResultScalarFieldEnum[] | ExamResultScalarFieldEnum
    having?: ExamResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamResultCountAggregateInputType | true
    _avg?: ExamResultAvgAggregateInputType
    _sum?: ExamResultSumAggregateInputType
    _min?: ExamResultMinAggregateInputType
    _max?: ExamResultMaxAggregateInputType
  }

  export type ExamResultGroupByOutputType = {
    id: number
    attemptId: number
    userId: number
    score: number
    grammarScore: number
    writingScore: number
    speakingScore: number
    listeningScore: number
    level: string
    createdAt: Date
    _count: ExamResultCountAggregateOutputType | null
    _avg: ExamResultAvgAggregateOutputType | null
    _sum: ExamResultSumAggregateOutputType | null
    _min: ExamResultMinAggregateOutputType | null
    _max: ExamResultMaxAggregateOutputType | null
  }

  type GetExamResultGroupByPayload<T extends ExamResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamResultGroupByOutputType[P]>
            : GetScalarType<T[P], ExamResultGroupByOutputType[P]>
        }
      >
    >


  export type ExamResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    userId?: boolean
    score?: boolean
    grammarScore?: boolean
    writingScore?: boolean
    speakingScore?: boolean
    listeningScore?: boolean
    level?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examResult"]>

  export type ExamResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    userId?: boolean
    score?: boolean
    grammarScore?: boolean
    writingScore?: boolean
    speakingScore?: boolean
    listeningScore?: boolean
    level?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examResult"]>

  export type ExamResultSelectScalar = {
    id?: boolean
    attemptId?: boolean
    userId?: boolean
    score?: boolean
    grammarScore?: boolean
    writingScore?: boolean
    speakingScore?: boolean
    listeningScore?: boolean
    level?: boolean
    createdAt?: boolean
  }

  export type ExamResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
  }
  export type ExamResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
  }

  export type $ExamResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamResult"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      attempt: Prisma.$ExamAttemptPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      attemptId: number
      userId: number
      score: number
      grammarScore: number
      writingScore: number
      speakingScore: number
      listeningScore: number
      level: string
      createdAt: Date
    }, ExtArgs["result"]["examResult"]>
    composites: {}
  }

  type ExamResultGetPayload<S extends boolean | null | undefined | ExamResultDefaultArgs> = $Result.GetResult<Prisma.$ExamResultPayload, S>

  type ExamResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamResultFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamResultCountAggregateInputType | true
    }

  export interface ExamResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamResult'], meta: { name: 'ExamResult' } }
    /**
     * Find zero or one ExamResult that matches the filter.
     * @param {ExamResultFindUniqueArgs} args - Arguments to find a ExamResult
     * @example
     * // Get one ExamResult
     * const examResult = await prisma.examResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamResultFindUniqueArgs>(args: SelectSubset<T, ExamResultFindUniqueArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExamResult that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamResultFindUniqueOrThrowArgs} args - Arguments to find a ExamResult
     * @example
     * // Get one ExamResult
     * const examResult = await prisma.examResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamResultFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExamResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamResultFindFirstArgs} args - Arguments to find a ExamResult
     * @example
     * // Get one ExamResult
     * const examResult = await prisma.examResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamResultFindFirstArgs>(args?: SelectSubset<T, ExamResultFindFirstArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExamResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamResultFindFirstOrThrowArgs} args - Arguments to find a ExamResult
     * @example
     * // Get one ExamResult
     * const examResult = await prisma.examResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamResultFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExamResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamResults
     * const examResults = await prisma.examResult.findMany()
     * 
     * // Get first 10 ExamResults
     * const examResults = await prisma.examResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examResultWithIdOnly = await prisma.examResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamResultFindManyArgs>(args?: SelectSubset<T, ExamResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExamResult.
     * @param {ExamResultCreateArgs} args - Arguments to create a ExamResult.
     * @example
     * // Create one ExamResult
     * const ExamResult = await prisma.examResult.create({
     *   data: {
     *     // ... data to create a ExamResult
     *   }
     * })
     * 
     */
    create<T extends ExamResultCreateArgs>(args: SelectSubset<T, ExamResultCreateArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExamResults.
     * @param {ExamResultCreateManyArgs} args - Arguments to create many ExamResults.
     * @example
     * // Create many ExamResults
     * const examResult = await prisma.examResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamResultCreateManyArgs>(args?: SelectSubset<T, ExamResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamResults and returns the data saved in the database.
     * @param {ExamResultCreateManyAndReturnArgs} args - Arguments to create many ExamResults.
     * @example
     * // Create many ExamResults
     * const examResult = await prisma.examResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamResults and only return the `id`
     * const examResultWithIdOnly = await prisma.examResult.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamResultCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExamResult.
     * @param {ExamResultDeleteArgs} args - Arguments to delete one ExamResult.
     * @example
     * // Delete one ExamResult
     * const ExamResult = await prisma.examResult.delete({
     *   where: {
     *     // ... filter to delete one ExamResult
     *   }
     * })
     * 
     */
    delete<T extends ExamResultDeleteArgs>(args: SelectSubset<T, ExamResultDeleteArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExamResult.
     * @param {ExamResultUpdateArgs} args - Arguments to update one ExamResult.
     * @example
     * // Update one ExamResult
     * const examResult = await prisma.examResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamResultUpdateArgs>(args: SelectSubset<T, ExamResultUpdateArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExamResults.
     * @param {ExamResultDeleteManyArgs} args - Arguments to filter ExamResults to delete.
     * @example
     * // Delete a few ExamResults
     * const { count } = await prisma.examResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamResultDeleteManyArgs>(args?: SelectSubset<T, ExamResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamResults
     * const examResult = await prisma.examResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamResultUpdateManyArgs>(args: SelectSubset<T, ExamResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamResult.
     * @param {ExamResultUpsertArgs} args - Arguments to update or create a ExamResult.
     * @example
     * // Update or create a ExamResult
     * const examResult = await prisma.examResult.upsert({
     *   create: {
     *     // ... data to create a ExamResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamResult we want to update
     *   }
     * })
     */
    upsert<T extends ExamResultUpsertArgs>(args: SelectSubset<T, ExamResultUpsertArgs<ExtArgs>>): Prisma__ExamResultClient<$Result.GetResult<Prisma.$ExamResultPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExamResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamResultCountArgs} args - Arguments to filter ExamResults to count.
     * @example
     * // Count the number of ExamResults
     * const count = await prisma.examResult.count({
     *   where: {
     *     // ... the filter for the ExamResults we want to count
     *   }
     * })
    **/
    count<T extends ExamResultCountArgs>(
      args?: Subset<T, ExamResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamResultAggregateArgs>(args: Subset<T, ExamResultAggregateArgs>): Prisma.PrismaPromise<GetExamResultAggregateType<T>>

    /**
     * Group by ExamResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamResultGroupByArgs['orderBy'] }
        : { orderBy?: ExamResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamResult model
   */
  readonly fields: ExamResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    attempt<T extends ExamAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttemptDefaultArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamResult model
   */ 
  interface ExamResultFieldRefs {
    readonly id: FieldRef<"ExamResult", 'Int'>
    readonly attemptId: FieldRef<"ExamResult", 'Int'>
    readonly userId: FieldRef<"ExamResult", 'Int'>
    readonly score: FieldRef<"ExamResult", 'Int'>
    readonly grammarScore: FieldRef<"ExamResult", 'Int'>
    readonly writingScore: FieldRef<"ExamResult", 'Int'>
    readonly speakingScore: FieldRef<"ExamResult", 'Int'>
    readonly listeningScore: FieldRef<"ExamResult", 'Int'>
    readonly level: FieldRef<"ExamResult", 'String'>
    readonly createdAt: FieldRef<"ExamResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamResult findUnique
   */
  export type ExamResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * Filter, which ExamResult to fetch.
     */
    where: ExamResultWhereUniqueInput
  }

  /**
   * ExamResult findUniqueOrThrow
   */
  export type ExamResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * Filter, which ExamResult to fetch.
     */
    where: ExamResultWhereUniqueInput
  }

  /**
   * ExamResult findFirst
   */
  export type ExamResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * Filter, which ExamResult to fetch.
     */
    where?: ExamResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamResults to fetch.
     */
    orderBy?: ExamResultOrderByWithRelationInput | ExamResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamResults.
     */
    cursor?: ExamResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamResults.
     */
    distinct?: ExamResultScalarFieldEnum | ExamResultScalarFieldEnum[]
  }

  /**
   * ExamResult findFirstOrThrow
   */
  export type ExamResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * Filter, which ExamResult to fetch.
     */
    where?: ExamResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamResults to fetch.
     */
    orderBy?: ExamResultOrderByWithRelationInput | ExamResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamResults.
     */
    cursor?: ExamResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamResults.
     */
    distinct?: ExamResultScalarFieldEnum | ExamResultScalarFieldEnum[]
  }

  /**
   * ExamResult findMany
   */
  export type ExamResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * Filter, which ExamResults to fetch.
     */
    where?: ExamResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamResults to fetch.
     */
    orderBy?: ExamResultOrderByWithRelationInput | ExamResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamResults.
     */
    cursor?: ExamResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamResults.
     */
    skip?: number
    distinct?: ExamResultScalarFieldEnum | ExamResultScalarFieldEnum[]
  }

  /**
   * ExamResult create
   */
  export type ExamResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamResult.
     */
    data: XOR<ExamResultCreateInput, ExamResultUncheckedCreateInput>
  }

  /**
   * ExamResult createMany
   */
  export type ExamResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamResults.
     */
    data: ExamResultCreateManyInput | ExamResultCreateManyInput[]
  }

  /**
   * ExamResult createManyAndReturn
   */
  export type ExamResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExamResults.
     */
    data: ExamResultCreateManyInput | ExamResultCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamResult update
   */
  export type ExamResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamResult.
     */
    data: XOR<ExamResultUpdateInput, ExamResultUncheckedUpdateInput>
    /**
     * Choose, which ExamResult to update.
     */
    where: ExamResultWhereUniqueInput
  }

  /**
   * ExamResult updateMany
   */
  export type ExamResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamResults.
     */
    data: XOR<ExamResultUpdateManyMutationInput, ExamResultUncheckedUpdateManyInput>
    /**
     * Filter which ExamResults to update
     */
    where?: ExamResultWhereInput
  }

  /**
   * ExamResult upsert
   */
  export type ExamResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamResult to update in case it exists.
     */
    where: ExamResultWhereUniqueInput
    /**
     * In case the ExamResult found by the `where` argument doesn't exist, create a new ExamResult with this data.
     */
    create: XOR<ExamResultCreateInput, ExamResultUncheckedCreateInput>
    /**
     * In case the ExamResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamResultUpdateInput, ExamResultUncheckedUpdateInput>
  }

  /**
   * ExamResult delete
   */
  export type ExamResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
    /**
     * Filter which ExamResult to delete.
     */
    where: ExamResultWhereUniqueInput
  }

  /**
   * ExamResult deleteMany
   */
  export type ExamResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamResults to delete
     */
    where?: ExamResultWhereInput
  }

  /**
   * ExamResult without action
   */
  export type ExamResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamResult
     */
    select?: ExamResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamResultInclude<ExtArgs> | null
  }


  /**
   * Model McqQuestion
   */

  export type AggregateMcqQuestion = {
    _count: McqQuestionCountAggregateOutputType | null
    _avg: McqQuestionAvgAggregateOutputType | null
    _sum: McqQuestionSumAggregateOutputType | null
    _min: McqQuestionMinAggregateOutputType | null
    _max: McqQuestionMaxAggregateOutputType | null
  }

  export type McqQuestionAvgAggregateOutputType = {
    id: number | null
  }

  export type McqQuestionSumAggregateOutputType = {
    id: number | null
  }

  export type McqQuestionMinAggregateOutputType = {
    id: number | null
    text: string | null
    options: string | null
    correct: string | null
    difficulty: string | null
    createdAt: Date | null
  }

  export type McqQuestionMaxAggregateOutputType = {
    id: number | null
    text: string | null
    options: string | null
    correct: string | null
    difficulty: string | null
    createdAt: Date | null
  }

  export type McqQuestionCountAggregateOutputType = {
    id: number
    text: number
    options: number
    correct: number
    difficulty: number
    createdAt: number
    _all: number
  }


  export type McqQuestionAvgAggregateInputType = {
    id?: true
  }

  export type McqQuestionSumAggregateInputType = {
    id?: true
  }

  export type McqQuestionMinAggregateInputType = {
    id?: true
    text?: true
    options?: true
    correct?: true
    difficulty?: true
    createdAt?: true
  }

  export type McqQuestionMaxAggregateInputType = {
    id?: true
    text?: true
    options?: true
    correct?: true
    difficulty?: true
    createdAt?: true
  }

  export type McqQuestionCountAggregateInputType = {
    id?: true
    text?: true
    options?: true
    correct?: true
    difficulty?: true
    createdAt?: true
    _all?: true
  }

  export type McqQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which McqQuestion to aggregate.
     */
    where?: McqQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of McqQuestions to fetch.
     */
    orderBy?: McqQuestionOrderByWithRelationInput | McqQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: McqQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` McqQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` McqQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned McqQuestions
    **/
    _count?: true | McqQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: McqQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: McqQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: McqQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: McqQuestionMaxAggregateInputType
  }

  export type GetMcqQuestionAggregateType<T extends McqQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateMcqQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMcqQuestion[P]>
      : GetScalarType<T[P], AggregateMcqQuestion[P]>
  }




  export type McqQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: McqQuestionWhereInput
    orderBy?: McqQuestionOrderByWithAggregationInput | McqQuestionOrderByWithAggregationInput[]
    by: McqQuestionScalarFieldEnum[] | McqQuestionScalarFieldEnum
    having?: McqQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: McqQuestionCountAggregateInputType | true
    _avg?: McqQuestionAvgAggregateInputType
    _sum?: McqQuestionSumAggregateInputType
    _min?: McqQuestionMinAggregateInputType
    _max?: McqQuestionMaxAggregateInputType
  }

  export type McqQuestionGroupByOutputType = {
    id: number
    text: string
    options: string
    correct: string
    difficulty: string | null
    createdAt: Date
    _count: McqQuestionCountAggregateOutputType | null
    _avg: McqQuestionAvgAggregateOutputType | null
    _sum: McqQuestionSumAggregateOutputType | null
    _min: McqQuestionMinAggregateOutputType | null
    _max: McqQuestionMaxAggregateOutputType | null
  }

  type GetMcqQuestionGroupByPayload<T extends McqQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<McqQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof McqQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], McqQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], McqQuestionGroupByOutputType[P]>
        }
      >
    >


  export type McqQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    options?: boolean
    correct?: boolean
    difficulty?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["mcqQuestion"]>

  export type McqQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    options?: boolean
    correct?: boolean
    difficulty?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["mcqQuestion"]>

  export type McqQuestionSelectScalar = {
    id?: boolean
    text?: boolean
    options?: boolean
    correct?: boolean
    difficulty?: boolean
    createdAt?: boolean
  }


  export type $McqQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "McqQuestion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      text: string
      options: string
      correct: string
      difficulty: string | null
      createdAt: Date
    }, ExtArgs["result"]["mcqQuestion"]>
    composites: {}
  }

  type McqQuestionGetPayload<S extends boolean | null | undefined | McqQuestionDefaultArgs> = $Result.GetResult<Prisma.$McqQuestionPayload, S>

  type McqQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<McqQuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: McqQuestionCountAggregateInputType | true
    }

  export interface McqQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['McqQuestion'], meta: { name: 'McqQuestion' } }
    /**
     * Find zero or one McqQuestion that matches the filter.
     * @param {McqQuestionFindUniqueArgs} args - Arguments to find a McqQuestion
     * @example
     * // Get one McqQuestion
     * const mcqQuestion = await prisma.mcqQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends McqQuestionFindUniqueArgs>(args: SelectSubset<T, McqQuestionFindUniqueArgs<ExtArgs>>): Prisma__McqQuestionClient<$Result.GetResult<Prisma.$McqQuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one McqQuestion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {McqQuestionFindUniqueOrThrowArgs} args - Arguments to find a McqQuestion
     * @example
     * // Get one McqQuestion
     * const mcqQuestion = await prisma.mcqQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends McqQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, McqQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__McqQuestionClient<$Result.GetResult<Prisma.$McqQuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first McqQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqQuestionFindFirstArgs} args - Arguments to find a McqQuestion
     * @example
     * // Get one McqQuestion
     * const mcqQuestion = await prisma.mcqQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends McqQuestionFindFirstArgs>(args?: SelectSubset<T, McqQuestionFindFirstArgs<ExtArgs>>): Prisma__McqQuestionClient<$Result.GetResult<Prisma.$McqQuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first McqQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqQuestionFindFirstOrThrowArgs} args - Arguments to find a McqQuestion
     * @example
     * // Get one McqQuestion
     * const mcqQuestion = await prisma.mcqQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends McqQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, McqQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__McqQuestionClient<$Result.GetResult<Prisma.$McqQuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more McqQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all McqQuestions
     * const mcqQuestions = await prisma.mcqQuestion.findMany()
     * 
     * // Get first 10 McqQuestions
     * const mcqQuestions = await prisma.mcqQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mcqQuestionWithIdOnly = await prisma.mcqQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends McqQuestionFindManyArgs>(args?: SelectSubset<T, McqQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$McqQuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a McqQuestion.
     * @param {McqQuestionCreateArgs} args - Arguments to create a McqQuestion.
     * @example
     * // Create one McqQuestion
     * const McqQuestion = await prisma.mcqQuestion.create({
     *   data: {
     *     // ... data to create a McqQuestion
     *   }
     * })
     * 
     */
    create<T extends McqQuestionCreateArgs>(args: SelectSubset<T, McqQuestionCreateArgs<ExtArgs>>): Prisma__McqQuestionClient<$Result.GetResult<Prisma.$McqQuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many McqQuestions.
     * @param {McqQuestionCreateManyArgs} args - Arguments to create many McqQuestions.
     * @example
     * // Create many McqQuestions
     * const mcqQuestion = await prisma.mcqQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends McqQuestionCreateManyArgs>(args?: SelectSubset<T, McqQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many McqQuestions and returns the data saved in the database.
     * @param {McqQuestionCreateManyAndReturnArgs} args - Arguments to create many McqQuestions.
     * @example
     * // Create many McqQuestions
     * const mcqQuestion = await prisma.mcqQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many McqQuestions and only return the `id`
     * const mcqQuestionWithIdOnly = await prisma.mcqQuestion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends McqQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, McqQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$McqQuestionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a McqQuestion.
     * @param {McqQuestionDeleteArgs} args - Arguments to delete one McqQuestion.
     * @example
     * // Delete one McqQuestion
     * const McqQuestion = await prisma.mcqQuestion.delete({
     *   where: {
     *     // ... filter to delete one McqQuestion
     *   }
     * })
     * 
     */
    delete<T extends McqQuestionDeleteArgs>(args: SelectSubset<T, McqQuestionDeleteArgs<ExtArgs>>): Prisma__McqQuestionClient<$Result.GetResult<Prisma.$McqQuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one McqQuestion.
     * @param {McqQuestionUpdateArgs} args - Arguments to update one McqQuestion.
     * @example
     * // Update one McqQuestion
     * const mcqQuestion = await prisma.mcqQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends McqQuestionUpdateArgs>(args: SelectSubset<T, McqQuestionUpdateArgs<ExtArgs>>): Prisma__McqQuestionClient<$Result.GetResult<Prisma.$McqQuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more McqQuestions.
     * @param {McqQuestionDeleteManyArgs} args - Arguments to filter McqQuestions to delete.
     * @example
     * // Delete a few McqQuestions
     * const { count } = await prisma.mcqQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends McqQuestionDeleteManyArgs>(args?: SelectSubset<T, McqQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more McqQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many McqQuestions
     * const mcqQuestion = await prisma.mcqQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends McqQuestionUpdateManyArgs>(args: SelectSubset<T, McqQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one McqQuestion.
     * @param {McqQuestionUpsertArgs} args - Arguments to update or create a McqQuestion.
     * @example
     * // Update or create a McqQuestion
     * const mcqQuestion = await prisma.mcqQuestion.upsert({
     *   create: {
     *     // ... data to create a McqQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the McqQuestion we want to update
     *   }
     * })
     */
    upsert<T extends McqQuestionUpsertArgs>(args: SelectSubset<T, McqQuestionUpsertArgs<ExtArgs>>): Prisma__McqQuestionClient<$Result.GetResult<Prisma.$McqQuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of McqQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqQuestionCountArgs} args - Arguments to filter McqQuestions to count.
     * @example
     * // Count the number of McqQuestions
     * const count = await prisma.mcqQuestion.count({
     *   where: {
     *     // ... the filter for the McqQuestions we want to count
     *   }
     * })
    **/
    count<T extends McqQuestionCountArgs>(
      args?: Subset<T, McqQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], McqQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a McqQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends McqQuestionAggregateArgs>(args: Subset<T, McqQuestionAggregateArgs>): Prisma.PrismaPromise<GetMcqQuestionAggregateType<T>>

    /**
     * Group by McqQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends McqQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: McqQuestionGroupByArgs['orderBy'] }
        : { orderBy?: McqQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, McqQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMcqQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the McqQuestion model
   */
  readonly fields: McqQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for McqQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__McqQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the McqQuestion model
   */ 
  interface McqQuestionFieldRefs {
    readonly id: FieldRef<"McqQuestion", 'Int'>
    readonly text: FieldRef<"McqQuestion", 'String'>
    readonly options: FieldRef<"McqQuestion", 'String'>
    readonly correct: FieldRef<"McqQuestion", 'String'>
    readonly difficulty: FieldRef<"McqQuestion", 'String'>
    readonly createdAt: FieldRef<"McqQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * McqQuestion findUnique
   */
  export type McqQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqQuestion
     */
    select?: McqQuestionSelect<ExtArgs> | null
    /**
     * Filter, which McqQuestion to fetch.
     */
    where: McqQuestionWhereUniqueInput
  }

  /**
   * McqQuestion findUniqueOrThrow
   */
  export type McqQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqQuestion
     */
    select?: McqQuestionSelect<ExtArgs> | null
    /**
     * Filter, which McqQuestion to fetch.
     */
    where: McqQuestionWhereUniqueInput
  }

  /**
   * McqQuestion findFirst
   */
  export type McqQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqQuestion
     */
    select?: McqQuestionSelect<ExtArgs> | null
    /**
     * Filter, which McqQuestion to fetch.
     */
    where?: McqQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of McqQuestions to fetch.
     */
    orderBy?: McqQuestionOrderByWithRelationInput | McqQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for McqQuestions.
     */
    cursor?: McqQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` McqQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` McqQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of McqQuestions.
     */
    distinct?: McqQuestionScalarFieldEnum | McqQuestionScalarFieldEnum[]
  }

  /**
   * McqQuestion findFirstOrThrow
   */
  export type McqQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqQuestion
     */
    select?: McqQuestionSelect<ExtArgs> | null
    /**
     * Filter, which McqQuestion to fetch.
     */
    where?: McqQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of McqQuestions to fetch.
     */
    orderBy?: McqQuestionOrderByWithRelationInput | McqQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for McqQuestions.
     */
    cursor?: McqQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` McqQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` McqQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of McqQuestions.
     */
    distinct?: McqQuestionScalarFieldEnum | McqQuestionScalarFieldEnum[]
  }

  /**
   * McqQuestion findMany
   */
  export type McqQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqQuestion
     */
    select?: McqQuestionSelect<ExtArgs> | null
    /**
     * Filter, which McqQuestions to fetch.
     */
    where?: McqQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of McqQuestions to fetch.
     */
    orderBy?: McqQuestionOrderByWithRelationInput | McqQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing McqQuestions.
     */
    cursor?: McqQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` McqQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` McqQuestions.
     */
    skip?: number
    distinct?: McqQuestionScalarFieldEnum | McqQuestionScalarFieldEnum[]
  }

  /**
   * McqQuestion create
   */
  export type McqQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqQuestion
     */
    select?: McqQuestionSelect<ExtArgs> | null
    /**
     * The data needed to create a McqQuestion.
     */
    data: XOR<McqQuestionCreateInput, McqQuestionUncheckedCreateInput>
  }

  /**
   * McqQuestion createMany
   */
  export type McqQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many McqQuestions.
     */
    data: McqQuestionCreateManyInput | McqQuestionCreateManyInput[]
  }

  /**
   * McqQuestion createManyAndReturn
   */
  export type McqQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqQuestion
     */
    select?: McqQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many McqQuestions.
     */
    data: McqQuestionCreateManyInput | McqQuestionCreateManyInput[]
  }

  /**
   * McqQuestion update
   */
  export type McqQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqQuestion
     */
    select?: McqQuestionSelect<ExtArgs> | null
    /**
     * The data needed to update a McqQuestion.
     */
    data: XOR<McqQuestionUpdateInput, McqQuestionUncheckedUpdateInput>
    /**
     * Choose, which McqQuestion to update.
     */
    where: McqQuestionWhereUniqueInput
  }

  /**
   * McqQuestion updateMany
   */
  export type McqQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update McqQuestions.
     */
    data: XOR<McqQuestionUpdateManyMutationInput, McqQuestionUncheckedUpdateManyInput>
    /**
     * Filter which McqQuestions to update
     */
    where?: McqQuestionWhereInput
  }

  /**
   * McqQuestion upsert
   */
  export type McqQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqQuestion
     */
    select?: McqQuestionSelect<ExtArgs> | null
    /**
     * The filter to search for the McqQuestion to update in case it exists.
     */
    where: McqQuestionWhereUniqueInput
    /**
     * In case the McqQuestion found by the `where` argument doesn't exist, create a new McqQuestion with this data.
     */
    create: XOR<McqQuestionCreateInput, McqQuestionUncheckedCreateInput>
    /**
     * In case the McqQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<McqQuestionUpdateInput, McqQuestionUncheckedUpdateInput>
  }

  /**
   * McqQuestion delete
   */
  export type McqQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqQuestion
     */
    select?: McqQuestionSelect<ExtArgs> | null
    /**
     * Filter which McqQuestion to delete.
     */
    where: McqQuestionWhereUniqueInput
  }

  /**
   * McqQuestion deleteMany
   */
  export type McqQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which McqQuestions to delete
     */
    where?: McqQuestionWhereInput
  }

  /**
   * McqQuestion without action
   */
  export type McqQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqQuestion
     */
    select?: McqQuestionSelect<ExtArgs> | null
  }


  /**
   * Model ListeningScenario
   */

  export type AggregateListeningScenario = {
    _count: ListeningScenarioCountAggregateOutputType | null
    _avg: ListeningScenarioAvgAggregateOutputType | null
    _sum: ListeningScenarioSumAggregateOutputType | null
    _min: ListeningScenarioMinAggregateOutputType | null
    _max: ListeningScenarioMaxAggregateOutputType | null
  }

  export type ListeningScenarioAvgAggregateOutputType = {
    id: number | null
  }

  export type ListeningScenarioSumAggregateOutputType = {
    id: number | null
  }

  export type ListeningScenarioMinAggregateOutputType = {
    id: number | null
    topic: string | null
    passage: string | null
    difficulty: string | null
    createdAt: Date | null
  }

  export type ListeningScenarioMaxAggregateOutputType = {
    id: number | null
    topic: string | null
    passage: string | null
    difficulty: string | null
    createdAt: Date | null
  }

  export type ListeningScenarioCountAggregateOutputType = {
    id: number
    topic: number
    passage: number
    difficulty: number
    createdAt: number
    _all: number
  }


  export type ListeningScenarioAvgAggregateInputType = {
    id?: true
  }

  export type ListeningScenarioSumAggregateInputType = {
    id?: true
  }

  export type ListeningScenarioMinAggregateInputType = {
    id?: true
    topic?: true
    passage?: true
    difficulty?: true
    createdAt?: true
  }

  export type ListeningScenarioMaxAggregateInputType = {
    id?: true
    topic?: true
    passage?: true
    difficulty?: true
    createdAt?: true
  }

  export type ListeningScenarioCountAggregateInputType = {
    id?: true
    topic?: true
    passage?: true
    difficulty?: true
    createdAt?: true
    _all?: true
  }

  export type ListeningScenarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListeningScenario to aggregate.
     */
    where?: ListeningScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListeningScenarios to fetch.
     */
    orderBy?: ListeningScenarioOrderByWithRelationInput | ListeningScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListeningScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListeningScenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListeningScenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ListeningScenarios
    **/
    _count?: true | ListeningScenarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListeningScenarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListeningScenarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListeningScenarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListeningScenarioMaxAggregateInputType
  }

  export type GetListeningScenarioAggregateType<T extends ListeningScenarioAggregateArgs> = {
        [P in keyof T & keyof AggregateListeningScenario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListeningScenario[P]>
      : GetScalarType<T[P], AggregateListeningScenario[P]>
  }




  export type ListeningScenarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListeningScenarioWhereInput
    orderBy?: ListeningScenarioOrderByWithAggregationInput | ListeningScenarioOrderByWithAggregationInput[]
    by: ListeningScenarioScalarFieldEnum[] | ListeningScenarioScalarFieldEnum
    having?: ListeningScenarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListeningScenarioCountAggregateInputType | true
    _avg?: ListeningScenarioAvgAggregateInputType
    _sum?: ListeningScenarioSumAggregateInputType
    _min?: ListeningScenarioMinAggregateInputType
    _max?: ListeningScenarioMaxAggregateInputType
  }

  export type ListeningScenarioGroupByOutputType = {
    id: number
    topic: string
    passage: string
    difficulty: string | null
    createdAt: Date
    _count: ListeningScenarioCountAggregateOutputType | null
    _avg: ListeningScenarioAvgAggregateOutputType | null
    _sum: ListeningScenarioSumAggregateOutputType | null
    _min: ListeningScenarioMinAggregateOutputType | null
    _max: ListeningScenarioMaxAggregateOutputType | null
  }

  type GetListeningScenarioGroupByPayload<T extends ListeningScenarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListeningScenarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListeningScenarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListeningScenarioGroupByOutputType[P]>
            : GetScalarType<T[P], ListeningScenarioGroupByOutputType[P]>
        }
      >
    >


  export type ListeningScenarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    passage?: boolean
    difficulty?: boolean
    createdAt?: boolean
    questions?: boolean | ListeningScenario$questionsArgs<ExtArgs>
    attempts?: boolean | ListeningScenario$attemptsArgs<ExtArgs>
    _count?: boolean | ListeningScenarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listeningScenario"]>

  export type ListeningScenarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    passage?: boolean
    difficulty?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["listeningScenario"]>

  export type ListeningScenarioSelectScalar = {
    id?: boolean
    topic?: boolean
    passage?: boolean
    difficulty?: boolean
    createdAt?: boolean
  }

  export type ListeningScenarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | ListeningScenario$questionsArgs<ExtArgs>
    attempts?: boolean | ListeningScenario$attemptsArgs<ExtArgs>
    _count?: boolean | ListeningScenarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ListeningScenarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ListeningScenarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ListeningScenario"
    objects: {
      questions: Prisma.$ListeningQuestionPayload<ExtArgs>[]
      attempts: Prisma.$ExamAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      topic: string
      passage: string
      difficulty: string | null
      createdAt: Date
    }, ExtArgs["result"]["listeningScenario"]>
    composites: {}
  }

  type ListeningScenarioGetPayload<S extends boolean | null | undefined | ListeningScenarioDefaultArgs> = $Result.GetResult<Prisma.$ListeningScenarioPayload, S>

  type ListeningScenarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ListeningScenarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ListeningScenarioCountAggregateInputType | true
    }

  export interface ListeningScenarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ListeningScenario'], meta: { name: 'ListeningScenario' } }
    /**
     * Find zero or one ListeningScenario that matches the filter.
     * @param {ListeningScenarioFindUniqueArgs} args - Arguments to find a ListeningScenario
     * @example
     * // Get one ListeningScenario
     * const listeningScenario = await prisma.listeningScenario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListeningScenarioFindUniqueArgs>(args: SelectSubset<T, ListeningScenarioFindUniqueArgs<ExtArgs>>): Prisma__ListeningScenarioClient<$Result.GetResult<Prisma.$ListeningScenarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ListeningScenario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ListeningScenarioFindUniqueOrThrowArgs} args - Arguments to find a ListeningScenario
     * @example
     * // Get one ListeningScenario
     * const listeningScenario = await prisma.listeningScenario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListeningScenarioFindUniqueOrThrowArgs>(args: SelectSubset<T, ListeningScenarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListeningScenarioClient<$Result.GetResult<Prisma.$ListeningScenarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ListeningScenario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningScenarioFindFirstArgs} args - Arguments to find a ListeningScenario
     * @example
     * // Get one ListeningScenario
     * const listeningScenario = await prisma.listeningScenario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListeningScenarioFindFirstArgs>(args?: SelectSubset<T, ListeningScenarioFindFirstArgs<ExtArgs>>): Prisma__ListeningScenarioClient<$Result.GetResult<Prisma.$ListeningScenarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ListeningScenario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningScenarioFindFirstOrThrowArgs} args - Arguments to find a ListeningScenario
     * @example
     * // Get one ListeningScenario
     * const listeningScenario = await prisma.listeningScenario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListeningScenarioFindFirstOrThrowArgs>(args?: SelectSubset<T, ListeningScenarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListeningScenarioClient<$Result.GetResult<Prisma.$ListeningScenarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ListeningScenarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningScenarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ListeningScenarios
     * const listeningScenarios = await prisma.listeningScenario.findMany()
     * 
     * // Get first 10 ListeningScenarios
     * const listeningScenarios = await prisma.listeningScenario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listeningScenarioWithIdOnly = await prisma.listeningScenario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListeningScenarioFindManyArgs>(args?: SelectSubset<T, ListeningScenarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListeningScenarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ListeningScenario.
     * @param {ListeningScenarioCreateArgs} args - Arguments to create a ListeningScenario.
     * @example
     * // Create one ListeningScenario
     * const ListeningScenario = await prisma.listeningScenario.create({
     *   data: {
     *     // ... data to create a ListeningScenario
     *   }
     * })
     * 
     */
    create<T extends ListeningScenarioCreateArgs>(args: SelectSubset<T, ListeningScenarioCreateArgs<ExtArgs>>): Prisma__ListeningScenarioClient<$Result.GetResult<Prisma.$ListeningScenarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ListeningScenarios.
     * @param {ListeningScenarioCreateManyArgs} args - Arguments to create many ListeningScenarios.
     * @example
     * // Create many ListeningScenarios
     * const listeningScenario = await prisma.listeningScenario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListeningScenarioCreateManyArgs>(args?: SelectSubset<T, ListeningScenarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ListeningScenarios and returns the data saved in the database.
     * @param {ListeningScenarioCreateManyAndReturnArgs} args - Arguments to create many ListeningScenarios.
     * @example
     * // Create many ListeningScenarios
     * const listeningScenario = await prisma.listeningScenario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ListeningScenarios and only return the `id`
     * const listeningScenarioWithIdOnly = await prisma.listeningScenario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListeningScenarioCreateManyAndReturnArgs>(args?: SelectSubset<T, ListeningScenarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListeningScenarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ListeningScenario.
     * @param {ListeningScenarioDeleteArgs} args - Arguments to delete one ListeningScenario.
     * @example
     * // Delete one ListeningScenario
     * const ListeningScenario = await prisma.listeningScenario.delete({
     *   where: {
     *     // ... filter to delete one ListeningScenario
     *   }
     * })
     * 
     */
    delete<T extends ListeningScenarioDeleteArgs>(args: SelectSubset<T, ListeningScenarioDeleteArgs<ExtArgs>>): Prisma__ListeningScenarioClient<$Result.GetResult<Prisma.$ListeningScenarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ListeningScenario.
     * @param {ListeningScenarioUpdateArgs} args - Arguments to update one ListeningScenario.
     * @example
     * // Update one ListeningScenario
     * const listeningScenario = await prisma.listeningScenario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListeningScenarioUpdateArgs>(args: SelectSubset<T, ListeningScenarioUpdateArgs<ExtArgs>>): Prisma__ListeningScenarioClient<$Result.GetResult<Prisma.$ListeningScenarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ListeningScenarios.
     * @param {ListeningScenarioDeleteManyArgs} args - Arguments to filter ListeningScenarios to delete.
     * @example
     * // Delete a few ListeningScenarios
     * const { count } = await prisma.listeningScenario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListeningScenarioDeleteManyArgs>(args?: SelectSubset<T, ListeningScenarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListeningScenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningScenarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ListeningScenarios
     * const listeningScenario = await prisma.listeningScenario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListeningScenarioUpdateManyArgs>(args: SelectSubset<T, ListeningScenarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ListeningScenario.
     * @param {ListeningScenarioUpsertArgs} args - Arguments to update or create a ListeningScenario.
     * @example
     * // Update or create a ListeningScenario
     * const listeningScenario = await prisma.listeningScenario.upsert({
     *   create: {
     *     // ... data to create a ListeningScenario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ListeningScenario we want to update
     *   }
     * })
     */
    upsert<T extends ListeningScenarioUpsertArgs>(args: SelectSubset<T, ListeningScenarioUpsertArgs<ExtArgs>>): Prisma__ListeningScenarioClient<$Result.GetResult<Prisma.$ListeningScenarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ListeningScenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningScenarioCountArgs} args - Arguments to filter ListeningScenarios to count.
     * @example
     * // Count the number of ListeningScenarios
     * const count = await prisma.listeningScenario.count({
     *   where: {
     *     // ... the filter for the ListeningScenarios we want to count
     *   }
     * })
    **/
    count<T extends ListeningScenarioCountArgs>(
      args?: Subset<T, ListeningScenarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListeningScenarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ListeningScenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningScenarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListeningScenarioAggregateArgs>(args: Subset<T, ListeningScenarioAggregateArgs>): Prisma.PrismaPromise<GetListeningScenarioAggregateType<T>>

    /**
     * Group by ListeningScenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningScenarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListeningScenarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListeningScenarioGroupByArgs['orderBy'] }
        : { orderBy?: ListeningScenarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListeningScenarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListeningScenarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ListeningScenario model
   */
  readonly fields: ListeningScenarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ListeningScenario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListeningScenarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends ListeningScenario$questionsArgs<ExtArgs> = {}>(args?: Subset<T, ListeningScenario$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListeningQuestionPayload<ExtArgs>, T, "findMany"> | Null>
    attempts<T extends ListeningScenario$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, ListeningScenario$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ListeningScenario model
   */ 
  interface ListeningScenarioFieldRefs {
    readonly id: FieldRef<"ListeningScenario", 'Int'>
    readonly topic: FieldRef<"ListeningScenario", 'String'>
    readonly passage: FieldRef<"ListeningScenario", 'String'>
    readonly difficulty: FieldRef<"ListeningScenario", 'String'>
    readonly createdAt: FieldRef<"ListeningScenario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ListeningScenario findUnique
   */
  export type ListeningScenarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningScenario
     */
    select?: ListeningScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningScenarioInclude<ExtArgs> | null
    /**
     * Filter, which ListeningScenario to fetch.
     */
    where: ListeningScenarioWhereUniqueInput
  }

  /**
   * ListeningScenario findUniqueOrThrow
   */
  export type ListeningScenarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningScenario
     */
    select?: ListeningScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningScenarioInclude<ExtArgs> | null
    /**
     * Filter, which ListeningScenario to fetch.
     */
    where: ListeningScenarioWhereUniqueInput
  }

  /**
   * ListeningScenario findFirst
   */
  export type ListeningScenarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningScenario
     */
    select?: ListeningScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningScenarioInclude<ExtArgs> | null
    /**
     * Filter, which ListeningScenario to fetch.
     */
    where?: ListeningScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListeningScenarios to fetch.
     */
    orderBy?: ListeningScenarioOrderByWithRelationInput | ListeningScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListeningScenarios.
     */
    cursor?: ListeningScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListeningScenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListeningScenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListeningScenarios.
     */
    distinct?: ListeningScenarioScalarFieldEnum | ListeningScenarioScalarFieldEnum[]
  }

  /**
   * ListeningScenario findFirstOrThrow
   */
  export type ListeningScenarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningScenario
     */
    select?: ListeningScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningScenarioInclude<ExtArgs> | null
    /**
     * Filter, which ListeningScenario to fetch.
     */
    where?: ListeningScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListeningScenarios to fetch.
     */
    orderBy?: ListeningScenarioOrderByWithRelationInput | ListeningScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListeningScenarios.
     */
    cursor?: ListeningScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListeningScenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListeningScenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListeningScenarios.
     */
    distinct?: ListeningScenarioScalarFieldEnum | ListeningScenarioScalarFieldEnum[]
  }

  /**
   * ListeningScenario findMany
   */
  export type ListeningScenarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningScenario
     */
    select?: ListeningScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningScenarioInclude<ExtArgs> | null
    /**
     * Filter, which ListeningScenarios to fetch.
     */
    where?: ListeningScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListeningScenarios to fetch.
     */
    orderBy?: ListeningScenarioOrderByWithRelationInput | ListeningScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ListeningScenarios.
     */
    cursor?: ListeningScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListeningScenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListeningScenarios.
     */
    skip?: number
    distinct?: ListeningScenarioScalarFieldEnum | ListeningScenarioScalarFieldEnum[]
  }

  /**
   * ListeningScenario create
   */
  export type ListeningScenarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningScenario
     */
    select?: ListeningScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningScenarioInclude<ExtArgs> | null
    /**
     * The data needed to create a ListeningScenario.
     */
    data: XOR<ListeningScenarioCreateInput, ListeningScenarioUncheckedCreateInput>
  }

  /**
   * ListeningScenario createMany
   */
  export type ListeningScenarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ListeningScenarios.
     */
    data: ListeningScenarioCreateManyInput | ListeningScenarioCreateManyInput[]
  }

  /**
   * ListeningScenario createManyAndReturn
   */
  export type ListeningScenarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningScenario
     */
    select?: ListeningScenarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ListeningScenarios.
     */
    data: ListeningScenarioCreateManyInput | ListeningScenarioCreateManyInput[]
  }

  /**
   * ListeningScenario update
   */
  export type ListeningScenarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningScenario
     */
    select?: ListeningScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningScenarioInclude<ExtArgs> | null
    /**
     * The data needed to update a ListeningScenario.
     */
    data: XOR<ListeningScenarioUpdateInput, ListeningScenarioUncheckedUpdateInput>
    /**
     * Choose, which ListeningScenario to update.
     */
    where: ListeningScenarioWhereUniqueInput
  }

  /**
   * ListeningScenario updateMany
   */
  export type ListeningScenarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ListeningScenarios.
     */
    data: XOR<ListeningScenarioUpdateManyMutationInput, ListeningScenarioUncheckedUpdateManyInput>
    /**
     * Filter which ListeningScenarios to update
     */
    where?: ListeningScenarioWhereInput
  }

  /**
   * ListeningScenario upsert
   */
  export type ListeningScenarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningScenario
     */
    select?: ListeningScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningScenarioInclude<ExtArgs> | null
    /**
     * The filter to search for the ListeningScenario to update in case it exists.
     */
    where: ListeningScenarioWhereUniqueInput
    /**
     * In case the ListeningScenario found by the `where` argument doesn't exist, create a new ListeningScenario with this data.
     */
    create: XOR<ListeningScenarioCreateInput, ListeningScenarioUncheckedCreateInput>
    /**
     * In case the ListeningScenario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListeningScenarioUpdateInput, ListeningScenarioUncheckedUpdateInput>
  }

  /**
   * ListeningScenario delete
   */
  export type ListeningScenarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningScenario
     */
    select?: ListeningScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningScenarioInclude<ExtArgs> | null
    /**
     * Filter which ListeningScenario to delete.
     */
    where: ListeningScenarioWhereUniqueInput
  }

  /**
   * ListeningScenario deleteMany
   */
  export type ListeningScenarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListeningScenarios to delete
     */
    where?: ListeningScenarioWhereInput
  }

  /**
   * ListeningScenario.questions
   */
  export type ListeningScenario$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningQuestion
     */
    select?: ListeningQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningQuestionInclude<ExtArgs> | null
    where?: ListeningQuestionWhereInput
    orderBy?: ListeningQuestionOrderByWithRelationInput | ListeningQuestionOrderByWithRelationInput[]
    cursor?: ListeningQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListeningQuestionScalarFieldEnum | ListeningQuestionScalarFieldEnum[]
  }

  /**
   * ListeningScenario.attempts
   */
  export type ListeningScenario$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    where?: ExamAttemptWhereInput
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    cursor?: ExamAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * ListeningScenario without action
   */
  export type ListeningScenarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningScenario
     */
    select?: ListeningScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningScenarioInclude<ExtArgs> | null
  }


  /**
   * Model ListeningQuestion
   */

  export type AggregateListeningQuestion = {
    _count: ListeningQuestionCountAggregateOutputType | null
    _avg: ListeningQuestionAvgAggregateOutputType | null
    _sum: ListeningQuestionSumAggregateOutputType | null
    _min: ListeningQuestionMinAggregateOutputType | null
    _max: ListeningQuestionMaxAggregateOutputType | null
  }

  export type ListeningQuestionAvgAggregateOutputType = {
    id: number | null
    scenarioId: number | null
  }

  export type ListeningQuestionSumAggregateOutputType = {
    id: number | null
    scenarioId: number | null
  }

  export type ListeningQuestionMinAggregateOutputType = {
    id: number | null
    scenarioId: number | null
    qid: string | null
    text: string | null
    options: string | null
    correct: string | null
  }

  export type ListeningQuestionMaxAggregateOutputType = {
    id: number | null
    scenarioId: number | null
    qid: string | null
    text: string | null
    options: string | null
    correct: string | null
  }

  export type ListeningQuestionCountAggregateOutputType = {
    id: number
    scenarioId: number
    qid: number
    text: number
    options: number
    correct: number
    _all: number
  }


  export type ListeningQuestionAvgAggregateInputType = {
    id?: true
    scenarioId?: true
  }

  export type ListeningQuestionSumAggregateInputType = {
    id?: true
    scenarioId?: true
  }

  export type ListeningQuestionMinAggregateInputType = {
    id?: true
    scenarioId?: true
    qid?: true
    text?: true
    options?: true
    correct?: true
  }

  export type ListeningQuestionMaxAggregateInputType = {
    id?: true
    scenarioId?: true
    qid?: true
    text?: true
    options?: true
    correct?: true
  }

  export type ListeningQuestionCountAggregateInputType = {
    id?: true
    scenarioId?: true
    qid?: true
    text?: true
    options?: true
    correct?: true
    _all?: true
  }

  export type ListeningQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListeningQuestion to aggregate.
     */
    where?: ListeningQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListeningQuestions to fetch.
     */
    orderBy?: ListeningQuestionOrderByWithRelationInput | ListeningQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListeningQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListeningQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListeningQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ListeningQuestions
    **/
    _count?: true | ListeningQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListeningQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListeningQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListeningQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListeningQuestionMaxAggregateInputType
  }

  export type GetListeningQuestionAggregateType<T extends ListeningQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateListeningQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListeningQuestion[P]>
      : GetScalarType<T[P], AggregateListeningQuestion[P]>
  }




  export type ListeningQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListeningQuestionWhereInput
    orderBy?: ListeningQuestionOrderByWithAggregationInput | ListeningQuestionOrderByWithAggregationInput[]
    by: ListeningQuestionScalarFieldEnum[] | ListeningQuestionScalarFieldEnum
    having?: ListeningQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListeningQuestionCountAggregateInputType | true
    _avg?: ListeningQuestionAvgAggregateInputType
    _sum?: ListeningQuestionSumAggregateInputType
    _min?: ListeningQuestionMinAggregateInputType
    _max?: ListeningQuestionMaxAggregateInputType
  }

  export type ListeningQuestionGroupByOutputType = {
    id: number
    scenarioId: number
    qid: string
    text: string
    options: string
    correct: string
    _count: ListeningQuestionCountAggregateOutputType | null
    _avg: ListeningQuestionAvgAggregateOutputType | null
    _sum: ListeningQuestionSumAggregateOutputType | null
    _min: ListeningQuestionMinAggregateOutputType | null
    _max: ListeningQuestionMaxAggregateOutputType | null
  }

  type GetListeningQuestionGroupByPayload<T extends ListeningQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListeningQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListeningQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListeningQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], ListeningQuestionGroupByOutputType[P]>
        }
      >
    >


  export type ListeningQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scenarioId?: boolean
    qid?: boolean
    text?: boolean
    options?: boolean
    correct?: boolean
    scenario?: boolean | ListeningScenarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listeningQuestion"]>

  export type ListeningQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scenarioId?: boolean
    qid?: boolean
    text?: boolean
    options?: boolean
    correct?: boolean
    scenario?: boolean | ListeningScenarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listeningQuestion"]>

  export type ListeningQuestionSelectScalar = {
    id?: boolean
    scenarioId?: boolean
    qid?: boolean
    text?: boolean
    options?: boolean
    correct?: boolean
  }

  export type ListeningQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scenario?: boolean | ListeningScenarioDefaultArgs<ExtArgs>
  }
  export type ListeningQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scenario?: boolean | ListeningScenarioDefaultArgs<ExtArgs>
  }

  export type $ListeningQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ListeningQuestion"
    objects: {
      scenario: Prisma.$ListeningScenarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      scenarioId: number
      qid: string
      text: string
      options: string
      correct: string
    }, ExtArgs["result"]["listeningQuestion"]>
    composites: {}
  }

  type ListeningQuestionGetPayload<S extends boolean | null | undefined | ListeningQuestionDefaultArgs> = $Result.GetResult<Prisma.$ListeningQuestionPayload, S>

  type ListeningQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ListeningQuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ListeningQuestionCountAggregateInputType | true
    }

  export interface ListeningQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ListeningQuestion'], meta: { name: 'ListeningQuestion' } }
    /**
     * Find zero or one ListeningQuestion that matches the filter.
     * @param {ListeningQuestionFindUniqueArgs} args - Arguments to find a ListeningQuestion
     * @example
     * // Get one ListeningQuestion
     * const listeningQuestion = await prisma.listeningQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListeningQuestionFindUniqueArgs>(args: SelectSubset<T, ListeningQuestionFindUniqueArgs<ExtArgs>>): Prisma__ListeningQuestionClient<$Result.GetResult<Prisma.$ListeningQuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ListeningQuestion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ListeningQuestionFindUniqueOrThrowArgs} args - Arguments to find a ListeningQuestion
     * @example
     * // Get one ListeningQuestion
     * const listeningQuestion = await prisma.listeningQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListeningQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, ListeningQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListeningQuestionClient<$Result.GetResult<Prisma.$ListeningQuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ListeningQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningQuestionFindFirstArgs} args - Arguments to find a ListeningQuestion
     * @example
     * // Get one ListeningQuestion
     * const listeningQuestion = await prisma.listeningQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListeningQuestionFindFirstArgs>(args?: SelectSubset<T, ListeningQuestionFindFirstArgs<ExtArgs>>): Prisma__ListeningQuestionClient<$Result.GetResult<Prisma.$ListeningQuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ListeningQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningQuestionFindFirstOrThrowArgs} args - Arguments to find a ListeningQuestion
     * @example
     * // Get one ListeningQuestion
     * const listeningQuestion = await prisma.listeningQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListeningQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, ListeningQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListeningQuestionClient<$Result.GetResult<Prisma.$ListeningQuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ListeningQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ListeningQuestions
     * const listeningQuestions = await prisma.listeningQuestion.findMany()
     * 
     * // Get first 10 ListeningQuestions
     * const listeningQuestions = await prisma.listeningQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listeningQuestionWithIdOnly = await prisma.listeningQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListeningQuestionFindManyArgs>(args?: SelectSubset<T, ListeningQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListeningQuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ListeningQuestion.
     * @param {ListeningQuestionCreateArgs} args - Arguments to create a ListeningQuestion.
     * @example
     * // Create one ListeningQuestion
     * const ListeningQuestion = await prisma.listeningQuestion.create({
     *   data: {
     *     // ... data to create a ListeningQuestion
     *   }
     * })
     * 
     */
    create<T extends ListeningQuestionCreateArgs>(args: SelectSubset<T, ListeningQuestionCreateArgs<ExtArgs>>): Prisma__ListeningQuestionClient<$Result.GetResult<Prisma.$ListeningQuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ListeningQuestions.
     * @param {ListeningQuestionCreateManyArgs} args - Arguments to create many ListeningQuestions.
     * @example
     * // Create many ListeningQuestions
     * const listeningQuestion = await prisma.listeningQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListeningQuestionCreateManyArgs>(args?: SelectSubset<T, ListeningQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ListeningQuestions and returns the data saved in the database.
     * @param {ListeningQuestionCreateManyAndReturnArgs} args - Arguments to create many ListeningQuestions.
     * @example
     * // Create many ListeningQuestions
     * const listeningQuestion = await prisma.listeningQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ListeningQuestions and only return the `id`
     * const listeningQuestionWithIdOnly = await prisma.listeningQuestion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListeningQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, ListeningQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListeningQuestionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ListeningQuestion.
     * @param {ListeningQuestionDeleteArgs} args - Arguments to delete one ListeningQuestion.
     * @example
     * // Delete one ListeningQuestion
     * const ListeningQuestion = await prisma.listeningQuestion.delete({
     *   where: {
     *     // ... filter to delete one ListeningQuestion
     *   }
     * })
     * 
     */
    delete<T extends ListeningQuestionDeleteArgs>(args: SelectSubset<T, ListeningQuestionDeleteArgs<ExtArgs>>): Prisma__ListeningQuestionClient<$Result.GetResult<Prisma.$ListeningQuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ListeningQuestion.
     * @param {ListeningQuestionUpdateArgs} args - Arguments to update one ListeningQuestion.
     * @example
     * // Update one ListeningQuestion
     * const listeningQuestion = await prisma.listeningQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListeningQuestionUpdateArgs>(args: SelectSubset<T, ListeningQuestionUpdateArgs<ExtArgs>>): Prisma__ListeningQuestionClient<$Result.GetResult<Prisma.$ListeningQuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ListeningQuestions.
     * @param {ListeningQuestionDeleteManyArgs} args - Arguments to filter ListeningQuestions to delete.
     * @example
     * // Delete a few ListeningQuestions
     * const { count } = await prisma.listeningQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListeningQuestionDeleteManyArgs>(args?: SelectSubset<T, ListeningQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListeningQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ListeningQuestions
     * const listeningQuestion = await prisma.listeningQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListeningQuestionUpdateManyArgs>(args: SelectSubset<T, ListeningQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ListeningQuestion.
     * @param {ListeningQuestionUpsertArgs} args - Arguments to update or create a ListeningQuestion.
     * @example
     * // Update or create a ListeningQuestion
     * const listeningQuestion = await prisma.listeningQuestion.upsert({
     *   create: {
     *     // ... data to create a ListeningQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ListeningQuestion we want to update
     *   }
     * })
     */
    upsert<T extends ListeningQuestionUpsertArgs>(args: SelectSubset<T, ListeningQuestionUpsertArgs<ExtArgs>>): Prisma__ListeningQuestionClient<$Result.GetResult<Prisma.$ListeningQuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ListeningQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningQuestionCountArgs} args - Arguments to filter ListeningQuestions to count.
     * @example
     * // Count the number of ListeningQuestions
     * const count = await prisma.listeningQuestion.count({
     *   where: {
     *     // ... the filter for the ListeningQuestions we want to count
     *   }
     * })
    **/
    count<T extends ListeningQuestionCountArgs>(
      args?: Subset<T, ListeningQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListeningQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ListeningQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListeningQuestionAggregateArgs>(args: Subset<T, ListeningQuestionAggregateArgs>): Prisma.PrismaPromise<GetListeningQuestionAggregateType<T>>

    /**
     * Group by ListeningQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListeningQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListeningQuestionGroupByArgs['orderBy'] }
        : { orderBy?: ListeningQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListeningQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListeningQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ListeningQuestion model
   */
  readonly fields: ListeningQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ListeningQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListeningQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scenario<T extends ListeningScenarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListeningScenarioDefaultArgs<ExtArgs>>): Prisma__ListeningScenarioClient<$Result.GetResult<Prisma.$ListeningScenarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ListeningQuestion model
   */ 
  interface ListeningQuestionFieldRefs {
    readonly id: FieldRef<"ListeningQuestion", 'Int'>
    readonly scenarioId: FieldRef<"ListeningQuestion", 'Int'>
    readonly qid: FieldRef<"ListeningQuestion", 'String'>
    readonly text: FieldRef<"ListeningQuestion", 'String'>
    readonly options: FieldRef<"ListeningQuestion", 'String'>
    readonly correct: FieldRef<"ListeningQuestion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ListeningQuestion findUnique
   */
  export type ListeningQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningQuestion
     */
    select?: ListeningQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ListeningQuestion to fetch.
     */
    where: ListeningQuestionWhereUniqueInput
  }

  /**
   * ListeningQuestion findUniqueOrThrow
   */
  export type ListeningQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningQuestion
     */
    select?: ListeningQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ListeningQuestion to fetch.
     */
    where: ListeningQuestionWhereUniqueInput
  }

  /**
   * ListeningQuestion findFirst
   */
  export type ListeningQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningQuestion
     */
    select?: ListeningQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ListeningQuestion to fetch.
     */
    where?: ListeningQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListeningQuestions to fetch.
     */
    orderBy?: ListeningQuestionOrderByWithRelationInput | ListeningQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListeningQuestions.
     */
    cursor?: ListeningQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListeningQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListeningQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListeningQuestions.
     */
    distinct?: ListeningQuestionScalarFieldEnum | ListeningQuestionScalarFieldEnum[]
  }

  /**
   * ListeningQuestion findFirstOrThrow
   */
  export type ListeningQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningQuestion
     */
    select?: ListeningQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ListeningQuestion to fetch.
     */
    where?: ListeningQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListeningQuestions to fetch.
     */
    orderBy?: ListeningQuestionOrderByWithRelationInput | ListeningQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListeningQuestions.
     */
    cursor?: ListeningQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListeningQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListeningQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListeningQuestions.
     */
    distinct?: ListeningQuestionScalarFieldEnum | ListeningQuestionScalarFieldEnum[]
  }

  /**
   * ListeningQuestion findMany
   */
  export type ListeningQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningQuestion
     */
    select?: ListeningQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ListeningQuestions to fetch.
     */
    where?: ListeningQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListeningQuestions to fetch.
     */
    orderBy?: ListeningQuestionOrderByWithRelationInput | ListeningQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ListeningQuestions.
     */
    cursor?: ListeningQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListeningQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListeningQuestions.
     */
    skip?: number
    distinct?: ListeningQuestionScalarFieldEnum | ListeningQuestionScalarFieldEnum[]
  }

  /**
   * ListeningQuestion create
   */
  export type ListeningQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningQuestion
     */
    select?: ListeningQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a ListeningQuestion.
     */
    data: XOR<ListeningQuestionCreateInput, ListeningQuestionUncheckedCreateInput>
  }

  /**
   * ListeningQuestion createMany
   */
  export type ListeningQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ListeningQuestions.
     */
    data: ListeningQuestionCreateManyInput | ListeningQuestionCreateManyInput[]
  }

  /**
   * ListeningQuestion createManyAndReturn
   */
  export type ListeningQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningQuestion
     */
    select?: ListeningQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ListeningQuestions.
     */
    data: ListeningQuestionCreateManyInput | ListeningQuestionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListeningQuestion update
   */
  export type ListeningQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningQuestion
     */
    select?: ListeningQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a ListeningQuestion.
     */
    data: XOR<ListeningQuestionUpdateInput, ListeningQuestionUncheckedUpdateInput>
    /**
     * Choose, which ListeningQuestion to update.
     */
    where: ListeningQuestionWhereUniqueInput
  }

  /**
   * ListeningQuestion updateMany
   */
  export type ListeningQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ListeningQuestions.
     */
    data: XOR<ListeningQuestionUpdateManyMutationInput, ListeningQuestionUncheckedUpdateManyInput>
    /**
     * Filter which ListeningQuestions to update
     */
    where?: ListeningQuestionWhereInput
  }

  /**
   * ListeningQuestion upsert
   */
  export type ListeningQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningQuestion
     */
    select?: ListeningQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the ListeningQuestion to update in case it exists.
     */
    where: ListeningQuestionWhereUniqueInput
    /**
     * In case the ListeningQuestion found by the `where` argument doesn't exist, create a new ListeningQuestion with this data.
     */
    create: XOR<ListeningQuestionCreateInput, ListeningQuestionUncheckedCreateInput>
    /**
     * In case the ListeningQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListeningQuestionUpdateInput, ListeningQuestionUncheckedUpdateInput>
  }

  /**
   * ListeningQuestion delete
   */
  export type ListeningQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningQuestion
     */
    select?: ListeningQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningQuestionInclude<ExtArgs> | null
    /**
     * Filter which ListeningQuestion to delete.
     */
    where: ListeningQuestionWhereUniqueInput
  }

  /**
   * ListeningQuestion deleteMany
   */
  export type ListeningQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListeningQuestions to delete
     */
    where?: ListeningQuestionWhereInput
  }

  /**
   * ListeningQuestion without action
   */
  export type ListeningQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningQuestion
     */
    select?: ListeningQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningQuestionInclude<ExtArgs> | null
  }


  /**
   * Model WritingTopic
   */

  export type AggregateWritingTopic = {
    _count: WritingTopicCountAggregateOutputType | null
    _avg: WritingTopicAvgAggregateOutputType | null
    _sum: WritingTopicSumAggregateOutputType | null
    _min: WritingTopicMinAggregateOutputType | null
    _max: WritingTopicMaxAggregateOutputType | null
  }

  export type WritingTopicAvgAggregateOutputType = {
    id: number | null
  }

  export type WritingTopicSumAggregateOutputType = {
    id: number | null
  }

  export type WritingTopicMinAggregateOutputType = {
    id: number | null
    topic: string | null
    difficulty: string | null
    createdAt: Date | null
  }

  export type WritingTopicMaxAggregateOutputType = {
    id: number | null
    topic: string | null
    difficulty: string | null
    createdAt: Date | null
  }

  export type WritingTopicCountAggregateOutputType = {
    id: number
    topic: number
    difficulty: number
    createdAt: number
    _all: number
  }


  export type WritingTopicAvgAggregateInputType = {
    id?: true
  }

  export type WritingTopicSumAggregateInputType = {
    id?: true
  }

  export type WritingTopicMinAggregateInputType = {
    id?: true
    topic?: true
    difficulty?: true
    createdAt?: true
  }

  export type WritingTopicMaxAggregateInputType = {
    id?: true
    topic?: true
    difficulty?: true
    createdAt?: true
  }

  export type WritingTopicCountAggregateInputType = {
    id?: true
    topic?: true
    difficulty?: true
    createdAt?: true
    _all?: true
  }

  export type WritingTopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WritingTopic to aggregate.
     */
    where?: WritingTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WritingTopics to fetch.
     */
    orderBy?: WritingTopicOrderByWithRelationInput | WritingTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WritingTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WritingTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WritingTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WritingTopics
    **/
    _count?: true | WritingTopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WritingTopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WritingTopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WritingTopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WritingTopicMaxAggregateInputType
  }

  export type GetWritingTopicAggregateType<T extends WritingTopicAggregateArgs> = {
        [P in keyof T & keyof AggregateWritingTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWritingTopic[P]>
      : GetScalarType<T[P], AggregateWritingTopic[P]>
  }




  export type WritingTopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WritingTopicWhereInput
    orderBy?: WritingTopicOrderByWithAggregationInput | WritingTopicOrderByWithAggregationInput[]
    by: WritingTopicScalarFieldEnum[] | WritingTopicScalarFieldEnum
    having?: WritingTopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WritingTopicCountAggregateInputType | true
    _avg?: WritingTopicAvgAggregateInputType
    _sum?: WritingTopicSumAggregateInputType
    _min?: WritingTopicMinAggregateInputType
    _max?: WritingTopicMaxAggregateInputType
  }

  export type WritingTopicGroupByOutputType = {
    id: number
    topic: string
    difficulty: string | null
    createdAt: Date
    _count: WritingTopicCountAggregateOutputType | null
    _avg: WritingTopicAvgAggregateOutputType | null
    _sum: WritingTopicSumAggregateOutputType | null
    _min: WritingTopicMinAggregateOutputType | null
    _max: WritingTopicMaxAggregateOutputType | null
  }

  type GetWritingTopicGroupByPayload<T extends WritingTopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WritingTopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WritingTopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WritingTopicGroupByOutputType[P]>
            : GetScalarType<T[P], WritingTopicGroupByOutputType[P]>
        }
      >
    >


  export type WritingTopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    difficulty?: boolean
    createdAt?: boolean
    attempts?: boolean | WritingTopic$attemptsArgs<ExtArgs>
    _count?: boolean | WritingTopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["writingTopic"]>

  export type WritingTopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    difficulty?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["writingTopic"]>

  export type WritingTopicSelectScalar = {
    id?: boolean
    topic?: boolean
    difficulty?: boolean
    createdAt?: boolean
  }

  export type WritingTopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempts?: boolean | WritingTopic$attemptsArgs<ExtArgs>
    _count?: boolean | WritingTopicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WritingTopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WritingTopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WritingTopic"
    objects: {
      attempts: Prisma.$ExamAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      topic: string
      difficulty: string | null
      createdAt: Date
    }, ExtArgs["result"]["writingTopic"]>
    composites: {}
  }

  type WritingTopicGetPayload<S extends boolean | null | undefined | WritingTopicDefaultArgs> = $Result.GetResult<Prisma.$WritingTopicPayload, S>

  type WritingTopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WritingTopicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WritingTopicCountAggregateInputType | true
    }

  export interface WritingTopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WritingTopic'], meta: { name: 'WritingTopic' } }
    /**
     * Find zero or one WritingTopic that matches the filter.
     * @param {WritingTopicFindUniqueArgs} args - Arguments to find a WritingTopic
     * @example
     * // Get one WritingTopic
     * const writingTopic = await prisma.writingTopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WritingTopicFindUniqueArgs>(args: SelectSubset<T, WritingTopicFindUniqueArgs<ExtArgs>>): Prisma__WritingTopicClient<$Result.GetResult<Prisma.$WritingTopicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WritingTopic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WritingTopicFindUniqueOrThrowArgs} args - Arguments to find a WritingTopic
     * @example
     * // Get one WritingTopic
     * const writingTopic = await prisma.writingTopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WritingTopicFindUniqueOrThrowArgs>(args: SelectSubset<T, WritingTopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WritingTopicClient<$Result.GetResult<Prisma.$WritingTopicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WritingTopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WritingTopicFindFirstArgs} args - Arguments to find a WritingTopic
     * @example
     * // Get one WritingTopic
     * const writingTopic = await prisma.writingTopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WritingTopicFindFirstArgs>(args?: SelectSubset<T, WritingTopicFindFirstArgs<ExtArgs>>): Prisma__WritingTopicClient<$Result.GetResult<Prisma.$WritingTopicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WritingTopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WritingTopicFindFirstOrThrowArgs} args - Arguments to find a WritingTopic
     * @example
     * // Get one WritingTopic
     * const writingTopic = await prisma.writingTopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WritingTopicFindFirstOrThrowArgs>(args?: SelectSubset<T, WritingTopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__WritingTopicClient<$Result.GetResult<Prisma.$WritingTopicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WritingTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WritingTopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WritingTopics
     * const writingTopics = await prisma.writingTopic.findMany()
     * 
     * // Get first 10 WritingTopics
     * const writingTopics = await prisma.writingTopic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const writingTopicWithIdOnly = await prisma.writingTopic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WritingTopicFindManyArgs>(args?: SelectSubset<T, WritingTopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WritingTopicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WritingTopic.
     * @param {WritingTopicCreateArgs} args - Arguments to create a WritingTopic.
     * @example
     * // Create one WritingTopic
     * const WritingTopic = await prisma.writingTopic.create({
     *   data: {
     *     // ... data to create a WritingTopic
     *   }
     * })
     * 
     */
    create<T extends WritingTopicCreateArgs>(args: SelectSubset<T, WritingTopicCreateArgs<ExtArgs>>): Prisma__WritingTopicClient<$Result.GetResult<Prisma.$WritingTopicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WritingTopics.
     * @param {WritingTopicCreateManyArgs} args - Arguments to create many WritingTopics.
     * @example
     * // Create many WritingTopics
     * const writingTopic = await prisma.writingTopic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WritingTopicCreateManyArgs>(args?: SelectSubset<T, WritingTopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WritingTopics and returns the data saved in the database.
     * @param {WritingTopicCreateManyAndReturnArgs} args - Arguments to create many WritingTopics.
     * @example
     * // Create many WritingTopics
     * const writingTopic = await prisma.writingTopic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WritingTopics and only return the `id`
     * const writingTopicWithIdOnly = await prisma.writingTopic.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WritingTopicCreateManyAndReturnArgs>(args?: SelectSubset<T, WritingTopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WritingTopicPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WritingTopic.
     * @param {WritingTopicDeleteArgs} args - Arguments to delete one WritingTopic.
     * @example
     * // Delete one WritingTopic
     * const WritingTopic = await prisma.writingTopic.delete({
     *   where: {
     *     // ... filter to delete one WritingTopic
     *   }
     * })
     * 
     */
    delete<T extends WritingTopicDeleteArgs>(args: SelectSubset<T, WritingTopicDeleteArgs<ExtArgs>>): Prisma__WritingTopicClient<$Result.GetResult<Prisma.$WritingTopicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WritingTopic.
     * @param {WritingTopicUpdateArgs} args - Arguments to update one WritingTopic.
     * @example
     * // Update one WritingTopic
     * const writingTopic = await prisma.writingTopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WritingTopicUpdateArgs>(args: SelectSubset<T, WritingTopicUpdateArgs<ExtArgs>>): Prisma__WritingTopicClient<$Result.GetResult<Prisma.$WritingTopicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WritingTopics.
     * @param {WritingTopicDeleteManyArgs} args - Arguments to filter WritingTopics to delete.
     * @example
     * // Delete a few WritingTopics
     * const { count } = await prisma.writingTopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WritingTopicDeleteManyArgs>(args?: SelectSubset<T, WritingTopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WritingTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WritingTopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WritingTopics
     * const writingTopic = await prisma.writingTopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WritingTopicUpdateManyArgs>(args: SelectSubset<T, WritingTopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WritingTopic.
     * @param {WritingTopicUpsertArgs} args - Arguments to update or create a WritingTopic.
     * @example
     * // Update or create a WritingTopic
     * const writingTopic = await prisma.writingTopic.upsert({
     *   create: {
     *     // ... data to create a WritingTopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WritingTopic we want to update
     *   }
     * })
     */
    upsert<T extends WritingTopicUpsertArgs>(args: SelectSubset<T, WritingTopicUpsertArgs<ExtArgs>>): Prisma__WritingTopicClient<$Result.GetResult<Prisma.$WritingTopicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WritingTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WritingTopicCountArgs} args - Arguments to filter WritingTopics to count.
     * @example
     * // Count the number of WritingTopics
     * const count = await prisma.writingTopic.count({
     *   where: {
     *     // ... the filter for the WritingTopics we want to count
     *   }
     * })
    **/
    count<T extends WritingTopicCountArgs>(
      args?: Subset<T, WritingTopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WritingTopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WritingTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WritingTopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WritingTopicAggregateArgs>(args: Subset<T, WritingTopicAggregateArgs>): Prisma.PrismaPromise<GetWritingTopicAggregateType<T>>

    /**
     * Group by WritingTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WritingTopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WritingTopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WritingTopicGroupByArgs['orderBy'] }
        : { orderBy?: WritingTopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WritingTopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWritingTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WritingTopic model
   */
  readonly fields: WritingTopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WritingTopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WritingTopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attempts<T extends WritingTopic$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, WritingTopic$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WritingTopic model
   */ 
  interface WritingTopicFieldRefs {
    readonly id: FieldRef<"WritingTopic", 'Int'>
    readonly topic: FieldRef<"WritingTopic", 'String'>
    readonly difficulty: FieldRef<"WritingTopic", 'String'>
    readonly createdAt: FieldRef<"WritingTopic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WritingTopic findUnique
   */
  export type WritingTopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingTopic
     */
    select?: WritingTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WritingTopicInclude<ExtArgs> | null
    /**
     * Filter, which WritingTopic to fetch.
     */
    where: WritingTopicWhereUniqueInput
  }

  /**
   * WritingTopic findUniqueOrThrow
   */
  export type WritingTopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingTopic
     */
    select?: WritingTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WritingTopicInclude<ExtArgs> | null
    /**
     * Filter, which WritingTopic to fetch.
     */
    where: WritingTopicWhereUniqueInput
  }

  /**
   * WritingTopic findFirst
   */
  export type WritingTopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingTopic
     */
    select?: WritingTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WritingTopicInclude<ExtArgs> | null
    /**
     * Filter, which WritingTopic to fetch.
     */
    where?: WritingTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WritingTopics to fetch.
     */
    orderBy?: WritingTopicOrderByWithRelationInput | WritingTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WritingTopics.
     */
    cursor?: WritingTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WritingTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WritingTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WritingTopics.
     */
    distinct?: WritingTopicScalarFieldEnum | WritingTopicScalarFieldEnum[]
  }

  /**
   * WritingTopic findFirstOrThrow
   */
  export type WritingTopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingTopic
     */
    select?: WritingTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WritingTopicInclude<ExtArgs> | null
    /**
     * Filter, which WritingTopic to fetch.
     */
    where?: WritingTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WritingTopics to fetch.
     */
    orderBy?: WritingTopicOrderByWithRelationInput | WritingTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WritingTopics.
     */
    cursor?: WritingTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WritingTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WritingTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WritingTopics.
     */
    distinct?: WritingTopicScalarFieldEnum | WritingTopicScalarFieldEnum[]
  }

  /**
   * WritingTopic findMany
   */
  export type WritingTopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingTopic
     */
    select?: WritingTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WritingTopicInclude<ExtArgs> | null
    /**
     * Filter, which WritingTopics to fetch.
     */
    where?: WritingTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WritingTopics to fetch.
     */
    orderBy?: WritingTopicOrderByWithRelationInput | WritingTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WritingTopics.
     */
    cursor?: WritingTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WritingTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WritingTopics.
     */
    skip?: number
    distinct?: WritingTopicScalarFieldEnum | WritingTopicScalarFieldEnum[]
  }

  /**
   * WritingTopic create
   */
  export type WritingTopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingTopic
     */
    select?: WritingTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WritingTopicInclude<ExtArgs> | null
    /**
     * The data needed to create a WritingTopic.
     */
    data: XOR<WritingTopicCreateInput, WritingTopicUncheckedCreateInput>
  }

  /**
   * WritingTopic createMany
   */
  export type WritingTopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WritingTopics.
     */
    data: WritingTopicCreateManyInput | WritingTopicCreateManyInput[]
  }

  /**
   * WritingTopic createManyAndReturn
   */
  export type WritingTopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingTopic
     */
    select?: WritingTopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WritingTopics.
     */
    data: WritingTopicCreateManyInput | WritingTopicCreateManyInput[]
  }

  /**
   * WritingTopic update
   */
  export type WritingTopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingTopic
     */
    select?: WritingTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WritingTopicInclude<ExtArgs> | null
    /**
     * The data needed to update a WritingTopic.
     */
    data: XOR<WritingTopicUpdateInput, WritingTopicUncheckedUpdateInput>
    /**
     * Choose, which WritingTopic to update.
     */
    where: WritingTopicWhereUniqueInput
  }

  /**
   * WritingTopic updateMany
   */
  export type WritingTopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WritingTopics.
     */
    data: XOR<WritingTopicUpdateManyMutationInput, WritingTopicUncheckedUpdateManyInput>
    /**
     * Filter which WritingTopics to update
     */
    where?: WritingTopicWhereInput
  }

  /**
   * WritingTopic upsert
   */
  export type WritingTopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingTopic
     */
    select?: WritingTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WritingTopicInclude<ExtArgs> | null
    /**
     * The filter to search for the WritingTopic to update in case it exists.
     */
    where: WritingTopicWhereUniqueInput
    /**
     * In case the WritingTopic found by the `where` argument doesn't exist, create a new WritingTopic with this data.
     */
    create: XOR<WritingTopicCreateInput, WritingTopicUncheckedCreateInput>
    /**
     * In case the WritingTopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WritingTopicUpdateInput, WritingTopicUncheckedUpdateInput>
  }

  /**
   * WritingTopic delete
   */
  export type WritingTopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingTopic
     */
    select?: WritingTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WritingTopicInclude<ExtArgs> | null
    /**
     * Filter which WritingTopic to delete.
     */
    where: WritingTopicWhereUniqueInput
  }

  /**
   * WritingTopic deleteMany
   */
  export type WritingTopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WritingTopics to delete
     */
    where?: WritingTopicWhereInput
  }

  /**
   * WritingTopic.attempts
   */
  export type WritingTopic$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    where?: ExamAttemptWhereInput
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    cursor?: ExamAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * WritingTopic without action
   */
  export type WritingTopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingTopic
     */
    select?: WritingTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WritingTopicInclude<ExtArgs> | null
  }


  /**
   * Model SpeakingSet
   */

  export type AggregateSpeakingSet = {
    _count: SpeakingSetCountAggregateOutputType | null
    _avg: SpeakingSetAvgAggregateOutputType | null
    _sum: SpeakingSetSumAggregateOutputType | null
    _min: SpeakingSetMinAggregateOutputType | null
    _max: SpeakingSetMaxAggregateOutputType | null
  }

  export type SpeakingSetAvgAggregateOutputType = {
    id: number | null
  }

  export type SpeakingSetSumAggregateOutputType = {
    id: number | null
  }

  export type SpeakingSetMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
  }

  export type SpeakingSetMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
  }

  export type SpeakingSetCountAggregateOutputType = {
    id: number
    createdAt: number
    _all: number
  }


  export type SpeakingSetAvgAggregateInputType = {
    id?: true
  }

  export type SpeakingSetSumAggregateInputType = {
    id?: true
  }

  export type SpeakingSetMinAggregateInputType = {
    id?: true
    createdAt?: true
  }

  export type SpeakingSetMaxAggregateInputType = {
    id?: true
    createdAt?: true
  }

  export type SpeakingSetCountAggregateInputType = {
    id?: true
    createdAt?: true
    _all?: true
  }

  export type SpeakingSetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeakingSet to aggregate.
     */
    where?: SpeakingSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakingSets to fetch.
     */
    orderBy?: SpeakingSetOrderByWithRelationInput | SpeakingSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpeakingSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakingSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakingSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpeakingSets
    **/
    _count?: true | SpeakingSetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpeakingSetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpeakingSetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeakingSetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeakingSetMaxAggregateInputType
  }

  export type GetSpeakingSetAggregateType<T extends SpeakingSetAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeakingSet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeakingSet[P]>
      : GetScalarType<T[P], AggregateSpeakingSet[P]>
  }




  export type SpeakingSetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakingSetWhereInput
    orderBy?: SpeakingSetOrderByWithAggregationInput | SpeakingSetOrderByWithAggregationInput[]
    by: SpeakingSetScalarFieldEnum[] | SpeakingSetScalarFieldEnum
    having?: SpeakingSetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeakingSetCountAggregateInputType | true
    _avg?: SpeakingSetAvgAggregateInputType
    _sum?: SpeakingSetSumAggregateInputType
    _min?: SpeakingSetMinAggregateInputType
    _max?: SpeakingSetMaxAggregateInputType
  }

  export type SpeakingSetGroupByOutputType = {
    id: number
    createdAt: Date
    _count: SpeakingSetCountAggregateOutputType | null
    _avg: SpeakingSetAvgAggregateOutputType | null
    _sum: SpeakingSetSumAggregateOutputType | null
    _min: SpeakingSetMinAggregateOutputType | null
    _max: SpeakingSetMaxAggregateOutputType | null
  }

  type GetSpeakingSetGroupByPayload<T extends SpeakingSetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpeakingSetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeakingSetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeakingSetGroupByOutputType[P]>
            : GetScalarType<T[P], SpeakingSetGroupByOutputType[P]>
        }
      >
    >


  export type SpeakingSetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    prompts?: boolean | SpeakingSet$promptsArgs<ExtArgs>
    attempts?: boolean | SpeakingSet$attemptsArgs<ExtArgs>
    _count?: boolean | SpeakingSetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speakingSet"]>

  export type SpeakingSetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["speakingSet"]>

  export type SpeakingSetSelectScalar = {
    id?: boolean
    createdAt?: boolean
  }

  export type SpeakingSetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompts?: boolean | SpeakingSet$promptsArgs<ExtArgs>
    attempts?: boolean | SpeakingSet$attemptsArgs<ExtArgs>
    _count?: boolean | SpeakingSetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpeakingSetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SpeakingSetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpeakingSet"
    objects: {
      prompts: Prisma.$SpeakingPromptPayload<ExtArgs>[]
      attempts: Prisma.$ExamAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
    }, ExtArgs["result"]["speakingSet"]>
    composites: {}
  }

  type SpeakingSetGetPayload<S extends boolean | null | undefined | SpeakingSetDefaultArgs> = $Result.GetResult<Prisma.$SpeakingSetPayload, S>

  type SpeakingSetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpeakingSetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpeakingSetCountAggregateInputType | true
    }

  export interface SpeakingSetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpeakingSet'], meta: { name: 'SpeakingSet' } }
    /**
     * Find zero or one SpeakingSet that matches the filter.
     * @param {SpeakingSetFindUniqueArgs} args - Arguments to find a SpeakingSet
     * @example
     * // Get one SpeakingSet
     * const speakingSet = await prisma.speakingSet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpeakingSetFindUniqueArgs>(args: SelectSubset<T, SpeakingSetFindUniqueArgs<ExtArgs>>): Prisma__SpeakingSetClient<$Result.GetResult<Prisma.$SpeakingSetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SpeakingSet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpeakingSetFindUniqueOrThrowArgs} args - Arguments to find a SpeakingSet
     * @example
     * // Get one SpeakingSet
     * const speakingSet = await prisma.speakingSet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpeakingSetFindUniqueOrThrowArgs>(args: SelectSubset<T, SpeakingSetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpeakingSetClient<$Result.GetResult<Prisma.$SpeakingSetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SpeakingSet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingSetFindFirstArgs} args - Arguments to find a SpeakingSet
     * @example
     * // Get one SpeakingSet
     * const speakingSet = await prisma.speakingSet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpeakingSetFindFirstArgs>(args?: SelectSubset<T, SpeakingSetFindFirstArgs<ExtArgs>>): Prisma__SpeakingSetClient<$Result.GetResult<Prisma.$SpeakingSetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SpeakingSet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingSetFindFirstOrThrowArgs} args - Arguments to find a SpeakingSet
     * @example
     * // Get one SpeakingSet
     * const speakingSet = await prisma.speakingSet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpeakingSetFindFirstOrThrowArgs>(args?: SelectSubset<T, SpeakingSetFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpeakingSetClient<$Result.GetResult<Prisma.$SpeakingSetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpeakingSets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingSetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpeakingSets
     * const speakingSets = await prisma.speakingSet.findMany()
     * 
     * // Get first 10 SpeakingSets
     * const speakingSets = await prisma.speakingSet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speakingSetWithIdOnly = await prisma.speakingSet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpeakingSetFindManyArgs>(args?: SelectSubset<T, SpeakingSetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakingSetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SpeakingSet.
     * @param {SpeakingSetCreateArgs} args - Arguments to create a SpeakingSet.
     * @example
     * // Create one SpeakingSet
     * const SpeakingSet = await prisma.speakingSet.create({
     *   data: {
     *     // ... data to create a SpeakingSet
     *   }
     * })
     * 
     */
    create<T extends SpeakingSetCreateArgs>(args: SelectSubset<T, SpeakingSetCreateArgs<ExtArgs>>): Prisma__SpeakingSetClient<$Result.GetResult<Prisma.$SpeakingSetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpeakingSets.
     * @param {SpeakingSetCreateManyArgs} args - Arguments to create many SpeakingSets.
     * @example
     * // Create many SpeakingSets
     * const speakingSet = await prisma.speakingSet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpeakingSetCreateManyArgs>(args?: SelectSubset<T, SpeakingSetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpeakingSets and returns the data saved in the database.
     * @param {SpeakingSetCreateManyAndReturnArgs} args - Arguments to create many SpeakingSets.
     * @example
     * // Create many SpeakingSets
     * const speakingSet = await prisma.speakingSet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpeakingSets and only return the `id`
     * const speakingSetWithIdOnly = await prisma.speakingSet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpeakingSetCreateManyAndReturnArgs>(args?: SelectSubset<T, SpeakingSetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakingSetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SpeakingSet.
     * @param {SpeakingSetDeleteArgs} args - Arguments to delete one SpeakingSet.
     * @example
     * // Delete one SpeakingSet
     * const SpeakingSet = await prisma.speakingSet.delete({
     *   where: {
     *     // ... filter to delete one SpeakingSet
     *   }
     * })
     * 
     */
    delete<T extends SpeakingSetDeleteArgs>(args: SelectSubset<T, SpeakingSetDeleteArgs<ExtArgs>>): Prisma__SpeakingSetClient<$Result.GetResult<Prisma.$SpeakingSetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SpeakingSet.
     * @param {SpeakingSetUpdateArgs} args - Arguments to update one SpeakingSet.
     * @example
     * // Update one SpeakingSet
     * const speakingSet = await prisma.speakingSet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpeakingSetUpdateArgs>(args: SelectSubset<T, SpeakingSetUpdateArgs<ExtArgs>>): Prisma__SpeakingSetClient<$Result.GetResult<Prisma.$SpeakingSetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpeakingSets.
     * @param {SpeakingSetDeleteManyArgs} args - Arguments to filter SpeakingSets to delete.
     * @example
     * // Delete a few SpeakingSets
     * const { count } = await prisma.speakingSet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpeakingSetDeleteManyArgs>(args?: SelectSubset<T, SpeakingSetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpeakingSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingSetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpeakingSets
     * const speakingSet = await prisma.speakingSet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpeakingSetUpdateManyArgs>(args: SelectSubset<T, SpeakingSetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpeakingSet.
     * @param {SpeakingSetUpsertArgs} args - Arguments to update or create a SpeakingSet.
     * @example
     * // Update or create a SpeakingSet
     * const speakingSet = await prisma.speakingSet.upsert({
     *   create: {
     *     // ... data to create a SpeakingSet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpeakingSet we want to update
     *   }
     * })
     */
    upsert<T extends SpeakingSetUpsertArgs>(args: SelectSubset<T, SpeakingSetUpsertArgs<ExtArgs>>): Prisma__SpeakingSetClient<$Result.GetResult<Prisma.$SpeakingSetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SpeakingSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingSetCountArgs} args - Arguments to filter SpeakingSets to count.
     * @example
     * // Count the number of SpeakingSets
     * const count = await prisma.speakingSet.count({
     *   where: {
     *     // ... the filter for the SpeakingSets we want to count
     *   }
     * })
    **/
    count<T extends SpeakingSetCountArgs>(
      args?: Subset<T, SpeakingSetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeakingSetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpeakingSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingSetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeakingSetAggregateArgs>(args: Subset<T, SpeakingSetAggregateArgs>): Prisma.PrismaPromise<GetSpeakingSetAggregateType<T>>

    /**
     * Group by SpeakingSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingSetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpeakingSetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeakingSetGroupByArgs['orderBy'] }
        : { orderBy?: SpeakingSetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpeakingSetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeakingSetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpeakingSet model
   */
  readonly fields: SpeakingSetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpeakingSet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpeakingSetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prompts<T extends SpeakingSet$promptsArgs<ExtArgs> = {}>(args?: Subset<T, SpeakingSet$promptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakingPromptPayload<ExtArgs>, T, "findMany"> | Null>
    attempts<T extends SpeakingSet$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, SpeakingSet$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpeakingSet model
   */ 
  interface SpeakingSetFieldRefs {
    readonly id: FieldRef<"SpeakingSet", 'Int'>
    readonly createdAt: FieldRef<"SpeakingSet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpeakingSet findUnique
   */
  export type SpeakingSetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSet
     */
    select?: SpeakingSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSetInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingSet to fetch.
     */
    where: SpeakingSetWhereUniqueInput
  }

  /**
   * SpeakingSet findUniqueOrThrow
   */
  export type SpeakingSetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSet
     */
    select?: SpeakingSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSetInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingSet to fetch.
     */
    where: SpeakingSetWhereUniqueInput
  }

  /**
   * SpeakingSet findFirst
   */
  export type SpeakingSetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSet
     */
    select?: SpeakingSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSetInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingSet to fetch.
     */
    where?: SpeakingSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakingSets to fetch.
     */
    orderBy?: SpeakingSetOrderByWithRelationInput | SpeakingSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeakingSets.
     */
    cursor?: SpeakingSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakingSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakingSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeakingSets.
     */
    distinct?: SpeakingSetScalarFieldEnum | SpeakingSetScalarFieldEnum[]
  }

  /**
   * SpeakingSet findFirstOrThrow
   */
  export type SpeakingSetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSet
     */
    select?: SpeakingSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSetInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingSet to fetch.
     */
    where?: SpeakingSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakingSets to fetch.
     */
    orderBy?: SpeakingSetOrderByWithRelationInput | SpeakingSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeakingSets.
     */
    cursor?: SpeakingSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakingSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakingSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeakingSets.
     */
    distinct?: SpeakingSetScalarFieldEnum | SpeakingSetScalarFieldEnum[]
  }

  /**
   * SpeakingSet findMany
   */
  export type SpeakingSetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSet
     */
    select?: SpeakingSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSetInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingSets to fetch.
     */
    where?: SpeakingSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakingSets to fetch.
     */
    orderBy?: SpeakingSetOrderByWithRelationInput | SpeakingSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpeakingSets.
     */
    cursor?: SpeakingSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakingSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakingSets.
     */
    skip?: number
    distinct?: SpeakingSetScalarFieldEnum | SpeakingSetScalarFieldEnum[]
  }

  /**
   * SpeakingSet create
   */
  export type SpeakingSetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSet
     */
    select?: SpeakingSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSetInclude<ExtArgs> | null
    /**
     * The data needed to create a SpeakingSet.
     */
    data?: XOR<SpeakingSetCreateInput, SpeakingSetUncheckedCreateInput>
  }

  /**
   * SpeakingSet createMany
   */
  export type SpeakingSetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpeakingSets.
     */
    data: SpeakingSetCreateManyInput | SpeakingSetCreateManyInput[]
  }

  /**
   * SpeakingSet createManyAndReturn
   */
  export type SpeakingSetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSet
     */
    select?: SpeakingSetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SpeakingSets.
     */
    data: SpeakingSetCreateManyInput | SpeakingSetCreateManyInput[]
  }

  /**
   * SpeakingSet update
   */
  export type SpeakingSetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSet
     */
    select?: SpeakingSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSetInclude<ExtArgs> | null
    /**
     * The data needed to update a SpeakingSet.
     */
    data: XOR<SpeakingSetUpdateInput, SpeakingSetUncheckedUpdateInput>
    /**
     * Choose, which SpeakingSet to update.
     */
    where: SpeakingSetWhereUniqueInput
  }

  /**
   * SpeakingSet updateMany
   */
  export type SpeakingSetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpeakingSets.
     */
    data: XOR<SpeakingSetUpdateManyMutationInput, SpeakingSetUncheckedUpdateManyInput>
    /**
     * Filter which SpeakingSets to update
     */
    where?: SpeakingSetWhereInput
  }

  /**
   * SpeakingSet upsert
   */
  export type SpeakingSetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSet
     */
    select?: SpeakingSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSetInclude<ExtArgs> | null
    /**
     * The filter to search for the SpeakingSet to update in case it exists.
     */
    where: SpeakingSetWhereUniqueInput
    /**
     * In case the SpeakingSet found by the `where` argument doesn't exist, create a new SpeakingSet with this data.
     */
    create: XOR<SpeakingSetCreateInput, SpeakingSetUncheckedCreateInput>
    /**
     * In case the SpeakingSet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpeakingSetUpdateInput, SpeakingSetUncheckedUpdateInput>
  }

  /**
   * SpeakingSet delete
   */
  export type SpeakingSetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSet
     */
    select?: SpeakingSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSetInclude<ExtArgs> | null
    /**
     * Filter which SpeakingSet to delete.
     */
    where: SpeakingSetWhereUniqueInput
  }

  /**
   * SpeakingSet deleteMany
   */
  export type SpeakingSetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeakingSets to delete
     */
    where?: SpeakingSetWhereInput
  }

  /**
   * SpeakingSet.prompts
   */
  export type SpeakingSet$promptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingPrompt
     */
    select?: SpeakingPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingPromptInclude<ExtArgs> | null
    where?: SpeakingPromptWhereInput
    orderBy?: SpeakingPromptOrderByWithRelationInput | SpeakingPromptOrderByWithRelationInput[]
    cursor?: SpeakingPromptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpeakingPromptScalarFieldEnum | SpeakingPromptScalarFieldEnum[]
  }

  /**
   * SpeakingSet.attempts
   */
  export type SpeakingSet$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    where?: ExamAttemptWhereInput
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    cursor?: ExamAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * SpeakingSet without action
   */
  export type SpeakingSetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSet
     */
    select?: SpeakingSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSetInclude<ExtArgs> | null
  }


  /**
   * Model SpeakingPrompt
   */

  export type AggregateSpeakingPrompt = {
    _count: SpeakingPromptCountAggregateOutputType | null
    _avg: SpeakingPromptAvgAggregateOutputType | null
    _sum: SpeakingPromptSumAggregateOutputType | null
    _min: SpeakingPromptMinAggregateOutputType | null
    _max: SpeakingPromptMaxAggregateOutputType | null
  }

  export type SpeakingPromptAvgAggregateOutputType = {
    id: number | null
    setId: number | null
  }

  export type SpeakingPromptSumAggregateOutputType = {
    id: number | null
    setId: number | null
  }

  export type SpeakingPromptMinAggregateOutputType = {
    id: number | null
    setId: number | null
    text: string | null
  }

  export type SpeakingPromptMaxAggregateOutputType = {
    id: number | null
    setId: number | null
    text: string | null
  }

  export type SpeakingPromptCountAggregateOutputType = {
    id: number
    setId: number
    text: number
    _all: number
  }


  export type SpeakingPromptAvgAggregateInputType = {
    id?: true
    setId?: true
  }

  export type SpeakingPromptSumAggregateInputType = {
    id?: true
    setId?: true
  }

  export type SpeakingPromptMinAggregateInputType = {
    id?: true
    setId?: true
    text?: true
  }

  export type SpeakingPromptMaxAggregateInputType = {
    id?: true
    setId?: true
    text?: true
  }

  export type SpeakingPromptCountAggregateInputType = {
    id?: true
    setId?: true
    text?: true
    _all?: true
  }

  export type SpeakingPromptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeakingPrompt to aggregate.
     */
    where?: SpeakingPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakingPrompts to fetch.
     */
    orderBy?: SpeakingPromptOrderByWithRelationInput | SpeakingPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpeakingPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakingPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakingPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpeakingPrompts
    **/
    _count?: true | SpeakingPromptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpeakingPromptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpeakingPromptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeakingPromptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeakingPromptMaxAggregateInputType
  }

  export type GetSpeakingPromptAggregateType<T extends SpeakingPromptAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeakingPrompt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeakingPrompt[P]>
      : GetScalarType<T[P], AggregateSpeakingPrompt[P]>
  }




  export type SpeakingPromptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakingPromptWhereInput
    orderBy?: SpeakingPromptOrderByWithAggregationInput | SpeakingPromptOrderByWithAggregationInput[]
    by: SpeakingPromptScalarFieldEnum[] | SpeakingPromptScalarFieldEnum
    having?: SpeakingPromptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeakingPromptCountAggregateInputType | true
    _avg?: SpeakingPromptAvgAggregateInputType
    _sum?: SpeakingPromptSumAggregateInputType
    _min?: SpeakingPromptMinAggregateInputType
    _max?: SpeakingPromptMaxAggregateInputType
  }

  export type SpeakingPromptGroupByOutputType = {
    id: number
    setId: number
    text: string
    _count: SpeakingPromptCountAggregateOutputType | null
    _avg: SpeakingPromptAvgAggregateOutputType | null
    _sum: SpeakingPromptSumAggregateOutputType | null
    _min: SpeakingPromptMinAggregateOutputType | null
    _max: SpeakingPromptMaxAggregateOutputType | null
  }

  type GetSpeakingPromptGroupByPayload<T extends SpeakingPromptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpeakingPromptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeakingPromptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeakingPromptGroupByOutputType[P]>
            : GetScalarType<T[P], SpeakingPromptGroupByOutputType[P]>
        }
      >
    >


  export type SpeakingPromptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    setId?: boolean
    text?: boolean
    set?: boolean | SpeakingSetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speakingPrompt"]>

  export type SpeakingPromptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    setId?: boolean
    text?: boolean
    set?: boolean | SpeakingSetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speakingPrompt"]>

  export type SpeakingPromptSelectScalar = {
    id?: boolean
    setId?: boolean
    text?: boolean
  }

  export type SpeakingPromptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    set?: boolean | SpeakingSetDefaultArgs<ExtArgs>
  }
  export type SpeakingPromptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    set?: boolean | SpeakingSetDefaultArgs<ExtArgs>
  }

  export type $SpeakingPromptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpeakingPrompt"
    objects: {
      set: Prisma.$SpeakingSetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      setId: number
      text: string
    }, ExtArgs["result"]["speakingPrompt"]>
    composites: {}
  }

  type SpeakingPromptGetPayload<S extends boolean | null | undefined | SpeakingPromptDefaultArgs> = $Result.GetResult<Prisma.$SpeakingPromptPayload, S>

  type SpeakingPromptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpeakingPromptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpeakingPromptCountAggregateInputType | true
    }

  export interface SpeakingPromptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpeakingPrompt'], meta: { name: 'SpeakingPrompt' } }
    /**
     * Find zero or one SpeakingPrompt that matches the filter.
     * @param {SpeakingPromptFindUniqueArgs} args - Arguments to find a SpeakingPrompt
     * @example
     * // Get one SpeakingPrompt
     * const speakingPrompt = await prisma.speakingPrompt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpeakingPromptFindUniqueArgs>(args: SelectSubset<T, SpeakingPromptFindUniqueArgs<ExtArgs>>): Prisma__SpeakingPromptClient<$Result.GetResult<Prisma.$SpeakingPromptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SpeakingPrompt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpeakingPromptFindUniqueOrThrowArgs} args - Arguments to find a SpeakingPrompt
     * @example
     * // Get one SpeakingPrompt
     * const speakingPrompt = await prisma.speakingPrompt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpeakingPromptFindUniqueOrThrowArgs>(args: SelectSubset<T, SpeakingPromptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpeakingPromptClient<$Result.GetResult<Prisma.$SpeakingPromptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SpeakingPrompt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingPromptFindFirstArgs} args - Arguments to find a SpeakingPrompt
     * @example
     * // Get one SpeakingPrompt
     * const speakingPrompt = await prisma.speakingPrompt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpeakingPromptFindFirstArgs>(args?: SelectSubset<T, SpeakingPromptFindFirstArgs<ExtArgs>>): Prisma__SpeakingPromptClient<$Result.GetResult<Prisma.$SpeakingPromptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SpeakingPrompt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingPromptFindFirstOrThrowArgs} args - Arguments to find a SpeakingPrompt
     * @example
     * // Get one SpeakingPrompt
     * const speakingPrompt = await prisma.speakingPrompt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpeakingPromptFindFirstOrThrowArgs>(args?: SelectSubset<T, SpeakingPromptFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpeakingPromptClient<$Result.GetResult<Prisma.$SpeakingPromptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpeakingPrompts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingPromptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpeakingPrompts
     * const speakingPrompts = await prisma.speakingPrompt.findMany()
     * 
     * // Get first 10 SpeakingPrompts
     * const speakingPrompts = await prisma.speakingPrompt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speakingPromptWithIdOnly = await prisma.speakingPrompt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpeakingPromptFindManyArgs>(args?: SelectSubset<T, SpeakingPromptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakingPromptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SpeakingPrompt.
     * @param {SpeakingPromptCreateArgs} args - Arguments to create a SpeakingPrompt.
     * @example
     * // Create one SpeakingPrompt
     * const SpeakingPrompt = await prisma.speakingPrompt.create({
     *   data: {
     *     // ... data to create a SpeakingPrompt
     *   }
     * })
     * 
     */
    create<T extends SpeakingPromptCreateArgs>(args: SelectSubset<T, SpeakingPromptCreateArgs<ExtArgs>>): Prisma__SpeakingPromptClient<$Result.GetResult<Prisma.$SpeakingPromptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpeakingPrompts.
     * @param {SpeakingPromptCreateManyArgs} args - Arguments to create many SpeakingPrompts.
     * @example
     * // Create many SpeakingPrompts
     * const speakingPrompt = await prisma.speakingPrompt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpeakingPromptCreateManyArgs>(args?: SelectSubset<T, SpeakingPromptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpeakingPrompts and returns the data saved in the database.
     * @param {SpeakingPromptCreateManyAndReturnArgs} args - Arguments to create many SpeakingPrompts.
     * @example
     * // Create many SpeakingPrompts
     * const speakingPrompt = await prisma.speakingPrompt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpeakingPrompts and only return the `id`
     * const speakingPromptWithIdOnly = await prisma.speakingPrompt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpeakingPromptCreateManyAndReturnArgs>(args?: SelectSubset<T, SpeakingPromptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakingPromptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SpeakingPrompt.
     * @param {SpeakingPromptDeleteArgs} args - Arguments to delete one SpeakingPrompt.
     * @example
     * // Delete one SpeakingPrompt
     * const SpeakingPrompt = await prisma.speakingPrompt.delete({
     *   where: {
     *     // ... filter to delete one SpeakingPrompt
     *   }
     * })
     * 
     */
    delete<T extends SpeakingPromptDeleteArgs>(args: SelectSubset<T, SpeakingPromptDeleteArgs<ExtArgs>>): Prisma__SpeakingPromptClient<$Result.GetResult<Prisma.$SpeakingPromptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SpeakingPrompt.
     * @param {SpeakingPromptUpdateArgs} args - Arguments to update one SpeakingPrompt.
     * @example
     * // Update one SpeakingPrompt
     * const speakingPrompt = await prisma.speakingPrompt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpeakingPromptUpdateArgs>(args: SelectSubset<T, SpeakingPromptUpdateArgs<ExtArgs>>): Prisma__SpeakingPromptClient<$Result.GetResult<Prisma.$SpeakingPromptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpeakingPrompts.
     * @param {SpeakingPromptDeleteManyArgs} args - Arguments to filter SpeakingPrompts to delete.
     * @example
     * // Delete a few SpeakingPrompts
     * const { count } = await prisma.speakingPrompt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpeakingPromptDeleteManyArgs>(args?: SelectSubset<T, SpeakingPromptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpeakingPrompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingPromptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpeakingPrompts
     * const speakingPrompt = await prisma.speakingPrompt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpeakingPromptUpdateManyArgs>(args: SelectSubset<T, SpeakingPromptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpeakingPrompt.
     * @param {SpeakingPromptUpsertArgs} args - Arguments to update or create a SpeakingPrompt.
     * @example
     * // Update or create a SpeakingPrompt
     * const speakingPrompt = await prisma.speakingPrompt.upsert({
     *   create: {
     *     // ... data to create a SpeakingPrompt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpeakingPrompt we want to update
     *   }
     * })
     */
    upsert<T extends SpeakingPromptUpsertArgs>(args: SelectSubset<T, SpeakingPromptUpsertArgs<ExtArgs>>): Prisma__SpeakingPromptClient<$Result.GetResult<Prisma.$SpeakingPromptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SpeakingPrompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingPromptCountArgs} args - Arguments to filter SpeakingPrompts to count.
     * @example
     * // Count the number of SpeakingPrompts
     * const count = await prisma.speakingPrompt.count({
     *   where: {
     *     // ... the filter for the SpeakingPrompts we want to count
     *   }
     * })
    **/
    count<T extends SpeakingPromptCountArgs>(
      args?: Subset<T, SpeakingPromptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeakingPromptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpeakingPrompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingPromptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeakingPromptAggregateArgs>(args: Subset<T, SpeakingPromptAggregateArgs>): Prisma.PrismaPromise<GetSpeakingPromptAggregateType<T>>

    /**
     * Group by SpeakingPrompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingPromptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpeakingPromptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeakingPromptGroupByArgs['orderBy'] }
        : { orderBy?: SpeakingPromptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpeakingPromptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeakingPromptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpeakingPrompt model
   */
  readonly fields: SpeakingPromptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpeakingPrompt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpeakingPromptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    set<T extends SpeakingSetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpeakingSetDefaultArgs<ExtArgs>>): Prisma__SpeakingSetClient<$Result.GetResult<Prisma.$SpeakingSetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpeakingPrompt model
   */ 
  interface SpeakingPromptFieldRefs {
    readonly id: FieldRef<"SpeakingPrompt", 'Int'>
    readonly setId: FieldRef<"SpeakingPrompt", 'Int'>
    readonly text: FieldRef<"SpeakingPrompt", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SpeakingPrompt findUnique
   */
  export type SpeakingPromptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingPrompt
     */
    select?: SpeakingPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingPromptInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingPrompt to fetch.
     */
    where: SpeakingPromptWhereUniqueInput
  }

  /**
   * SpeakingPrompt findUniqueOrThrow
   */
  export type SpeakingPromptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingPrompt
     */
    select?: SpeakingPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingPromptInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingPrompt to fetch.
     */
    where: SpeakingPromptWhereUniqueInput
  }

  /**
   * SpeakingPrompt findFirst
   */
  export type SpeakingPromptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingPrompt
     */
    select?: SpeakingPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingPromptInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingPrompt to fetch.
     */
    where?: SpeakingPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakingPrompts to fetch.
     */
    orderBy?: SpeakingPromptOrderByWithRelationInput | SpeakingPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeakingPrompts.
     */
    cursor?: SpeakingPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakingPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakingPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeakingPrompts.
     */
    distinct?: SpeakingPromptScalarFieldEnum | SpeakingPromptScalarFieldEnum[]
  }

  /**
   * SpeakingPrompt findFirstOrThrow
   */
  export type SpeakingPromptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingPrompt
     */
    select?: SpeakingPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingPromptInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingPrompt to fetch.
     */
    where?: SpeakingPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakingPrompts to fetch.
     */
    orderBy?: SpeakingPromptOrderByWithRelationInput | SpeakingPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeakingPrompts.
     */
    cursor?: SpeakingPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakingPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakingPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeakingPrompts.
     */
    distinct?: SpeakingPromptScalarFieldEnum | SpeakingPromptScalarFieldEnum[]
  }

  /**
   * SpeakingPrompt findMany
   */
  export type SpeakingPromptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingPrompt
     */
    select?: SpeakingPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingPromptInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingPrompts to fetch.
     */
    where?: SpeakingPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakingPrompts to fetch.
     */
    orderBy?: SpeakingPromptOrderByWithRelationInput | SpeakingPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpeakingPrompts.
     */
    cursor?: SpeakingPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakingPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakingPrompts.
     */
    skip?: number
    distinct?: SpeakingPromptScalarFieldEnum | SpeakingPromptScalarFieldEnum[]
  }

  /**
   * SpeakingPrompt create
   */
  export type SpeakingPromptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingPrompt
     */
    select?: SpeakingPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingPromptInclude<ExtArgs> | null
    /**
     * The data needed to create a SpeakingPrompt.
     */
    data: XOR<SpeakingPromptCreateInput, SpeakingPromptUncheckedCreateInput>
  }

  /**
   * SpeakingPrompt createMany
   */
  export type SpeakingPromptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpeakingPrompts.
     */
    data: SpeakingPromptCreateManyInput | SpeakingPromptCreateManyInput[]
  }

  /**
   * SpeakingPrompt createManyAndReturn
   */
  export type SpeakingPromptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingPrompt
     */
    select?: SpeakingPromptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SpeakingPrompts.
     */
    data: SpeakingPromptCreateManyInput | SpeakingPromptCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingPromptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpeakingPrompt update
   */
  export type SpeakingPromptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingPrompt
     */
    select?: SpeakingPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingPromptInclude<ExtArgs> | null
    /**
     * The data needed to update a SpeakingPrompt.
     */
    data: XOR<SpeakingPromptUpdateInput, SpeakingPromptUncheckedUpdateInput>
    /**
     * Choose, which SpeakingPrompt to update.
     */
    where: SpeakingPromptWhereUniqueInput
  }

  /**
   * SpeakingPrompt updateMany
   */
  export type SpeakingPromptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpeakingPrompts.
     */
    data: XOR<SpeakingPromptUpdateManyMutationInput, SpeakingPromptUncheckedUpdateManyInput>
    /**
     * Filter which SpeakingPrompts to update
     */
    where?: SpeakingPromptWhereInput
  }

  /**
   * SpeakingPrompt upsert
   */
  export type SpeakingPromptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingPrompt
     */
    select?: SpeakingPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingPromptInclude<ExtArgs> | null
    /**
     * The filter to search for the SpeakingPrompt to update in case it exists.
     */
    where: SpeakingPromptWhereUniqueInput
    /**
     * In case the SpeakingPrompt found by the `where` argument doesn't exist, create a new SpeakingPrompt with this data.
     */
    create: XOR<SpeakingPromptCreateInput, SpeakingPromptUncheckedCreateInput>
    /**
     * In case the SpeakingPrompt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpeakingPromptUpdateInput, SpeakingPromptUncheckedUpdateInput>
  }

  /**
   * SpeakingPrompt delete
   */
  export type SpeakingPromptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingPrompt
     */
    select?: SpeakingPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingPromptInclude<ExtArgs> | null
    /**
     * Filter which SpeakingPrompt to delete.
     */
    where: SpeakingPromptWhereUniqueInput
  }

  /**
   * SpeakingPrompt deleteMany
   */
  export type SpeakingPromptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeakingPrompts to delete
     */
    where?: SpeakingPromptWhereInput
  }

  /**
   * SpeakingPrompt without action
   */
  export type SpeakingPromptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingPrompt
     */
    select?: SpeakingPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingPromptInclude<ExtArgs> | null
  }


  /**
   * Model CheatingEvent
   */

  export type AggregateCheatingEvent = {
    _count: CheatingEventCountAggregateOutputType | null
    _avg: CheatingEventAvgAggregateOutputType | null
    _sum: CheatingEventSumAggregateOutputType | null
    _min: CheatingEventMinAggregateOutputType | null
    _max: CheatingEventMaxAggregateOutputType | null
  }

  export type CheatingEventAvgAggregateOutputType = {
    id: number | null
    attemptId: number | null
  }

  export type CheatingEventSumAggregateOutputType = {
    id: number | null
    attemptId: number | null
  }

  export type CheatingEventMinAggregateOutputType = {
    id: number | null
    attemptId: number | null
    type: string | null
    details: string | null
    createdAt: Date | null
  }

  export type CheatingEventMaxAggregateOutputType = {
    id: number | null
    attemptId: number | null
    type: string | null
    details: string | null
    createdAt: Date | null
  }

  export type CheatingEventCountAggregateOutputType = {
    id: number
    attemptId: number
    type: number
    details: number
    createdAt: number
    _all: number
  }


  export type CheatingEventAvgAggregateInputType = {
    id?: true
    attemptId?: true
  }

  export type CheatingEventSumAggregateInputType = {
    id?: true
    attemptId?: true
  }

  export type CheatingEventMinAggregateInputType = {
    id?: true
    attemptId?: true
    type?: true
    details?: true
    createdAt?: true
  }

  export type CheatingEventMaxAggregateInputType = {
    id?: true
    attemptId?: true
    type?: true
    details?: true
    createdAt?: true
  }

  export type CheatingEventCountAggregateInputType = {
    id?: true
    attemptId?: true
    type?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type CheatingEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheatingEvent to aggregate.
     */
    where?: CheatingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheatingEvents to fetch.
     */
    orderBy?: CheatingEventOrderByWithRelationInput | CheatingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheatingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheatingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheatingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CheatingEvents
    **/
    _count?: true | CheatingEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CheatingEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CheatingEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheatingEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheatingEventMaxAggregateInputType
  }

  export type GetCheatingEventAggregateType<T extends CheatingEventAggregateArgs> = {
        [P in keyof T & keyof AggregateCheatingEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheatingEvent[P]>
      : GetScalarType<T[P], AggregateCheatingEvent[P]>
  }




  export type CheatingEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheatingEventWhereInput
    orderBy?: CheatingEventOrderByWithAggregationInput | CheatingEventOrderByWithAggregationInput[]
    by: CheatingEventScalarFieldEnum[] | CheatingEventScalarFieldEnum
    having?: CheatingEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheatingEventCountAggregateInputType | true
    _avg?: CheatingEventAvgAggregateInputType
    _sum?: CheatingEventSumAggregateInputType
    _min?: CheatingEventMinAggregateInputType
    _max?: CheatingEventMaxAggregateInputType
  }

  export type CheatingEventGroupByOutputType = {
    id: number
    attemptId: number
    type: string
    details: string | null
    createdAt: Date
    _count: CheatingEventCountAggregateOutputType | null
    _avg: CheatingEventAvgAggregateOutputType | null
    _sum: CheatingEventSumAggregateOutputType | null
    _min: CheatingEventMinAggregateOutputType | null
    _max: CheatingEventMaxAggregateOutputType | null
  }

  type GetCheatingEventGroupByPayload<T extends CheatingEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheatingEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheatingEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheatingEventGroupByOutputType[P]>
            : GetScalarType<T[P], CheatingEventGroupByOutputType[P]>
        }
      >
    >


  export type CheatingEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    type?: boolean
    details?: boolean
    createdAt?: boolean
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cheatingEvent"]>

  export type CheatingEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    type?: boolean
    details?: boolean
    createdAt?: boolean
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cheatingEvent"]>

  export type CheatingEventSelectScalar = {
    id?: boolean
    attemptId?: boolean
    type?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type CheatingEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
  }
  export type CheatingEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
  }

  export type $CheatingEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CheatingEvent"
    objects: {
      attempt: Prisma.$ExamAttemptPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      attemptId: number
      type: string
      details: string | null
      createdAt: Date
    }, ExtArgs["result"]["cheatingEvent"]>
    composites: {}
  }

  type CheatingEventGetPayload<S extends boolean | null | undefined | CheatingEventDefaultArgs> = $Result.GetResult<Prisma.$CheatingEventPayload, S>

  type CheatingEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CheatingEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CheatingEventCountAggregateInputType | true
    }

  export interface CheatingEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CheatingEvent'], meta: { name: 'CheatingEvent' } }
    /**
     * Find zero or one CheatingEvent that matches the filter.
     * @param {CheatingEventFindUniqueArgs} args - Arguments to find a CheatingEvent
     * @example
     * // Get one CheatingEvent
     * const cheatingEvent = await prisma.cheatingEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CheatingEventFindUniqueArgs>(args: SelectSubset<T, CheatingEventFindUniqueArgs<ExtArgs>>): Prisma__CheatingEventClient<$Result.GetResult<Prisma.$CheatingEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CheatingEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CheatingEventFindUniqueOrThrowArgs} args - Arguments to find a CheatingEvent
     * @example
     * // Get one CheatingEvent
     * const cheatingEvent = await prisma.cheatingEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CheatingEventFindUniqueOrThrowArgs>(args: SelectSubset<T, CheatingEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CheatingEventClient<$Result.GetResult<Prisma.$CheatingEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CheatingEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatingEventFindFirstArgs} args - Arguments to find a CheatingEvent
     * @example
     * // Get one CheatingEvent
     * const cheatingEvent = await prisma.cheatingEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CheatingEventFindFirstArgs>(args?: SelectSubset<T, CheatingEventFindFirstArgs<ExtArgs>>): Prisma__CheatingEventClient<$Result.GetResult<Prisma.$CheatingEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CheatingEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatingEventFindFirstOrThrowArgs} args - Arguments to find a CheatingEvent
     * @example
     * // Get one CheatingEvent
     * const cheatingEvent = await prisma.cheatingEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CheatingEventFindFirstOrThrowArgs>(args?: SelectSubset<T, CheatingEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__CheatingEventClient<$Result.GetResult<Prisma.$CheatingEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CheatingEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatingEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CheatingEvents
     * const cheatingEvents = await prisma.cheatingEvent.findMany()
     * 
     * // Get first 10 CheatingEvents
     * const cheatingEvents = await prisma.cheatingEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cheatingEventWithIdOnly = await prisma.cheatingEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CheatingEventFindManyArgs>(args?: SelectSubset<T, CheatingEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheatingEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CheatingEvent.
     * @param {CheatingEventCreateArgs} args - Arguments to create a CheatingEvent.
     * @example
     * // Create one CheatingEvent
     * const CheatingEvent = await prisma.cheatingEvent.create({
     *   data: {
     *     // ... data to create a CheatingEvent
     *   }
     * })
     * 
     */
    create<T extends CheatingEventCreateArgs>(args: SelectSubset<T, CheatingEventCreateArgs<ExtArgs>>): Prisma__CheatingEventClient<$Result.GetResult<Prisma.$CheatingEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CheatingEvents.
     * @param {CheatingEventCreateManyArgs} args - Arguments to create many CheatingEvents.
     * @example
     * // Create many CheatingEvents
     * const cheatingEvent = await prisma.cheatingEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CheatingEventCreateManyArgs>(args?: SelectSubset<T, CheatingEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CheatingEvents and returns the data saved in the database.
     * @param {CheatingEventCreateManyAndReturnArgs} args - Arguments to create many CheatingEvents.
     * @example
     * // Create many CheatingEvents
     * const cheatingEvent = await prisma.cheatingEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CheatingEvents and only return the `id`
     * const cheatingEventWithIdOnly = await prisma.cheatingEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CheatingEventCreateManyAndReturnArgs>(args?: SelectSubset<T, CheatingEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheatingEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CheatingEvent.
     * @param {CheatingEventDeleteArgs} args - Arguments to delete one CheatingEvent.
     * @example
     * // Delete one CheatingEvent
     * const CheatingEvent = await prisma.cheatingEvent.delete({
     *   where: {
     *     // ... filter to delete one CheatingEvent
     *   }
     * })
     * 
     */
    delete<T extends CheatingEventDeleteArgs>(args: SelectSubset<T, CheatingEventDeleteArgs<ExtArgs>>): Prisma__CheatingEventClient<$Result.GetResult<Prisma.$CheatingEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CheatingEvent.
     * @param {CheatingEventUpdateArgs} args - Arguments to update one CheatingEvent.
     * @example
     * // Update one CheatingEvent
     * const cheatingEvent = await prisma.cheatingEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CheatingEventUpdateArgs>(args: SelectSubset<T, CheatingEventUpdateArgs<ExtArgs>>): Prisma__CheatingEventClient<$Result.GetResult<Prisma.$CheatingEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CheatingEvents.
     * @param {CheatingEventDeleteManyArgs} args - Arguments to filter CheatingEvents to delete.
     * @example
     * // Delete a few CheatingEvents
     * const { count } = await prisma.cheatingEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CheatingEventDeleteManyArgs>(args?: SelectSubset<T, CheatingEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheatingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatingEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CheatingEvents
     * const cheatingEvent = await prisma.cheatingEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CheatingEventUpdateManyArgs>(args: SelectSubset<T, CheatingEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CheatingEvent.
     * @param {CheatingEventUpsertArgs} args - Arguments to update or create a CheatingEvent.
     * @example
     * // Update or create a CheatingEvent
     * const cheatingEvent = await prisma.cheatingEvent.upsert({
     *   create: {
     *     // ... data to create a CheatingEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CheatingEvent we want to update
     *   }
     * })
     */
    upsert<T extends CheatingEventUpsertArgs>(args: SelectSubset<T, CheatingEventUpsertArgs<ExtArgs>>): Prisma__CheatingEventClient<$Result.GetResult<Prisma.$CheatingEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CheatingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatingEventCountArgs} args - Arguments to filter CheatingEvents to count.
     * @example
     * // Count the number of CheatingEvents
     * const count = await prisma.cheatingEvent.count({
     *   where: {
     *     // ... the filter for the CheatingEvents we want to count
     *   }
     * })
    **/
    count<T extends CheatingEventCountArgs>(
      args?: Subset<T, CheatingEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheatingEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CheatingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatingEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheatingEventAggregateArgs>(args: Subset<T, CheatingEventAggregateArgs>): Prisma.PrismaPromise<GetCheatingEventAggregateType<T>>

    /**
     * Group by CheatingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatingEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheatingEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheatingEventGroupByArgs['orderBy'] }
        : { orderBy?: CheatingEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheatingEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheatingEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CheatingEvent model
   */
  readonly fields: CheatingEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CheatingEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheatingEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attempt<T extends ExamAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttemptDefaultArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CheatingEvent model
   */ 
  interface CheatingEventFieldRefs {
    readonly id: FieldRef<"CheatingEvent", 'Int'>
    readonly attemptId: FieldRef<"CheatingEvent", 'Int'>
    readonly type: FieldRef<"CheatingEvent", 'String'>
    readonly details: FieldRef<"CheatingEvent", 'String'>
    readonly createdAt: FieldRef<"CheatingEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CheatingEvent findUnique
   */
  export type CheatingEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatingEvent
     */
    select?: CheatingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatingEventInclude<ExtArgs> | null
    /**
     * Filter, which CheatingEvent to fetch.
     */
    where: CheatingEventWhereUniqueInput
  }

  /**
   * CheatingEvent findUniqueOrThrow
   */
  export type CheatingEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatingEvent
     */
    select?: CheatingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatingEventInclude<ExtArgs> | null
    /**
     * Filter, which CheatingEvent to fetch.
     */
    where: CheatingEventWhereUniqueInput
  }

  /**
   * CheatingEvent findFirst
   */
  export type CheatingEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatingEvent
     */
    select?: CheatingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatingEventInclude<ExtArgs> | null
    /**
     * Filter, which CheatingEvent to fetch.
     */
    where?: CheatingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheatingEvents to fetch.
     */
    orderBy?: CheatingEventOrderByWithRelationInput | CheatingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheatingEvents.
     */
    cursor?: CheatingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheatingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheatingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheatingEvents.
     */
    distinct?: CheatingEventScalarFieldEnum | CheatingEventScalarFieldEnum[]
  }

  /**
   * CheatingEvent findFirstOrThrow
   */
  export type CheatingEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatingEvent
     */
    select?: CheatingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatingEventInclude<ExtArgs> | null
    /**
     * Filter, which CheatingEvent to fetch.
     */
    where?: CheatingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheatingEvents to fetch.
     */
    orderBy?: CheatingEventOrderByWithRelationInput | CheatingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheatingEvents.
     */
    cursor?: CheatingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheatingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheatingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheatingEvents.
     */
    distinct?: CheatingEventScalarFieldEnum | CheatingEventScalarFieldEnum[]
  }

  /**
   * CheatingEvent findMany
   */
  export type CheatingEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatingEvent
     */
    select?: CheatingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatingEventInclude<ExtArgs> | null
    /**
     * Filter, which CheatingEvents to fetch.
     */
    where?: CheatingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheatingEvents to fetch.
     */
    orderBy?: CheatingEventOrderByWithRelationInput | CheatingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CheatingEvents.
     */
    cursor?: CheatingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheatingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheatingEvents.
     */
    skip?: number
    distinct?: CheatingEventScalarFieldEnum | CheatingEventScalarFieldEnum[]
  }

  /**
   * CheatingEvent create
   */
  export type CheatingEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatingEvent
     */
    select?: CheatingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatingEventInclude<ExtArgs> | null
    /**
     * The data needed to create a CheatingEvent.
     */
    data: XOR<CheatingEventCreateInput, CheatingEventUncheckedCreateInput>
  }

  /**
   * CheatingEvent createMany
   */
  export type CheatingEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CheatingEvents.
     */
    data: CheatingEventCreateManyInput | CheatingEventCreateManyInput[]
  }

  /**
   * CheatingEvent createManyAndReturn
   */
  export type CheatingEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatingEvent
     */
    select?: CheatingEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CheatingEvents.
     */
    data: CheatingEventCreateManyInput | CheatingEventCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatingEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CheatingEvent update
   */
  export type CheatingEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatingEvent
     */
    select?: CheatingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatingEventInclude<ExtArgs> | null
    /**
     * The data needed to update a CheatingEvent.
     */
    data: XOR<CheatingEventUpdateInput, CheatingEventUncheckedUpdateInput>
    /**
     * Choose, which CheatingEvent to update.
     */
    where: CheatingEventWhereUniqueInput
  }

  /**
   * CheatingEvent updateMany
   */
  export type CheatingEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CheatingEvents.
     */
    data: XOR<CheatingEventUpdateManyMutationInput, CheatingEventUncheckedUpdateManyInput>
    /**
     * Filter which CheatingEvents to update
     */
    where?: CheatingEventWhereInput
  }

  /**
   * CheatingEvent upsert
   */
  export type CheatingEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatingEvent
     */
    select?: CheatingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatingEventInclude<ExtArgs> | null
    /**
     * The filter to search for the CheatingEvent to update in case it exists.
     */
    where: CheatingEventWhereUniqueInput
    /**
     * In case the CheatingEvent found by the `where` argument doesn't exist, create a new CheatingEvent with this data.
     */
    create: XOR<CheatingEventCreateInput, CheatingEventUncheckedCreateInput>
    /**
     * In case the CheatingEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheatingEventUpdateInput, CheatingEventUncheckedUpdateInput>
  }

  /**
   * CheatingEvent delete
   */
  export type CheatingEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatingEvent
     */
    select?: CheatingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatingEventInclude<ExtArgs> | null
    /**
     * Filter which CheatingEvent to delete.
     */
    where: CheatingEventWhereUniqueInput
  }

  /**
   * CheatingEvent deleteMany
   */
  export type CheatingEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheatingEvents to delete
     */
    where?: CheatingEventWhereInput
  }

  /**
   * CheatingEvent without action
   */
  export type CheatingEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatingEvent
     */
    select?: CheatingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatingEventInclude<ExtArgs> | null
  }


  /**
   * Model AudioResponse
   */

  export type AggregateAudioResponse = {
    _count: AudioResponseCountAggregateOutputType | null
    _avg: AudioResponseAvgAggregateOutputType | null
    _sum: AudioResponseSumAggregateOutputType | null
    _min: AudioResponseMinAggregateOutputType | null
    _max: AudioResponseMaxAggregateOutputType | null
  }

  export type AudioResponseAvgAggregateOutputType = {
    id: number | null
    attemptId: number | null
    promptIndex: number | null
    durationMs: number | null
    asrConfidence: number | null
  }

  export type AudioResponseSumAggregateOutputType = {
    id: number | null
    attemptId: number | null
    promptIndex: number | null
    durationMs: number | null
    asrConfidence: number | null
  }

  export type AudioResponseMinAggregateOutputType = {
    id: number | null
    attemptId: number | null
    promptIndex: number | null
    storageUrl: string | null
    mimeType: string | null
    durationMs: number | null
    asrText: string | null
    asrConfidence: number | null
    createdAt: Date | null
  }

  export type AudioResponseMaxAggregateOutputType = {
    id: number | null
    attemptId: number | null
    promptIndex: number | null
    storageUrl: string | null
    mimeType: string | null
    durationMs: number | null
    asrText: string | null
    asrConfidence: number | null
    createdAt: Date | null
  }

  export type AudioResponseCountAggregateOutputType = {
    id: number
    attemptId: number
    promptIndex: number
    storageUrl: number
    mimeType: number
    durationMs: number
    asrText: number
    asrConfidence: number
    createdAt: number
    _all: number
  }


  export type AudioResponseAvgAggregateInputType = {
    id?: true
    attemptId?: true
    promptIndex?: true
    durationMs?: true
    asrConfidence?: true
  }

  export type AudioResponseSumAggregateInputType = {
    id?: true
    attemptId?: true
    promptIndex?: true
    durationMs?: true
    asrConfidence?: true
  }

  export type AudioResponseMinAggregateInputType = {
    id?: true
    attemptId?: true
    promptIndex?: true
    storageUrl?: true
    mimeType?: true
    durationMs?: true
    asrText?: true
    asrConfidence?: true
    createdAt?: true
  }

  export type AudioResponseMaxAggregateInputType = {
    id?: true
    attemptId?: true
    promptIndex?: true
    storageUrl?: true
    mimeType?: true
    durationMs?: true
    asrText?: true
    asrConfidence?: true
    createdAt?: true
  }

  export type AudioResponseCountAggregateInputType = {
    id?: true
    attemptId?: true
    promptIndex?: true
    storageUrl?: true
    mimeType?: true
    durationMs?: true
    asrText?: true
    asrConfidence?: true
    createdAt?: true
    _all?: true
  }

  export type AudioResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioResponse to aggregate.
     */
    where?: AudioResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioResponses to fetch.
     */
    orderBy?: AudioResponseOrderByWithRelationInput | AudioResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioResponses
    **/
    _count?: true | AudioResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AudioResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AudioResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioResponseMaxAggregateInputType
  }

  export type GetAudioResponseAggregateType<T extends AudioResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioResponse[P]>
      : GetScalarType<T[P], AggregateAudioResponse[P]>
  }




  export type AudioResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioResponseWhereInput
    orderBy?: AudioResponseOrderByWithAggregationInput | AudioResponseOrderByWithAggregationInput[]
    by: AudioResponseScalarFieldEnum[] | AudioResponseScalarFieldEnum
    having?: AudioResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioResponseCountAggregateInputType | true
    _avg?: AudioResponseAvgAggregateInputType
    _sum?: AudioResponseSumAggregateInputType
    _min?: AudioResponseMinAggregateInputType
    _max?: AudioResponseMaxAggregateInputType
  }

  export type AudioResponseGroupByOutputType = {
    id: number
    attemptId: number
    promptIndex: number
    storageUrl: string
    mimeType: string | null
    durationMs: number | null
    asrText: string | null
    asrConfidence: number | null
    createdAt: Date
    _count: AudioResponseCountAggregateOutputType | null
    _avg: AudioResponseAvgAggregateOutputType | null
    _sum: AudioResponseSumAggregateOutputType | null
    _min: AudioResponseMinAggregateOutputType | null
    _max: AudioResponseMaxAggregateOutputType | null
  }

  type GetAudioResponseGroupByPayload<T extends AudioResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioResponseGroupByOutputType[P]>
            : GetScalarType<T[P], AudioResponseGroupByOutputType[P]>
        }
      >
    >


  export type AudioResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    promptIndex?: boolean
    storageUrl?: boolean
    mimeType?: boolean
    durationMs?: boolean
    asrText?: boolean
    asrConfidence?: boolean
    createdAt?: boolean
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioResponse"]>

  export type AudioResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    promptIndex?: boolean
    storageUrl?: boolean
    mimeType?: boolean
    durationMs?: boolean
    asrText?: boolean
    asrConfidence?: boolean
    createdAt?: boolean
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioResponse"]>

  export type AudioResponseSelectScalar = {
    id?: boolean
    attemptId?: boolean
    promptIndex?: boolean
    storageUrl?: boolean
    mimeType?: boolean
    durationMs?: boolean
    asrText?: boolean
    asrConfidence?: boolean
    createdAt?: boolean
  }

  export type AudioResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
  }
  export type AudioResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
  }

  export type $AudioResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioResponse"
    objects: {
      attempt: Prisma.$ExamAttemptPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      attemptId: number
      promptIndex: number
      storageUrl: string
      mimeType: string | null
      durationMs: number | null
      asrText: string | null
      asrConfidence: number | null
      createdAt: Date
    }, ExtArgs["result"]["audioResponse"]>
    composites: {}
  }

  type AudioResponseGetPayload<S extends boolean | null | undefined | AudioResponseDefaultArgs> = $Result.GetResult<Prisma.$AudioResponsePayload, S>

  type AudioResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AudioResponseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AudioResponseCountAggregateInputType | true
    }

  export interface AudioResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioResponse'], meta: { name: 'AudioResponse' } }
    /**
     * Find zero or one AudioResponse that matches the filter.
     * @param {AudioResponseFindUniqueArgs} args - Arguments to find a AudioResponse
     * @example
     * // Get one AudioResponse
     * const audioResponse = await prisma.audioResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioResponseFindUniqueArgs>(args: SelectSubset<T, AudioResponseFindUniqueArgs<ExtArgs>>): Prisma__AudioResponseClient<$Result.GetResult<Prisma.$AudioResponsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AudioResponse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AudioResponseFindUniqueOrThrowArgs} args - Arguments to find a AudioResponse
     * @example
     * // Get one AudioResponse
     * const audioResponse = await prisma.audioResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioResponseClient<$Result.GetResult<Prisma.$AudioResponsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AudioResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioResponseFindFirstArgs} args - Arguments to find a AudioResponse
     * @example
     * // Get one AudioResponse
     * const audioResponse = await prisma.audioResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioResponseFindFirstArgs>(args?: SelectSubset<T, AudioResponseFindFirstArgs<ExtArgs>>): Prisma__AudioResponseClient<$Result.GetResult<Prisma.$AudioResponsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AudioResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioResponseFindFirstOrThrowArgs} args - Arguments to find a AudioResponse
     * @example
     * // Get one AudioResponse
     * const audioResponse = await prisma.audioResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioResponseClient<$Result.GetResult<Prisma.$AudioResponsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AudioResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioResponses
     * const audioResponses = await prisma.audioResponse.findMany()
     * 
     * // Get first 10 AudioResponses
     * const audioResponses = await prisma.audioResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioResponseWithIdOnly = await prisma.audioResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioResponseFindManyArgs>(args?: SelectSubset<T, AudioResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioResponsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AudioResponse.
     * @param {AudioResponseCreateArgs} args - Arguments to create a AudioResponse.
     * @example
     * // Create one AudioResponse
     * const AudioResponse = await prisma.audioResponse.create({
     *   data: {
     *     // ... data to create a AudioResponse
     *   }
     * })
     * 
     */
    create<T extends AudioResponseCreateArgs>(args: SelectSubset<T, AudioResponseCreateArgs<ExtArgs>>): Prisma__AudioResponseClient<$Result.GetResult<Prisma.$AudioResponsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AudioResponses.
     * @param {AudioResponseCreateManyArgs} args - Arguments to create many AudioResponses.
     * @example
     * // Create many AudioResponses
     * const audioResponse = await prisma.audioResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioResponseCreateManyArgs>(args?: SelectSubset<T, AudioResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioResponses and returns the data saved in the database.
     * @param {AudioResponseCreateManyAndReturnArgs} args - Arguments to create many AudioResponses.
     * @example
     * // Create many AudioResponses
     * const audioResponse = await prisma.audioResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioResponses and only return the `id`
     * const audioResponseWithIdOnly = await prisma.audioResponse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioResponsePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AudioResponse.
     * @param {AudioResponseDeleteArgs} args - Arguments to delete one AudioResponse.
     * @example
     * // Delete one AudioResponse
     * const AudioResponse = await prisma.audioResponse.delete({
     *   where: {
     *     // ... filter to delete one AudioResponse
     *   }
     * })
     * 
     */
    delete<T extends AudioResponseDeleteArgs>(args: SelectSubset<T, AudioResponseDeleteArgs<ExtArgs>>): Prisma__AudioResponseClient<$Result.GetResult<Prisma.$AudioResponsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AudioResponse.
     * @param {AudioResponseUpdateArgs} args - Arguments to update one AudioResponse.
     * @example
     * // Update one AudioResponse
     * const audioResponse = await prisma.audioResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioResponseUpdateArgs>(args: SelectSubset<T, AudioResponseUpdateArgs<ExtArgs>>): Prisma__AudioResponseClient<$Result.GetResult<Prisma.$AudioResponsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AudioResponses.
     * @param {AudioResponseDeleteManyArgs} args - Arguments to filter AudioResponses to delete.
     * @example
     * // Delete a few AudioResponses
     * const { count } = await prisma.audioResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioResponseDeleteManyArgs>(args?: SelectSubset<T, AudioResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioResponses
     * const audioResponse = await prisma.audioResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioResponseUpdateManyArgs>(args: SelectSubset<T, AudioResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AudioResponse.
     * @param {AudioResponseUpsertArgs} args - Arguments to update or create a AudioResponse.
     * @example
     * // Update or create a AudioResponse
     * const audioResponse = await prisma.audioResponse.upsert({
     *   create: {
     *     // ... data to create a AudioResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioResponse we want to update
     *   }
     * })
     */
    upsert<T extends AudioResponseUpsertArgs>(args: SelectSubset<T, AudioResponseUpsertArgs<ExtArgs>>): Prisma__AudioResponseClient<$Result.GetResult<Prisma.$AudioResponsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AudioResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioResponseCountArgs} args - Arguments to filter AudioResponses to count.
     * @example
     * // Count the number of AudioResponses
     * const count = await prisma.audioResponse.count({
     *   where: {
     *     // ... the filter for the AudioResponses we want to count
     *   }
     * })
    **/
    count<T extends AudioResponseCountArgs>(
      args?: Subset<T, AudioResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioResponseAggregateArgs>(args: Subset<T, AudioResponseAggregateArgs>): Prisma.PrismaPromise<GetAudioResponseAggregateType<T>>

    /**
     * Group by AudioResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioResponseGroupByArgs['orderBy'] }
        : { orderBy?: AudioResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioResponse model
   */
  readonly fields: AudioResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attempt<T extends ExamAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttemptDefaultArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioResponse model
   */ 
  interface AudioResponseFieldRefs {
    readonly id: FieldRef<"AudioResponse", 'Int'>
    readonly attemptId: FieldRef<"AudioResponse", 'Int'>
    readonly promptIndex: FieldRef<"AudioResponse", 'Int'>
    readonly storageUrl: FieldRef<"AudioResponse", 'String'>
    readonly mimeType: FieldRef<"AudioResponse", 'String'>
    readonly durationMs: FieldRef<"AudioResponse", 'Int'>
    readonly asrText: FieldRef<"AudioResponse", 'String'>
    readonly asrConfidence: FieldRef<"AudioResponse", 'Float'>
    readonly createdAt: FieldRef<"AudioResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AudioResponse findUnique
   */
  export type AudioResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioResponse
     */
    select?: AudioResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioResponseInclude<ExtArgs> | null
    /**
     * Filter, which AudioResponse to fetch.
     */
    where: AudioResponseWhereUniqueInput
  }

  /**
   * AudioResponse findUniqueOrThrow
   */
  export type AudioResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioResponse
     */
    select?: AudioResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioResponseInclude<ExtArgs> | null
    /**
     * Filter, which AudioResponse to fetch.
     */
    where: AudioResponseWhereUniqueInput
  }

  /**
   * AudioResponse findFirst
   */
  export type AudioResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioResponse
     */
    select?: AudioResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioResponseInclude<ExtArgs> | null
    /**
     * Filter, which AudioResponse to fetch.
     */
    where?: AudioResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioResponses to fetch.
     */
    orderBy?: AudioResponseOrderByWithRelationInput | AudioResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioResponses.
     */
    cursor?: AudioResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioResponses.
     */
    distinct?: AudioResponseScalarFieldEnum | AudioResponseScalarFieldEnum[]
  }

  /**
   * AudioResponse findFirstOrThrow
   */
  export type AudioResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioResponse
     */
    select?: AudioResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioResponseInclude<ExtArgs> | null
    /**
     * Filter, which AudioResponse to fetch.
     */
    where?: AudioResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioResponses to fetch.
     */
    orderBy?: AudioResponseOrderByWithRelationInput | AudioResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioResponses.
     */
    cursor?: AudioResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioResponses.
     */
    distinct?: AudioResponseScalarFieldEnum | AudioResponseScalarFieldEnum[]
  }

  /**
   * AudioResponse findMany
   */
  export type AudioResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioResponse
     */
    select?: AudioResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioResponseInclude<ExtArgs> | null
    /**
     * Filter, which AudioResponses to fetch.
     */
    where?: AudioResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioResponses to fetch.
     */
    orderBy?: AudioResponseOrderByWithRelationInput | AudioResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioResponses.
     */
    cursor?: AudioResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioResponses.
     */
    skip?: number
    distinct?: AudioResponseScalarFieldEnum | AudioResponseScalarFieldEnum[]
  }

  /**
   * AudioResponse create
   */
  export type AudioResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioResponse
     */
    select?: AudioResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioResponse.
     */
    data: XOR<AudioResponseCreateInput, AudioResponseUncheckedCreateInput>
  }

  /**
   * AudioResponse createMany
   */
  export type AudioResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioResponses.
     */
    data: AudioResponseCreateManyInput | AudioResponseCreateManyInput[]
  }

  /**
   * AudioResponse createManyAndReturn
   */
  export type AudioResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioResponse
     */
    select?: AudioResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AudioResponses.
     */
    data: AudioResponseCreateManyInput | AudioResponseCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioResponse update
   */
  export type AudioResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioResponse
     */
    select?: AudioResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioResponse.
     */
    data: XOR<AudioResponseUpdateInput, AudioResponseUncheckedUpdateInput>
    /**
     * Choose, which AudioResponse to update.
     */
    where: AudioResponseWhereUniqueInput
  }

  /**
   * AudioResponse updateMany
   */
  export type AudioResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioResponses.
     */
    data: XOR<AudioResponseUpdateManyMutationInput, AudioResponseUncheckedUpdateManyInput>
    /**
     * Filter which AudioResponses to update
     */
    where?: AudioResponseWhereInput
  }

  /**
   * AudioResponse upsert
   */
  export type AudioResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioResponse
     */
    select?: AudioResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioResponse to update in case it exists.
     */
    where: AudioResponseWhereUniqueInput
    /**
     * In case the AudioResponse found by the `where` argument doesn't exist, create a new AudioResponse with this data.
     */
    create: XOR<AudioResponseCreateInput, AudioResponseUncheckedCreateInput>
    /**
     * In case the AudioResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioResponseUpdateInput, AudioResponseUncheckedUpdateInput>
  }

  /**
   * AudioResponse delete
   */
  export type AudioResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioResponse
     */
    select?: AudioResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioResponseInclude<ExtArgs> | null
    /**
     * Filter which AudioResponse to delete.
     */
    where: AudioResponseWhereUniqueInput
  }

  /**
   * AudioResponse deleteMany
   */
  export type AudioResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioResponses to delete
     */
    where?: AudioResponseWhereInput
  }

  /**
   * AudioResponse without action
   */
  export type AudioResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioResponse
     */
    select?: AudioResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioResponseInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    channel: string | null
    type: string | null
    title: string | null
    message: string | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    channel: string | null
    type: string | null
    title: string | null
    message: string | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    channel: number
    type: number
    title: number
    message: number
    readAt: number
    createdAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    channel?: true
    type?: true
    title?: true
    message?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    channel?: true
    type?: true
    title?: true
    message?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    channel?: true
    type?: true
    title?: true
    message?: true
    readAt?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number
    channel: string
    type: string
    title: string
    message: string
    readAt: Date | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    channel?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    readAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    channel?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    readAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    channel?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    readAt?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      channel: string
      type: string
      title: string
      message: string
      readAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly channel: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _avg: PasswordResetTokenAvgAggregateOutputType | null
    _sum: PasswordResetTokenSumAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    usedAt: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordResetTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordResetTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _avg?: PasswordResetTokenAvgAggregateInputType
    _sum?: PasswordResetTokenSumAggregateInputType
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: number
    userId: number
    token: string
    expiresAt: Date
    usedAt: Date | null
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _avg: PasswordResetTokenAvgAggregateOutputType | null
    _sum: PasswordResetTokenSumAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }

  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
      expiresAt: Date
      usedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */ 
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'Int'>
    readonly userId: FieldRef<"PasswordResetToken", 'Int'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly usedAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    emailVerifiedAt: 'emailVerifiedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ExamAttemptScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    createdAt: 'createdAt',
    submittedAt: 'submittedAt',
    mcqQuestionIds: 'mcqQuestionIds',
    listeningScenarioId: 'listeningScenarioId',
    writingTopicId: 'writingTopicId',
    speakingSetId: 'speakingSetId',
    mcqAnswers: 'mcqAnswers',
    listeningAnswers: 'listeningAnswers',
    writingAnswer: 'writingAnswer',
    speakingTranscript: 'speakingTranscript',
    speakingScore: 'speakingScore'
  };

  export type ExamAttemptScalarFieldEnum = (typeof ExamAttemptScalarFieldEnum)[keyof typeof ExamAttemptScalarFieldEnum]


  export const ActiveExamScalarFieldEnum: {
    userId: 'userId',
    attemptId: 'attemptId',
    createdAt: 'createdAt',
    mcqCorrect: 'mcqCorrect',
    listeningCorrect: 'listeningCorrect'
  };

  export type ActiveExamScalarFieldEnum = (typeof ActiveExamScalarFieldEnum)[keyof typeof ActiveExamScalarFieldEnum]


  export const ExamResultScalarFieldEnum: {
    id: 'id',
    attemptId: 'attemptId',
    userId: 'userId',
    score: 'score',
    grammarScore: 'grammarScore',
    writingScore: 'writingScore',
    speakingScore: 'speakingScore',
    listeningScore: 'listeningScore',
    level: 'level',
    createdAt: 'createdAt'
  };

  export type ExamResultScalarFieldEnum = (typeof ExamResultScalarFieldEnum)[keyof typeof ExamResultScalarFieldEnum]


  export const McqQuestionScalarFieldEnum: {
    id: 'id',
    text: 'text',
    options: 'options',
    correct: 'correct',
    difficulty: 'difficulty',
    createdAt: 'createdAt'
  };

  export type McqQuestionScalarFieldEnum = (typeof McqQuestionScalarFieldEnum)[keyof typeof McqQuestionScalarFieldEnum]


  export const ListeningScenarioScalarFieldEnum: {
    id: 'id',
    topic: 'topic',
    passage: 'passage',
    difficulty: 'difficulty',
    createdAt: 'createdAt'
  };

  export type ListeningScenarioScalarFieldEnum = (typeof ListeningScenarioScalarFieldEnum)[keyof typeof ListeningScenarioScalarFieldEnum]


  export const ListeningQuestionScalarFieldEnum: {
    id: 'id',
    scenarioId: 'scenarioId',
    qid: 'qid',
    text: 'text',
    options: 'options',
    correct: 'correct'
  };

  export type ListeningQuestionScalarFieldEnum = (typeof ListeningQuestionScalarFieldEnum)[keyof typeof ListeningQuestionScalarFieldEnum]


  export const WritingTopicScalarFieldEnum: {
    id: 'id',
    topic: 'topic',
    difficulty: 'difficulty',
    createdAt: 'createdAt'
  };

  export type WritingTopicScalarFieldEnum = (typeof WritingTopicScalarFieldEnum)[keyof typeof WritingTopicScalarFieldEnum]


  export const SpeakingSetScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt'
  };

  export type SpeakingSetScalarFieldEnum = (typeof SpeakingSetScalarFieldEnum)[keyof typeof SpeakingSetScalarFieldEnum]


  export const SpeakingPromptScalarFieldEnum: {
    id: 'id',
    setId: 'setId',
    text: 'text'
  };

  export type SpeakingPromptScalarFieldEnum = (typeof SpeakingPromptScalarFieldEnum)[keyof typeof SpeakingPromptScalarFieldEnum]


  export const CheatingEventScalarFieldEnum: {
    id: 'id',
    attemptId: 'attemptId',
    type: 'type',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type CheatingEventScalarFieldEnum = (typeof CheatingEventScalarFieldEnum)[keyof typeof CheatingEventScalarFieldEnum]


  export const AudioResponseScalarFieldEnum: {
    id: 'id',
    attemptId: 'attemptId',
    promptIndex: 'promptIndex',
    storageUrl: 'storageUrl',
    mimeType: 'mimeType',
    durationMs: 'durationMs',
    asrText: 'asrText',
    asrConfidence: 'asrConfidence',
    createdAt: 'createdAt'
  };

  export type AudioResponseScalarFieldEnum = (typeof AudioResponseScalarFieldEnum)[keyof typeof AudioResponseScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    channel: 'channel',
    type: 'type',
    title: 'title',
    message: 'message',
    readAt: 'readAt',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    usedAt: 'usedAt',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    examResults?: ExamResultListRelationFilter
    attempts?: ExamAttemptListRelationFilter
    activeExam?: XOR<ActiveExamNullableRelationFilter, ActiveExamWhereInput> | null
    notifications?: NotificationListRelationFilter
    resetTokens?: PasswordResetTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    examResults?: ExamResultOrderByRelationAggregateInput
    attempts?: ExamAttemptOrderByRelationAggregateInput
    activeExam?: ActiveExamOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    resetTokens?: PasswordResetTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    examResults?: ExamResultListRelationFilter
    attempts?: ExamAttemptListRelationFilter
    activeExam?: XOR<ActiveExamNullableRelationFilter, ActiveExamWhereInput> | null
    notifications?: NotificationListRelationFilter
    resetTokens?: PasswordResetTokenListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type ExamAttemptWhereInput = {
    AND?: ExamAttemptWhereInput | ExamAttemptWhereInput[]
    OR?: ExamAttemptWhereInput[]
    NOT?: ExamAttemptWhereInput | ExamAttemptWhereInput[]
    id?: IntFilter<"ExamAttempt"> | number
    userId?: IntFilter<"ExamAttempt"> | number
    status?: StringFilter<"ExamAttempt"> | string
    createdAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"ExamAttempt"> | Date | string | null
    mcqQuestionIds?: StringNullableFilter<"ExamAttempt"> | string | null
    listeningScenarioId?: IntNullableFilter<"ExamAttempt"> | number | null
    writingTopicId?: IntNullableFilter<"ExamAttempt"> | number | null
    speakingSetId?: IntNullableFilter<"ExamAttempt"> | number | null
    mcqAnswers?: StringNullableFilter<"ExamAttempt"> | string | null
    listeningAnswers?: StringNullableFilter<"ExamAttempt"> | string | null
    writingAnswer?: StringNullableFilter<"ExamAttempt"> | string | null
    speakingTranscript?: StringNullableFilter<"ExamAttempt"> | string | null
    speakingScore?: IntNullableFilter<"ExamAttempt"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    listeningScenario?: XOR<ListeningScenarioNullableRelationFilter, ListeningScenarioWhereInput> | null
    writingTopic?: XOR<WritingTopicNullableRelationFilter, WritingTopicWhereInput> | null
    speakingSet?: XOR<SpeakingSetNullableRelationFilter, SpeakingSetWhereInput> | null
    result?: XOR<ExamResultNullableRelationFilter, ExamResultWhereInput> | null
    cheatingEvents?: CheatingEventListRelationFilter
    audioResponses?: AudioResponseListRelationFilter
    activeExam?: XOR<ActiveExamNullableRelationFilter, ActiveExamWhereInput> | null
  }

  export type ExamAttemptOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    mcqQuestionIds?: SortOrderInput | SortOrder
    listeningScenarioId?: SortOrderInput | SortOrder
    writingTopicId?: SortOrderInput | SortOrder
    speakingSetId?: SortOrderInput | SortOrder
    mcqAnswers?: SortOrderInput | SortOrder
    listeningAnswers?: SortOrderInput | SortOrder
    writingAnswer?: SortOrderInput | SortOrder
    speakingTranscript?: SortOrderInput | SortOrder
    speakingScore?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    listeningScenario?: ListeningScenarioOrderByWithRelationInput
    writingTopic?: WritingTopicOrderByWithRelationInput
    speakingSet?: SpeakingSetOrderByWithRelationInput
    result?: ExamResultOrderByWithRelationInput
    cheatingEvents?: CheatingEventOrderByRelationAggregateInput
    audioResponses?: AudioResponseOrderByRelationAggregateInput
    activeExam?: ActiveExamOrderByWithRelationInput
  }

  export type ExamAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExamAttemptWhereInput | ExamAttemptWhereInput[]
    OR?: ExamAttemptWhereInput[]
    NOT?: ExamAttemptWhereInput | ExamAttemptWhereInput[]
    userId?: IntFilter<"ExamAttempt"> | number
    status?: StringFilter<"ExamAttempt"> | string
    createdAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"ExamAttempt"> | Date | string | null
    mcqQuestionIds?: StringNullableFilter<"ExamAttempt"> | string | null
    listeningScenarioId?: IntNullableFilter<"ExamAttempt"> | number | null
    writingTopicId?: IntNullableFilter<"ExamAttempt"> | number | null
    speakingSetId?: IntNullableFilter<"ExamAttempt"> | number | null
    mcqAnswers?: StringNullableFilter<"ExamAttempt"> | string | null
    listeningAnswers?: StringNullableFilter<"ExamAttempt"> | string | null
    writingAnswer?: StringNullableFilter<"ExamAttempt"> | string | null
    speakingTranscript?: StringNullableFilter<"ExamAttempt"> | string | null
    speakingScore?: IntNullableFilter<"ExamAttempt"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    listeningScenario?: XOR<ListeningScenarioNullableRelationFilter, ListeningScenarioWhereInput> | null
    writingTopic?: XOR<WritingTopicNullableRelationFilter, WritingTopicWhereInput> | null
    speakingSet?: XOR<SpeakingSetNullableRelationFilter, SpeakingSetWhereInput> | null
    result?: XOR<ExamResultNullableRelationFilter, ExamResultWhereInput> | null
    cheatingEvents?: CheatingEventListRelationFilter
    audioResponses?: AudioResponseListRelationFilter
    activeExam?: XOR<ActiveExamNullableRelationFilter, ActiveExamWhereInput> | null
  }, "id">

  export type ExamAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    mcqQuestionIds?: SortOrderInput | SortOrder
    listeningScenarioId?: SortOrderInput | SortOrder
    writingTopicId?: SortOrderInput | SortOrder
    speakingSetId?: SortOrderInput | SortOrder
    mcqAnswers?: SortOrderInput | SortOrder
    listeningAnswers?: SortOrderInput | SortOrder
    writingAnswer?: SortOrderInput | SortOrder
    speakingTranscript?: SortOrderInput | SortOrder
    speakingScore?: SortOrderInput | SortOrder
    _count?: ExamAttemptCountOrderByAggregateInput
    _avg?: ExamAttemptAvgOrderByAggregateInput
    _max?: ExamAttemptMaxOrderByAggregateInput
    _min?: ExamAttemptMinOrderByAggregateInput
    _sum?: ExamAttemptSumOrderByAggregateInput
  }

  export type ExamAttemptScalarWhereWithAggregatesInput = {
    AND?: ExamAttemptScalarWhereWithAggregatesInput | ExamAttemptScalarWhereWithAggregatesInput[]
    OR?: ExamAttemptScalarWhereWithAggregatesInput[]
    NOT?: ExamAttemptScalarWhereWithAggregatesInput | ExamAttemptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExamAttempt"> | number
    userId?: IntWithAggregatesFilter<"ExamAttempt"> | number
    status?: StringWithAggregatesFilter<"ExamAttempt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ExamAttempt"> | Date | string
    submittedAt?: DateTimeNullableWithAggregatesFilter<"ExamAttempt"> | Date | string | null
    mcqQuestionIds?: StringNullableWithAggregatesFilter<"ExamAttempt"> | string | null
    listeningScenarioId?: IntNullableWithAggregatesFilter<"ExamAttempt"> | number | null
    writingTopicId?: IntNullableWithAggregatesFilter<"ExamAttempt"> | number | null
    speakingSetId?: IntNullableWithAggregatesFilter<"ExamAttempt"> | number | null
    mcqAnswers?: StringNullableWithAggregatesFilter<"ExamAttempt"> | string | null
    listeningAnswers?: StringNullableWithAggregatesFilter<"ExamAttempt"> | string | null
    writingAnswer?: StringNullableWithAggregatesFilter<"ExamAttempt"> | string | null
    speakingTranscript?: StringNullableWithAggregatesFilter<"ExamAttempt"> | string | null
    speakingScore?: IntNullableWithAggregatesFilter<"ExamAttempt"> | number | null
  }

  export type ActiveExamWhereInput = {
    AND?: ActiveExamWhereInput | ActiveExamWhereInput[]
    OR?: ActiveExamWhereInput[]
    NOT?: ActiveExamWhereInput | ActiveExamWhereInput[]
    userId?: IntFilter<"ActiveExam"> | number
    attemptId?: IntFilter<"ActiveExam"> | number
    createdAt?: DateTimeFilter<"ActiveExam"> | Date | string
    mcqCorrect?: StringFilter<"ActiveExam"> | string
    listeningCorrect?: StringFilter<"ActiveExam"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    attempt?: XOR<ExamAttemptRelationFilter, ExamAttemptWhereInput>
  }

  export type ActiveExamOrderByWithRelationInput = {
    userId?: SortOrder
    attemptId?: SortOrder
    createdAt?: SortOrder
    mcqCorrect?: SortOrder
    listeningCorrect?: SortOrder
    user?: UserOrderByWithRelationInput
    attempt?: ExamAttemptOrderByWithRelationInput
  }

  export type ActiveExamWhereUniqueInput = Prisma.AtLeast<{
    userId?: number
    attemptId?: number
    AND?: ActiveExamWhereInput | ActiveExamWhereInput[]
    OR?: ActiveExamWhereInput[]
    NOT?: ActiveExamWhereInput | ActiveExamWhereInput[]
    createdAt?: DateTimeFilter<"ActiveExam"> | Date | string
    mcqCorrect?: StringFilter<"ActiveExam"> | string
    listeningCorrect?: StringFilter<"ActiveExam"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    attempt?: XOR<ExamAttemptRelationFilter, ExamAttemptWhereInput>
  }, "userId" | "attemptId">

  export type ActiveExamOrderByWithAggregationInput = {
    userId?: SortOrder
    attemptId?: SortOrder
    createdAt?: SortOrder
    mcqCorrect?: SortOrder
    listeningCorrect?: SortOrder
    _count?: ActiveExamCountOrderByAggregateInput
    _avg?: ActiveExamAvgOrderByAggregateInput
    _max?: ActiveExamMaxOrderByAggregateInput
    _min?: ActiveExamMinOrderByAggregateInput
    _sum?: ActiveExamSumOrderByAggregateInput
  }

  export type ActiveExamScalarWhereWithAggregatesInput = {
    AND?: ActiveExamScalarWhereWithAggregatesInput | ActiveExamScalarWhereWithAggregatesInput[]
    OR?: ActiveExamScalarWhereWithAggregatesInput[]
    NOT?: ActiveExamScalarWhereWithAggregatesInput | ActiveExamScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"ActiveExam"> | number
    attemptId?: IntWithAggregatesFilter<"ActiveExam"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ActiveExam"> | Date | string
    mcqCorrect?: StringWithAggregatesFilter<"ActiveExam"> | string
    listeningCorrect?: StringWithAggregatesFilter<"ActiveExam"> | string
  }

  export type ExamResultWhereInput = {
    AND?: ExamResultWhereInput | ExamResultWhereInput[]
    OR?: ExamResultWhereInput[]
    NOT?: ExamResultWhereInput | ExamResultWhereInput[]
    id?: IntFilter<"ExamResult"> | number
    attemptId?: IntFilter<"ExamResult"> | number
    userId?: IntFilter<"ExamResult"> | number
    score?: IntFilter<"ExamResult"> | number
    grammarScore?: IntFilter<"ExamResult"> | number
    writingScore?: IntFilter<"ExamResult"> | number
    speakingScore?: IntFilter<"ExamResult"> | number
    listeningScore?: IntFilter<"ExamResult"> | number
    level?: StringFilter<"ExamResult"> | string
    createdAt?: DateTimeFilter<"ExamResult"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    attempt?: XOR<ExamAttemptRelationFilter, ExamAttemptWhereInput>
  }

  export type ExamResultOrderByWithRelationInput = {
    id?: SortOrder
    attemptId?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    grammarScore?: SortOrder
    writingScore?: SortOrder
    speakingScore?: SortOrder
    listeningScore?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    attempt?: ExamAttemptOrderByWithRelationInput
  }

  export type ExamResultWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    attemptId?: number
    AND?: ExamResultWhereInput | ExamResultWhereInput[]
    OR?: ExamResultWhereInput[]
    NOT?: ExamResultWhereInput | ExamResultWhereInput[]
    userId?: IntFilter<"ExamResult"> | number
    score?: IntFilter<"ExamResult"> | number
    grammarScore?: IntFilter<"ExamResult"> | number
    writingScore?: IntFilter<"ExamResult"> | number
    speakingScore?: IntFilter<"ExamResult"> | number
    listeningScore?: IntFilter<"ExamResult"> | number
    level?: StringFilter<"ExamResult"> | string
    createdAt?: DateTimeFilter<"ExamResult"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    attempt?: XOR<ExamAttemptRelationFilter, ExamAttemptWhereInput>
  }, "id" | "attemptId">

  export type ExamResultOrderByWithAggregationInput = {
    id?: SortOrder
    attemptId?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    grammarScore?: SortOrder
    writingScore?: SortOrder
    speakingScore?: SortOrder
    listeningScore?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    _count?: ExamResultCountOrderByAggregateInput
    _avg?: ExamResultAvgOrderByAggregateInput
    _max?: ExamResultMaxOrderByAggregateInput
    _min?: ExamResultMinOrderByAggregateInput
    _sum?: ExamResultSumOrderByAggregateInput
  }

  export type ExamResultScalarWhereWithAggregatesInput = {
    AND?: ExamResultScalarWhereWithAggregatesInput | ExamResultScalarWhereWithAggregatesInput[]
    OR?: ExamResultScalarWhereWithAggregatesInput[]
    NOT?: ExamResultScalarWhereWithAggregatesInput | ExamResultScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExamResult"> | number
    attemptId?: IntWithAggregatesFilter<"ExamResult"> | number
    userId?: IntWithAggregatesFilter<"ExamResult"> | number
    score?: IntWithAggregatesFilter<"ExamResult"> | number
    grammarScore?: IntWithAggregatesFilter<"ExamResult"> | number
    writingScore?: IntWithAggregatesFilter<"ExamResult"> | number
    speakingScore?: IntWithAggregatesFilter<"ExamResult"> | number
    listeningScore?: IntWithAggregatesFilter<"ExamResult"> | number
    level?: StringWithAggregatesFilter<"ExamResult"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ExamResult"> | Date | string
  }

  export type McqQuestionWhereInput = {
    AND?: McqQuestionWhereInput | McqQuestionWhereInput[]
    OR?: McqQuestionWhereInput[]
    NOT?: McqQuestionWhereInput | McqQuestionWhereInput[]
    id?: IntFilter<"McqQuestion"> | number
    text?: StringFilter<"McqQuestion"> | string
    options?: StringFilter<"McqQuestion"> | string
    correct?: StringFilter<"McqQuestion"> | string
    difficulty?: StringNullableFilter<"McqQuestion"> | string | null
    createdAt?: DateTimeFilter<"McqQuestion"> | Date | string
  }

  export type McqQuestionOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    options?: SortOrder
    correct?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type McqQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: McqQuestionWhereInput | McqQuestionWhereInput[]
    OR?: McqQuestionWhereInput[]
    NOT?: McqQuestionWhereInput | McqQuestionWhereInput[]
    text?: StringFilter<"McqQuestion"> | string
    options?: StringFilter<"McqQuestion"> | string
    correct?: StringFilter<"McqQuestion"> | string
    difficulty?: StringNullableFilter<"McqQuestion"> | string | null
    createdAt?: DateTimeFilter<"McqQuestion"> | Date | string
  }, "id">

  export type McqQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    options?: SortOrder
    correct?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: McqQuestionCountOrderByAggregateInput
    _avg?: McqQuestionAvgOrderByAggregateInput
    _max?: McqQuestionMaxOrderByAggregateInput
    _min?: McqQuestionMinOrderByAggregateInput
    _sum?: McqQuestionSumOrderByAggregateInput
  }

  export type McqQuestionScalarWhereWithAggregatesInput = {
    AND?: McqQuestionScalarWhereWithAggregatesInput | McqQuestionScalarWhereWithAggregatesInput[]
    OR?: McqQuestionScalarWhereWithAggregatesInput[]
    NOT?: McqQuestionScalarWhereWithAggregatesInput | McqQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"McqQuestion"> | number
    text?: StringWithAggregatesFilter<"McqQuestion"> | string
    options?: StringWithAggregatesFilter<"McqQuestion"> | string
    correct?: StringWithAggregatesFilter<"McqQuestion"> | string
    difficulty?: StringNullableWithAggregatesFilter<"McqQuestion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"McqQuestion"> | Date | string
  }

  export type ListeningScenarioWhereInput = {
    AND?: ListeningScenarioWhereInput | ListeningScenarioWhereInput[]
    OR?: ListeningScenarioWhereInput[]
    NOT?: ListeningScenarioWhereInput | ListeningScenarioWhereInput[]
    id?: IntFilter<"ListeningScenario"> | number
    topic?: StringFilter<"ListeningScenario"> | string
    passage?: StringFilter<"ListeningScenario"> | string
    difficulty?: StringNullableFilter<"ListeningScenario"> | string | null
    createdAt?: DateTimeFilter<"ListeningScenario"> | Date | string
    questions?: ListeningQuestionListRelationFilter
    attempts?: ExamAttemptListRelationFilter
  }

  export type ListeningScenarioOrderByWithRelationInput = {
    id?: SortOrder
    topic?: SortOrder
    passage?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    questions?: ListeningQuestionOrderByRelationAggregateInput
    attempts?: ExamAttemptOrderByRelationAggregateInput
  }

  export type ListeningScenarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ListeningScenarioWhereInput | ListeningScenarioWhereInput[]
    OR?: ListeningScenarioWhereInput[]
    NOT?: ListeningScenarioWhereInput | ListeningScenarioWhereInput[]
    topic?: StringFilter<"ListeningScenario"> | string
    passage?: StringFilter<"ListeningScenario"> | string
    difficulty?: StringNullableFilter<"ListeningScenario"> | string | null
    createdAt?: DateTimeFilter<"ListeningScenario"> | Date | string
    questions?: ListeningQuestionListRelationFilter
    attempts?: ExamAttemptListRelationFilter
  }, "id">

  export type ListeningScenarioOrderByWithAggregationInput = {
    id?: SortOrder
    topic?: SortOrder
    passage?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ListeningScenarioCountOrderByAggregateInput
    _avg?: ListeningScenarioAvgOrderByAggregateInput
    _max?: ListeningScenarioMaxOrderByAggregateInput
    _min?: ListeningScenarioMinOrderByAggregateInput
    _sum?: ListeningScenarioSumOrderByAggregateInput
  }

  export type ListeningScenarioScalarWhereWithAggregatesInput = {
    AND?: ListeningScenarioScalarWhereWithAggregatesInput | ListeningScenarioScalarWhereWithAggregatesInput[]
    OR?: ListeningScenarioScalarWhereWithAggregatesInput[]
    NOT?: ListeningScenarioScalarWhereWithAggregatesInput | ListeningScenarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ListeningScenario"> | number
    topic?: StringWithAggregatesFilter<"ListeningScenario"> | string
    passage?: StringWithAggregatesFilter<"ListeningScenario"> | string
    difficulty?: StringNullableWithAggregatesFilter<"ListeningScenario"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ListeningScenario"> | Date | string
  }

  export type ListeningQuestionWhereInput = {
    AND?: ListeningQuestionWhereInput | ListeningQuestionWhereInput[]
    OR?: ListeningQuestionWhereInput[]
    NOT?: ListeningQuestionWhereInput | ListeningQuestionWhereInput[]
    id?: IntFilter<"ListeningQuestion"> | number
    scenarioId?: IntFilter<"ListeningQuestion"> | number
    qid?: StringFilter<"ListeningQuestion"> | string
    text?: StringFilter<"ListeningQuestion"> | string
    options?: StringFilter<"ListeningQuestion"> | string
    correct?: StringFilter<"ListeningQuestion"> | string
    scenario?: XOR<ListeningScenarioRelationFilter, ListeningScenarioWhereInput>
  }

  export type ListeningQuestionOrderByWithRelationInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    qid?: SortOrder
    text?: SortOrder
    options?: SortOrder
    correct?: SortOrder
    scenario?: ListeningScenarioOrderByWithRelationInput
  }

  export type ListeningQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    scenarioId_qid?: ListeningQuestionScenarioIdQidCompoundUniqueInput
    AND?: ListeningQuestionWhereInput | ListeningQuestionWhereInput[]
    OR?: ListeningQuestionWhereInput[]
    NOT?: ListeningQuestionWhereInput | ListeningQuestionWhereInput[]
    scenarioId?: IntFilter<"ListeningQuestion"> | number
    qid?: StringFilter<"ListeningQuestion"> | string
    text?: StringFilter<"ListeningQuestion"> | string
    options?: StringFilter<"ListeningQuestion"> | string
    correct?: StringFilter<"ListeningQuestion"> | string
    scenario?: XOR<ListeningScenarioRelationFilter, ListeningScenarioWhereInput>
  }, "id" | "scenarioId_qid">

  export type ListeningQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    qid?: SortOrder
    text?: SortOrder
    options?: SortOrder
    correct?: SortOrder
    _count?: ListeningQuestionCountOrderByAggregateInput
    _avg?: ListeningQuestionAvgOrderByAggregateInput
    _max?: ListeningQuestionMaxOrderByAggregateInput
    _min?: ListeningQuestionMinOrderByAggregateInput
    _sum?: ListeningQuestionSumOrderByAggregateInput
  }

  export type ListeningQuestionScalarWhereWithAggregatesInput = {
    AND?: ListeningQuestionScalarWhereWithAggregatesInput | ListeningQuestionScalarWhereWithAggregatesInput[]
    OR?: ListeningQuestionScalarWhereWithAggregatesInput[]
    NOT?: ListeningQuestionScalarWhereWithAggregatesInput | ListeningQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ListeningQuestion"> | number
    scenarioId?: IntWithAggregatesFilter<"ListeningQuestion"> | number
    qid?: StringWithAggregatesFilter<"ListeningQuestion"> | string
    text?: StringWithAggregatesFilter<"ListeningQuestion"> | string
    options?: StringWithAggregatesFilter<"ListeningQuestion"> | string
    correct?: StringWithAggregatesFilter<"ListeningQuestion"> | string
  }

  export type WritingTopicWhereInput = {
    AND?: WritingTopicWhereInput | WritingTopicWhereInput[]
    OR?: WritingTopicWhereInput[]
    NOT?: WritingTopicWhereInput | WritingTopicWhereInput[]
    id?: IntFilter<"WritingTopic"> | number
    topic?: StringFilter<"WritingTopic"> | string
    difficulty?: StringNullableFilter<"WritingTopic"> | string | null
    createdAt?: DateTimeFilter<"WritingTopic"> | Date | string
    attempts?: ExamAttemptListRelationFilter
  }

  export type WritingTopicOrderByWithRelationInput = {
    id?: SortOrder
    topic?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    attempts?: ExamAttemptOrderByRelationAggregateInput
  }

  export type WritingTopicWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WritingTopicWhereInput | WritingTopicWhereInput[]
    OR?: WritingTopicWhereInput[]
    NOT?: WritingTopicWhereInput | WritingTopicWhereInput[]
    topic?: StringFilter<"WritingTopic"> | string
    difficulty?: StringNullableFilter<"WritingTopic"> | string | null
    createdAt?: DateTimeFilter<"WritingTopic"> | Date | string
    attempts?: ExamAttemptListRelationFilter
  }, "id">

  export type WritingTopicOrderByWithAggregationInput = {
    id?: SortOrder
    topic?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WritingTopicCountOrderByAggregateInput
    _avg?: WritingTopicAvgOrderByAggregateInput
    _max?: WritingTopicMaxOrderByAggregateInput
    _min?: WritingTopicMinOrderByAggregateInput
    _sum?: WritingTopicSumOrderByAggregateInput
  }

  export type WritingTopicScalarWhereWithAggregatesInput = {
    AND?: WritingTopicScalarWhereWithAggregatesInput | WritingTopicScalarWhereWithAggregatesInput[]
    OR?: WritingTopicScalarWhereWithAggregatesInput[]
    NOT?: WritingTopicScalarWhereWithAggregatesInput | WritingTopicScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WritingTopic"> | number
    topic?: StringWithAggregatesFilter<"WritingTopic"> | string
    difficulty?: StringNullableWithAggregatesFilter<"WritingTopic"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WritingTopic"> | Date | string
  }

  export type SpeakingSetWhereInput = {
    AND?: SpeakingSetWhereInput | SpeakingSetWhereInput[]
    OR?: SpeakingSetWhereInput[]
    NOT?: SpeakingSetWhereInput | SpeakingSetWhereInput[]
    id?: IntFilter<"SpeakingSet"> | number
    createdAt?: DateTimeFilter<"SpeakingSet"> | Date | string
    prompts?: SpeakingPromptListRelationFilter
    attempts?: ExamAttemptListRelationFilter
  }

  export type SpeakingSetOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    prompts?: SpeakingPromptOrderByRelationAggregateInput
    attempts?: ExamAttemptOrderByRelationAggregateInput
  }

  export type SpeakingSetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SpeakingSetWhereInput | SpeakingSetWhereInput[]
    OR?: SpeakingSetWhereInput[]
    NOT?: SpeakingSetWhereInput | SpeakingSetWhereInput[]
    createdAt?: DateTimeFilter<"SpeakingSet"> | Date | string
    prompts?: SpeakingPromptListRelationFilter
    attempts?: ExamAttemptListRelationFilter
  }, "id">

  export type SpeakingSetOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    _count?: SpeakingSetCountOrderByAggregateInput
    _avg?: SpeakingSetAvgOrderByAggregateInput
    _max?: SpeakingSetMaxOrderByAggregateInput
    _min?: SpeakingSetMinOrderByAggregateInput
    _sum?: SpeakingSetSumOrderByAggregateInput
  }

  export type SpeakingSetScalarWhereWithAggregatesInput = {
    AND?: SpeakingSetScalarWhereWithAggregatesInput | SpeakingSetScalarWhereWithAggregatesInput[]
    OR?: SpeakingSetScalarWhereWithAggregatesInput[]
    NOT?: SpeakingSetScalarWhereWithAggregatesInput | SpeakingSetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpeakingSet"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SpeakingSet"> | Date | string
  }

  export type SpeakingPromptWhereInput = {
    AND?: SpeakingPromptWhereInput | SpeakingPromptWhereInput[]
    OR?: SpeakingPromptWhereInput[]
    NOT?: SpeakingPromptWhereInput | SpeakingPromptWhereInput[]
    id?: IntFilter<"SpeakingPrompt"> | number
    setId?: IntFilter<"SpeakingPrompt"> | number
    text?: StringFilter<"SpeakingPrompt"> | string
    set?: XOR<SpeakingSetRelationFilter, SpeakingSetWhereInput>
  }

  export type SpeakingPromptOrderByWithRelationInput = {
    id?: SortOrder
    setId?: SortOrder
    text?: SortOrder
    set?: SpeakingSetOrderByWithRelationInput
  }

  export type SpeakingPromptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SpeakingPromptWhereInput | SpeakingPromptWhereInput[]
    OR?: SpeakingPromptWhereInput[]
    NOT?: SpeakingPromptWhereInput | SpeakingPromptWhereInput[]
    setId?: IntFilter<"SpeakingPrompt"> | number
    text?: StringFilter<"SpeakingPrompt"> | string
    set?: XOR<SpeakingSetRelationFilter, SpeakingSetWhereInput>
  }, "id">

  export type SpeakingPromptOrderByWithAggregationInput = {
    id?: SortOrder
    setId?: SortOrder
    text?: SortOrder
    _count?: SpeakingPromptCountOrderByAggregateInput
    _avg?: SpeakingPromptAvgOrderByAggregateInput
    _max?: SpeakingPromptMaxOrderByAggregateInput
    _min?: SpeakingPromptMinOrderByAggregateInput
    _sum?: SpeakingPromptSumOrderByAggregateInput
  }

  export type SpeakingPromptScalarWhereWithAggregatesInput = {
    AND?: SpeakingPromptScalarWhereWithAggregatesInput | SpeakingPromptScalarWhereWithAggregatesInput[]
    OR?: SpeakingPromptScalarWhereWithAggregatesInput[]
    NOT?: SpeakingPromptScalarWhereWithAggregatesInput | SpeakingPromptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpeakingPrompt"> | number
    setId?: IntWithAggregatesFilter<"SpeakingPrompt"> | number
    text?: StringWithAggregatesFilter<"SpeakingPrompt"> | string
  }

  export type CheatingEventWhereInput = {
    AND?: CheatingEventWhereInput | CheatingEventWhereInput[]
    OR?: CheatingEventWhereInput[]
    NOT?: CheatingEventWhereInput | CheatingEventWhereInput[]
    id?: IntFilter<"CheatingEvent"> | number
    attemptId?: IntFilter<"CheatingEvent"> | number
    type?: StringFilter<"CheatingEvent"> | string
    details?: StringNullableFilter<"CheatingEvent"> | string | null
    createdAt?: DateTimeFilter<"CheatingEvent"> | Date | string
    attempt?: XOR<ExamAttemptRelationFilter, ExamAttemptWhereInput>
  }

  export type CheatingEventOrderByWithRelationInput = {
    id?: SortOrder
    attemptId?: SortOrder
    type?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    attempt?: ExamAttemptOrderByWithRelationInput
  }

  export type CheatingEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CheatingEventWhereInput | CheatingEventWhereInput[]
    OR?: CheatingEventWhereInput[]
    NOT?: CheatingEventWhereInput | CheatingEventWhereInput[]
    attemptId?: IntFilter<"CheatingEvent"> | number
    type?: StringFilter<"CheatingEvent"> | string
    details?: StringNullableFilter<"CheatingEvent"> | string | null
    createdAt?: DateTimeFilter<"CheatingEvent"> | Date | string
    attempt?: XOR<ExamAttemptRelationFilter, ExamAttemptWhereInput>
  }, "id">

  export type CheatingEventOrderByWithAggregationInput = {
    id?: SortOrder
    attemptId?: SortOrder
    type?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CheatingEventCountOrderByAggregateInput
    _avg?: CheatingEventAvgOrderByAggregateInput
    _max?: CheatingEventMaxOrderByAggregateInput
    _min?: CheatingEventMinOrderByAggregateInput
    _sum?: CheatingEventSumOrderByAggregateInput
  }

  export type CheatingEventScalarWhereWithAggregatesInput = {
    AND?: CheatingEventScalarWhereWithAggregatesInput | CheatingEventScalarWhereWithAggregatesInput[]
    OR?: CheatingEventScalarWhereWithAggregatesInput[]
    NOT?: CheatingEventScalarWhereWithAggregatesInput | CheatingEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CheatingEvent"> | number
    attemptId?: IntWithAggregatesFilter<"CheatingEvent"> | number
    type?: StringWithAggregatesFilter<"CheatingEvent"> | string
    details?: StringNullableWithAggregatesFilter<"CheatingEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CheatingEvent"> | Date | string
  }

  export type AudioResponseWhereInput = {
    AND?: AudioResponseWhereInput | AudioResponseWhereInput[]
    OR?: AudioResponseWhereInput[]
    NOT?: AudioResponseWhereInput | AudioResponseWhereInput[]
    id?: IntFilter<"AudioResponse"> | number
    attemptId?: IntFilter<"AudioResponse"> | number
    promptIndex?: IntFilter<"AudioResponse"> | number
    storageUrl?: StringFilter<"AudioResponse"> | string
    mimeType?: StringNullableFilter<"AudioResponse"> | string | null
    durationMs?: IntNullableFilter<"AudioResponse"> | number | null
    asrText?: StringNullableFilter<"AudioResponse"> | string | null
    asrConfidence?: FloatNullableFilter<"AudioResponse"> | number | null
    createdAt?: DateTimeFilter<"AudioResponse"> | Date | string
    attempt?: XOR<ExamAttemptRelationFilter, ExamAttemptWhereInput>
  }

  export type AudioResponseOrderByWithRelationInput = {
    id?: SortOrder
    attemptId?: SortOrder
    promptIndex?: SortOrder
    storageUrl?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    asrText?: SortOrderInput | SortOrder
    asrConfidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    attempt?: ExamAttemptOrderByWithRelationInput
  }

  export type AudioResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AudioResponseWhereInput | AudioResponseWhereInput[]
    OR?: AudioResponseWhereInput[]
    NOT?: AudioResponseWhereInput | AudioResponseWhereInput[]
    attemptId?: IntFilter<"AudioResponse"> | number
    promptIndex?: IntFilter<"AudioResponse"> | number
    storageUrl?: StringFilter<"AudioResponse"> | string
    mimeType?: StringNullableFilter<"AudioResponse"> | string | null
    durationMs?: IntNullableFilter<"AudioResponse"> | number | null
    asrText?: StringNullableFilter<"AudioResponse"> | string | null
    asrConfidence?: FloatNullableFilter<"AudioResponse"> | number | null
    createdAt?: DateTimeFilter<"AudioResponse"> | Date | string
    attempt?: XOR<ExamAttemptRelationFilter, ExamAttemptWhereInput>
  }, "id">

  export type AudioResponseOrderByWithAggregationInput = {
    id?: SortOrder
    attemptId?: SortOrder
    promptIndex?: SortOrder
    storageUrl?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    asrText?: SortOrderInput | SortOrder
    asrConfidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AudioResponseCountOrderByAggregateInput
    _avg?: AudioResponseAvgOrderByAggregateInput
    _max?: AudioResponseMaxOrderByAggregateInput
    _min?: AudioResponseMinOrderByAggregateInput
    _sum?: AudioResponseSumOrderByAggregateInput
  }

  export type AudioResponseScalarWhereWithAggregatesInput = {
    AND?: AudioResponseScalarWhereWithAggregatesInput | AudioResponseScalarWhereWithAggregatesInput[]
    OR?: AudioResponseScalarWhereWithAggregatesInput[]
    NOT?: AudioResponseScalarWhereWithAggregatesInput | AudioResponseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AudioResponse"> | number
    attemptId?: IntWithAggregatesFilter<"AudioResponse"> | number
    promptIndex?: IntWithAggregatesFilter<"AudioResponse"> | number
    storageUrl?: StringWithAggregatesFilter<"AudioResponse"> | string
    mimeType?: StringNullableWithAggregatesFilter<"AudioResponse"> | string | null
    durationMs?: IntNullableWithAggregatesFilter<"AudioResponse"> | number | null
    asrText?: StringNullableWithAggregatesFilter<"AudioResponse"> | string | null
    asrConfidence?: FloatNullableWithAggregatesFilter<"AudioResponse"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AudioResponse"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    channel?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    channel?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntFilter<"Notification"> | number
    channel?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    channel?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntWithAggregatesFilter<"Notification"> | number
    channel?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: IntFilter<"PasswordResetToken"> | number
    userId?: IntFilter<"PasswordResetToken"> | number
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: IntFilter<"PasswordResetToken"> | number
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _avg?: PasswordResetTokenAvgOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
    _sum?: PasswordResetTokenSumOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PasswordResetToken"> | number
    userId?: IntWithAggregatesFilter<"PasswordResetToken"> | number
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    role?: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerifiedAt?: Date | string | null
    examResults?: ExamResultCreateNestedManyWithoutUserInput
    attempts?: ExamAttemptCreateNestedManyWithoutUserInput
    activeExam?: ActiveExamCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    role?: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerifiedAt?: Date | string | null
    examResults?: ExamResultUncheckedCreateNestedManyWithoutUserInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    activeExam?: ActiveExamUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examResults?: ExamResultUpdateManyWithoutUserNestedInput
    attempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    activeExam?: ActiveExamUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examResults?: ExamResultUncheckedUpdateManyWithoutUserNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    activeExam?: ActiveExamUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    role?: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerifiedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExamAttemptCreateInput = {
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    user: UserCreateNestedOneWithoutAttemptsInput
    listeningScenario?: ListeningScenarioCreateNestedOneWithoutAttemptsInput
    writingTopic?: WritingTopicCreateNestedOneWithoutAttemptsInput
    speakingSet?: SpeakingSetCreateNestedOneWithoutAttemptsInput
    result?: ExamResultCreateNestedOneWithoutAttemptInput
    cheatingEvents?: CheatingEventCreateNestedManyWithoutAttemptInput
    audioResponses?: AudioResponseCreateNestedManyWithoutAttemptInput
    activeExam?: ActiveExamCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateInput = {
    id?: number
    userId: number
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    listeningScenarioId?: number | null
    writingTopicId?: number | null
    speakingSetId?: number | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    result?: ExamResultUncheckedCreateNestedOneWithoutAttemptInput
    cheatingEvents?: CheatingEventUncheckedCreateNestedManyWithoutAttemptInput
    audioResponses?: AudioResponseUncheckedCreateNestedManyWithoutAttemptInput
    activeExam?: ActiveExamUncheckedCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutAttemptsNestedInput
    listeningScenario?: ListeningScenarioUpdateOneWithoutAttemptsNestedInput
    writingTopic?: WritingTopicUpdateOneWithoutAttemptsNestedInput
    speakingSet?: SpeakingSetUpdateOneWithoutAttemptsNestedInput
    result?: ExamResultUpdateOneWithoutAttemptNestedInput
    cheatingEvents?: CheatingEventUpdateManyWithoutAttemptNestedInput
    audioResponses?: AudioResponseUpdateManyWithoutAttemptNestedInput
    activeExam?: ActiveExamUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    listeningScenarioId?: NullableIntFieldUpdateOperationsInput | number | null
    writingTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    speakingSetId?: NullableIntFieldUpdateOperationsInput | number | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    result?: ExamResultUncheckedUpdateOneWithoutAttemptNestedInput
    cheatingEvents?: CheatingEventUncheckedUpdateManyWithoutAttemptNestedInput
    audioResponses?: AudioResponseUncheckedUpdateManyWithoutAttemptNestedInput
    activeExam?: ActiveExamUncheckedUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptCreateManyInput = {
    id?: number
    userId: number
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    listeningScenarioId?: number | null
    writingTopicId?: number | null
    speakingSetId?: number | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
  }

  export type ExamAttemptUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExamAttemptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    listeningScenarioId?: NullableIntFieldUpdateOperationsInput | number | null
    writingTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    speakingSetId?: NullableIntFieldUpdateOperationsInput | number | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActiveExamCreateInput = {
    createdAt?: Date | string
    mcqCorrect: string
    listeningCorrect: string
    user: UserCreateNestedOneWithoutActiveExamInput
    attempt: ExamAttemptCreateNestedOneWithoutActiveExamInput
  }

  export type ActiveExamUncheckedCreateInput = {
    userId: number
    attemptId: number
    createdAt?: Date | string
    mcqCorrect: string
    listeningCorrect: string
  }

  export type ActiveExamUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mcqCorrect?: StringFieldUpdateOperationsInput | string
    listeningCorrect?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutActiveExamNestedInput
    attempt?: ExamAttemptUpdateOneRequiredWithoutActiveExamNestedInput
  }

  export type ActiveExamUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mcqCorrect?: StringFieldUpdateOperationsInput | string
    listeningCorrect?: StringFieldUpdateOperationsInput | string
  }

  export type ActiveExamCreateManyInput = {
    userId: number
    attemptId: number
    createdAt?: Date | string
    mcqCorrect: string
    listeningCorrect: string
  }

  export type ActiveExamUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mcqCorrect?: StringFieldUpdateOperationsInput | string
    listeningCorrect?: StringFieldUpdateOperationsInput | string
  }

  export type ActiveExamUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mcqCorrect?: StringFieldUpdateOperationsInput | string
    listeningCorrect?: StringFieldUpdateOperationsInput | string
  }

  export type ExamResultCreateInput = {
    score: number
    grammarScore: number
    writingScore: number
    speakingScore: number
    listeningScore: number
    level?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutExamResultsInput
    attempt: ExamAttemptCreateNestedOneWithoutResultInput
  }

  export type ExamResultUncheckedCreateInput = {
    id?: number
    attemptId: number
    userId: number
    score: number
    grammarScore: number
    writingScore: number
    speakingScore: number
    listeningScore: number
    level?: string
    createdAt?: Date | string
  }

  export type ExamResultUpdateInput = {
    score?: IntFieldUpdateOperationsInput | number
    grammarScore?: IntFieldUpdateOperationsInput | number
    writingScore?: IntFieldUpdateOperationsInput | number
    speakingScore?: IntFieldUpdateOperationsInput | number
    listeningScore?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExamResultsNestedInput
    attempt?: ExamAttemptUpdateOneRequiredWithoutResultNestedInput
  }

  export type ExamResultUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    grammarScore?: IntFieldUpdateOperationsInput | number
    writingScore?: IntFieldUpdateOperationsInput | number
    speakingScore?: IntFieldUpdateOperationsInput | number
    listeningScore?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamResultCreateManyInput = {
    id?: number
    attemptId: number
    userId: number
    score: number
    grammarScore: number
    writingScore: number
    speakingScore: number
    listeningScore: number
    level?: string
    createdAt?: Date | string
  }

  export type ExamResultUpdateManyMutationInput = {
    score?: IntFieldUpdateOperationsInput | number
    grammarScore?: IntFieldUpdateOperationsInput | number
    writingScore?: IntFieldUpdateOperationsInput | number
    speakingScore?: IntFieldUpdateOperationsInput | number
    listeningScore?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamResultUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    grammarScore?: IntFieldUpdateOperationsInput | number
    writingScore?: IntFieldUpdateOperationsInput | number
    speakingScore?: IntFieldUpdateOperationsInput | number
    listeningScore?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqQuestionCreateInput = {
    text: string
    options: string
    correct: string
    difficulty?: string | null
    createdAt?: Date | string
  }

  export type McqQuestionUncheckedCreateInput = {
    id?: number
    text: string
    options: string
    correct: string
    difficulty?: string | null
    createdAt?: Date | string
  }

  export type McqQuestionUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqQuestionCreateManyInput = {
    id?: number
    text: string
    options: string
    correct: string
    difficulty?: string | null
    createdAt?: Date | string
  }

  export type McqQuestionUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListeningScenarioCreateInput = {
    topic: string
    passage: string
    difficulty?: string | null
    createdAt?: Date | string
    questions?: ListeningQuestionCreateNestedManyWithoutScenarioInput
    attempts?: ExamAttemptCreateNestedManyWithoutListeningScenarioInput
  }

  export type ListeningScenarioUncheckedCreateInput = {
    id?: number
    topic: string
    passage: string
    difficulty?: string | null
    createdAt?: Date | string
    questions?: ListeningQuestionUncheckedCreateNestedManyWithoutScenarioInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutListeningScenarioInput
  }

  export type ListeningScenarioUpdateInput = {
    topic?: StringFieldUpdateOperationsInput | string
    passage?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ListeningQuestionUpdateManyWithoutScenarioNestedInput
    attempts?: ExamAttemptUpdateManyWithoutListeningScenarioNestedInput
  }

  export type ListeningScenarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    topic?: StringFieldUpdateOperationsInput | string
    passage?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ListeningQuestionUncheckedUpdateManyWithoutScenarioNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutListeningScenarioNestedInput
  }

  export type ListeningScenarioCreateManyInput = {
    id?: number
    topic: string
    passage: string
    difficulty?: string | null
    createdAt?: Date | string
  }

  export type ListeningScenarioUpdateManyMutationInput = {
    topic?: StringFieldUpdateOperationsInput | string
    passage?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListeningScenarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    topic?: StringFieldUpdateOperationsInput | string
    passage?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListeningQuestionCreateInput = {
    qid: string
    text: string
    options: string
    correct: string
    scenario: ListeningScenarioCreateNestedOneWithoutQuestionsInput
  }

  export type ListeningQuestionUncheckedCreateInput = {
    id?: number
    scenarioId: number
    qid: string
    text: string
    options: string
    correct: string
  }

  export type ListeningQuestionUpdateInput = {
    qid?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct?: StringFieldUpdateOperationsInput | string
    scenario?: ListeningScenarioUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type ListeningQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    scenarioId?: IntFieldUpdateOperationsInput | number
    qid?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct?: StringFieldUpdateOperationsInput | string
  }

  export type ListeningQuestionCreateManyInput = {
    id?: number
    scenarioId: number
    qid: string
    text: string
    options: string
    correct: string
  }

  export type ListeningQuestionUpdateManyMutationInput = {
    qid?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct?: StringFieldUpdateOperationsInput | string
  }

  export type ListeningQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    scenarioId?: IntFieldUpdateOperationsInput | number
    qid?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct?: StringFieldUpdateOperationsInput | string
  }

  export type WritingTopicCreateInput = {
    topic: string
    difficulty?: string | null
    createdAt?: Date | string
    attempts?: ExamAttemptCreateNestedManyWithoutWritingTopicInput
  }

  export type WritingTopicUncheckedCreateInput = {
    id?: number
    topic: string
    difficulty?: string | null
    createdAt?: Date | string
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutWritingTopicInput
  }

  export type WritingTopicUpdateInput = {
    topic?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: ExamAttemptUpdateManyWithoutWritingTopicNestedInput
  }

  export type WritingTopicUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    topic?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: ExamAttemptUncheckedUpdateManyWithoutWritingTopicNestedInput
  }

  export type WritingTopicCreateManyInput = {
    id?: number
    topic: string
    difficulty?: string | null
    createdAt?: Date | string
  }

  export type WritingTopicUpdateManyMutationInput = {
    topic?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WritingTopicUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    topic?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakingSetCreateInput = {
    createdAt?: Date | string
    prompts?: SpeakingPromptCreateNestedManyWithoutSetInput
    attempts?: ExamAttemptCreateNestedManyWithoutSpeakingSetInput
  }

  export type SpeakingSetUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    prompts?: SpeakingPromptUncheckedCreateNestedManyWithoutSetInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutSpeakingSetInput
  }

  export type SpeakingSetUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompts?: SpeakingPromptUpdateManyWithoutSetNestedInput
    attempts?: ExamAttemptUpdateManyWithoutSpeakingSetNestedInput
  }

  export type SpeakingSetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompts?: SpeakingPromptUncheckedUpdateManyWithoutSetNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutSpeakingSetNestedInput
  }

  export type SpeakingSetCreateManyInput = {
    id?: number
    createdAt?: Date | string
  }

  export type SpeakingSetUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakingSetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakingPromptCreateInput = {
    text: string
    set: SpeakingSetCreateNestedOneWithoutPromptsInput
  }

  export type SpeakingPromptUncheckedCreateInput = {
    id?: number
    setId: number
    text: string
  }

  export type SpeakingPromptUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    set?: SpeakingSetUpdateOneRequiredWithoutPromptsNestedInput
  }

  export type SpeakingPromptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    setId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type SpeakingPromptCreateManyInput = {
    id?: number
    setId: number
    text: string
  }

  export type SpeakingPromptUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
  }

  export type SpeakingPromptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    setId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type CheatingEventCreateInput = {
    type: string
    details?: string | null
    createdAt?: Date | string
    attempt: ExamAttemptCreateNestedOneWithoutCheatingEventsInput
  }

  export type CheatingEventUncheckedCreateInput = {
    id?: number
    attemptId: number
    type: string
    details?: string | null
    createdAt?: Date | string
  }

  export type CheatingEventUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: ExamAttemptUpdateOneRequiredWithoutCheatingEventsNestedInput
  }

  export type CheatingEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheatingEventCreateManyInput = {
    id?: number
    attemptId: number
    type: string
    details?: string | null
    createdAt?: Date | string
  }

  export type CheatingEventUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheatingEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioResponseCreateInput = {
    promptIndex: number
    storageUrl: string
    mimeType?: string | null
    durationMs?: number | null
    asrText?: string | null
    asrConfidence?: number | null
    createdAt?: Date | string
    attempt: ExamAttemptCreateNestedOneWithoutAudioResponsesInput
  }

  export type AudioResponseUncheckedCreateInput = {
    id?: number
    attemptId: number
    promptIndex: number
    storageUrl: string
    mimeType?: string | null
    durationMs?: number | null
    asrText?: string | null
    asrConfidence?: number | null
    createdAt?: Date | string
  }

  export type AudioResponseUpdateInput = {
    promptIndex?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    asrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: ExamAttemptUpdateOneRequiredWithoutAudioResponsesNestedInput
  }

  export type AudioResponseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    promptIndex?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    asrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioResponseCreateManyInput = {
    id?: number
    attemptId: number
    promptIndex: number
    storageUrl: string
    mimeType?: string | null
    durationMs?: number | null
    asrText?: string | null
    asrConfidence?: number | null
    createdAt?: Date | string
  }

  export type AudioResponseUpdateManyMutationInput = {
    promptIndex?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    asrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioResponseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    promptIndex?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    asrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    channel: string
    type: string
    title: string
    message: string
    readAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId: number
    channel: string
    type: string
    title: string
    message: string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    channel?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId: number
    channel: string
    type: string
    title: string
    message: string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    channel?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ExamResultListRelationFilter = {
    every?: ExamResultWhereInput
    some?: ExamResultWhereInput
    none?: ExamResultWhereInput
  }

  export type ExamAttemptListRelationFilter = {
    every?: ExamAttemptWhereInput
    some?: ExamAttemptWhereInput
    none?: ExamAttemptWhereInput
  }

  export type ActiveExamNullableRelationFilter = {
    is?: ActiveExamWhereInput | null
    isNot?: ActiveExamWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ExamResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailVerifiedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailVerifiedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailVerifiedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ListeningScenarioNullableRelationFilter = {
    is?: ListeningScenarioWhereInput | null
    isNot?: ListeningScenarioWhereInput | null
  }

  export type WritingTopicNullableRelationFilter = {
    is?: WritingTopicWhereInput | null
    isNot?: WritingTopicWhereInput | null
  }

  export type SpeakingSetNullableRelationFilter = {
    is?: SpeakingSetWhereInput | null
    isNot?: SpeakingSetWhereInput | null
  }

  export type ExamResultNullableRelationFilter = {
    is?: ExamResultWhereInput | null
    isNot?: ExamResultWhereInput | null
  }

  export type CheatingEventListRelationFilter = {
    every?: CheatingEventWhereInput
    some?: CheatingEventWhereInput
    none?: CheatingEventWhereInput
  }

  export type AudioResponseListRelationFilter = {
    every?: AudioResponseWhereInput
    some?: AudioResponseWhereInput
    none?: AudioResponseWhereInput
  }

  export type CheatingEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AudioResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    submittedAt?: SortOrder
    mcqQuestionIds?: SortOrder
    listeningScenarioId?: SortOrder
    writingTopicId?: SortOrder
    speakingSetId?: SortOrder
    mcqAnswers?: SortOrder
    listeningAnswers?: SortOrder
    writingAnswer?: SortOrder
    speakingTranscript?: SortOrder
    speakingScore?: SortOrder
  }

  export type ExamAttemptAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    listeningScenarioId?: SortOrder
    writingTopicId?: SortOrder
    speakingSetId?: SortOrder
    speakingScore?: SortOrder
  }

  export type ExamAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    submittedAt?: SortOrder
    mcqQuestionIds?: SortOrder
    listeningScenarioId?: SortOrder
    writingTopicId?: SortOrder
    speakingSetId?: SortOrder
    mcqAnswers?: SortOrder
    listeningAnswers?: SortOrder
    writingAnswer?: SortOrder
    speakingTranscript?: SortOrder
    speakingScore?: SortOrder
  }

  export type ExamAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    submittedAt?: SortOrder
    mcqQuestionIds?: SortOrder
    listeningScenarioId?: SortOrder
    writingTopicId?: SortOrder
    speakingSetId?: SortOrder
    mcqAnswers?: SortOrder
    listeningAnswers?: SortOrder
    writingAnswer?: SortOrder
    speakingTranscript?: SortOrder
    speakingScore?: SortOrder
  }

  export type ExamAttemptSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    listeningScenarioId?: SortOrder
    writingTopicId?: SortOrder
    speakingSetId?: SortOrder
    speakingScore?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ExamAttemptRelationFilter = {
    is?: ExamAttemptWhereInput
    isNot?: ExamAttemptWhereInput
  }

  export type ActiveExamCountOrderByAggregateInput = {
    userId?: SortOrder
    attemptId?: SortOrder
    createdAt?: SortOrder
    mcqCorrect?: SortOrder
    listeningCorrect?: SortOrder
  }

  export type ActiveExamAvgOrderByAggregateInput = {
    userId?: SortOrder
    attemptId?: SortOrder
  }

  export type ActiveExamMaxOrderByAggregateInput = {
    userId?: SortOrder
    attemptId?: SortOrder
    createdAt?: SortOrder
    mcqCorrect?: SortOrder
    listeningCorrect?: SortOrder
  }

  export type ActiveExamMinOrderByAggregateInput = {
    userId?: SortOrder
    attemptId?: SortOrder
    createdAt?: SortOrder
    mcqCorrect?: SortOrder
    listeningCorrect?: SortOrder
  }

  export type ActiveExamSumOrderByAggregateInput = {
    userId?: SortOrder
    attemptId?: SortOrder
  }

  export type ExamResultCountOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    grammarScore?: SortOrder
    writingScore?: SortOrder
    speakingScore?: SortOrder
    listeningScore?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
  }

  export type ExamResultAvgOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    grammarScore?: SortOrder
    writingScore?: SortOrder
    speakingScore?: SortOrder
    listeningScore?: SortOrder
  }

  export type ExamResultMaxOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    grammarScore?: SortOrder
    writingScore?: SortOrder
    speakingScore?: SortOrder
    listeningScore?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
  }

  export type ExamResultMinOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    grammarScore?: SortOrder
    writingScore?: SortOrder
    speakingScore?: SortOrder
    listeningScore?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
  }

  export type ExamResultSumOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    grammarScore?: SortOrder
    writingScore?: SortOrder
    speakingScore?: SortOrder
    listeningScore?: SortOrder
  }

  export type McqQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    options?: SortOrder
    correct?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
  }

  export type McqQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type McqQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    options?: SortOrder
    correct?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
  }

  export type McqQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    options?: SortOrder
    correct?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
  }

  export type McqQuestionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ListeningQuestionListRelationFilter = {
    every?: ListeningQuestionWhereInput
    some?: ListeningQuestionWhereInput
    none?: ListeningQuestionWhereInput
  }

  export type ListeningQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListeningScenarioCountOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    passage?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
  }

  export type ListeningScenarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ListeningScenarioMaxOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    passage?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
  }

  export type ListeningScenarioMinOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    passage?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
  }

  export type ListeningScenarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ListeningScenarioRelationFilter = {
    is?: ListeningScenarioWhereInput
    isNot?: ListeningScenarioWhereInput
  }

  export type ListeningQuestionScenarioIdQidCompoundUniqueInput = {
    scenarioId: number
    qid: string
  }

  export type ListeningQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    qid?: SortOrder
    text?: SortOrder
    options?: SortOrder
    correct?: SortOrder
  }

  export type ListeningQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    scenarioId?: SortOrder
  }

  export type ListeningQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    qid?: SortOrder
    text?: SortOrder
    options?: SortOrder
    correct?: SortOrder
  }

  export type ListeningQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    qid?: SortOrder
    text?: SortOrder
    options?: SortOrder
    correct?: SortOrder
  }

  export type ListeningQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    scenarioId?: SortOrder
  }

  export type WritingTopicCountOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
  }

  export type WritingTopicAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WritingTopicMaxOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
  }

  export type WritingTopicMinOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
  }

  export type WritingTopicSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeakingPromptListRelationFilter = {
    every?: SpeakingPromptWhereInput
    some?: SpeakingPromptWhereInput
    none?: SpeakingPromptWhereInput
  }

  export type SpeakingPromptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpeakingSetCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
  }

  export type SpeakingSetAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeakingSetMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
  }

  export type SpeakingSetMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
  }

  export type SpeakingSetSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeakingSetRelationFilter = {
    is?: SpeakingSetWhereInput
    isNot?: SpeakingSetWhereInput
  }

  export type SpeakingPromptCountOrderByAggregateInput = {
    id?: SortOrder
    setId?: SortOrder
    text?: SortOrder
  }

  export type SpeakingPromptAvgOrderByAggregateInput = {
    id?: SortOrder
    setId?: SortOrder
  }

  export type SpeakingPromptMaxOrderByAggregateInput = {
    id?: SortOrder
    setId?: SortOrder
    text?: SortOrder
  }

  export type SpeakingPromptMinOrderByAggregateInput = {
    id?: SortOrder
    setId?: SortOrder
    text?: SortOrder
  }

  export type SpeakingPromptSumOrderByAggregateInput = {
    id?: SortOrder
    setId?: SortOrder
  }

  export type CheatingEventCountOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    type?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type CheatingEventAvgOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
  }

  export type CheatingEventMaxOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    type?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type CheatingEventMinOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    type?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type CheatingEventSumOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AudioResponseCountOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    promptIndex?: SortOrder
    storageUrl?: SortOrder
    mimeType?: SortOrder
    durationMs?: SortOrder
    asrText?: SortOrder
    asrConfidence?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioResponseAvgOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    promptIndex?: SortOrder
    durationMs?: SortOrder
    asrConfidence?: SortOrder
  }

  export type AudioResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    promptIndex?: SortOrder
    storageUrl?: SortOrder
    mimeType?: SortOrder
    durationMs?: SortOrder
    asrText?: SortOrder
    asrConfidence?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioResponseMinOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    promptIndex?: SortOrder
    storageUrl?: SortOrder
    mimeType?: SortOrder
    durationMs?: SortOrder
    asrText?: SortOrder
    asrConfidence?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioResponseSumOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    promptIndex?: SortOrder
    durationMs?: SortOrder
    asrConfidence?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channel?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channel?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channel?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ExamResultCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamResultCreateWithoutUserInput, ExamResultUncheckedCreateWithoutUserInput> | ExamResultCreateWithoutUserInput[] | ExamResultUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamResultCreateOrConnectWithoutUserInput | ExamResultCreateOrConnectWithoutUserInput[]
    createMany?: ExamResultCreateManyUserInputEnvelope
    connect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
  }

  export type ExamAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput> | ExamAttemptCreateWithoutUserInput[] | ExamAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutUserInput | ExamAttemptCreateOrConnectWithoutUserInput[]
    createMany?: ExamAttemptCreateManyUserInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type ActiveExamCreateNestedOneWithoutUserInput = {
    create?: XOR<ActiveExamCreateWithoutUserInput, ActiveExamUncheckedCreateWithoutUserInput>
    connectOrCreate?: ActiveExamCreateOrConnectWithoutUserInput
    connect?: ActiveExamWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type ExamResultUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamResultCreateWithoutUserInput, ExamResultUncheckedCreateWithoutUserInput> | ExamResultCreateWithoutUserInput[] | ExamResultUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamResultCreateOrConnectWithoutUserInput | ExamResultCreateOrConnectWithoutUserInput[]
    createMany?: ExamResultCreateManyUserInputEnvelope
    connect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
  }

  export type ExamAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput> | ExamAttemptCreateWithoutUserInput[] | ExamAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutUserInput | ExamAttemptCreateOrConnectWithoutUserInput[]
    createMany?: ExamAttemptCreateManyUserInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type ActiveExamUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ActiveExamCreateWithoutUserInput, ActiveExamUncheckedCreateWithoutUserInput>
    connectOrCreate?: ActiveExamCreateOrConnectWithoutUserInput
    connect?: ActiveExamWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ExamResultUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamResultCreateWithoutUserInput, ExamResultUncheckedCreateWithoutUserInput> | ExamResultCreateWithoutUserInput[] | ExamResultUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamResultCreateOrConnectWithoutUserInput | ExamResultCreateOrConnectWithoutUserInput[]
    upsert?: ExamResultUpsertWithWhereUniqueWithoutUserInput | ExamResultUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamResultCreateManyUserInputEnvelope
    set?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    disconnect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    delete?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    connect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    update?: ExamResultUpdateWithWhereUniqueWithoutUserInput | ExamResultUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamResultUpdateManyWithWhereWithoutUserInput | ExamResultUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamResultScalarWhereInput | ExamResultScalarWhereInput[]
  }

  export type ExamAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput> | ExamAttemptCreateWithoutUserInput[] | ExamAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutUserInput | ExamAttemptCreateOrConnectWithoutUserInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutUserInput | ExamAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamAttemptCreateManyUserInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutUserInput | ExamAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutUserInput | ExamAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type ActiveExamUpdateOneWithoutUserNestedInput = {
    create?: XOR<ActiveExamCreateWithoutUserInput, ActiveExamUncheckedCreateWithoutUserInput>
    connectOrCreate?: ActiveExamCreateOrConnectWithoutUserInput
    upsert?: ActiveExamUpsertWithoutUserInput
    disconnect?: ActiveExamWhereInput | boolean
    delete?: ActiveExamWhereInput | boolean
    connect?: ActiveExamWhereUniqueInput
    update?: XOR<XOR<ActiveExamUpdateToOneWithWhereWithoutUserInput, ActiveExamUpdateWithoutUserInput>, ActiveExamUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ExamResultUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamResultCreateWithoutUserInput, ExamResultUncheckedCreateWithoutUserInput> | ExamResultCreateWithoutUserInput[] | ExamResultUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamResultCreateOrConnectWithoutUserInput | ExamResultCreateOrConnectWithoutUserInput[]
    upsert?: ExamResultUpsertWithWhereUniqueWithoutUserInput | ExamResultUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamResultCreateManyUserInputEnvelope
    set?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    disconnect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    delete?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    connect?: ExamResultWhereUniqueInput | ExamResultWhereUniqueInput[]
    update?: ExamResultUpdateWithWhereUniqueWithoutUserInput | ExamResultUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamResultUpdateManyWithWhereWithoutUserInput | ExamResultUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamResultScalarWhereInput | ExamResultScalarWhereInput[]
  }

  export type ExamAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput> | ExamAttemptCreateWithoutUserInput[] | ExamAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutUserInput | ExamAttemptCreateOrConnectWithoutUserInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutUserInput | ExamAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamAttemptCreateManyUserInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutUserInput | ExamAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutUserInput | ExamAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type ActiveExamUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ActiveExamCreateWithoutUserInput, ActiveExamUncheckedCreateWithoutUserInput>
    connectOrCreate?: ActiveExamCreateOrConnectWithoutUserInput
    upsert?: ActiveExamUpsertWithoutUserInput
    disconnect?: ActiveExamWhereInput | boolean
    delete?: ActiveExamWhereInput | boolean
    connect?: ActiveExamWhereUniqueInput
    update?: XOR<XOR<ActiveExamUpdateToOneWithWhereWithoutUserInput, ActiveExamUpdateWithoutUserInput>, ActiveExamUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<UserCreateWithoutAttemptsInput, UserUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttemptsInput
    connect?: UserWhereUniqueInput
  }

  export type ListeningScenarioCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<ListeningScenarioCreateWithoutAttemptsInput, ListeningScenarioUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: ListeningScenarioCreateOrConnectWithoutAttemptsInput
    connect?: ListeningScenarioWhereUniqueInput
  }

  export type WritingTopicCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<WritingTopicCreateWithoutAttemptsInput, WritingTopicUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: WritingTopicCreateOrConnectWithoutAttemptsInput
    connect?: WritingTopicWhereUniqueInput
  }

  export type SpeakingSetCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<SpeakingSetCreateWithoutAttemptsInput, SpeakingSetUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: SpeakingSetCreateOrConnectWithoutAttemptsInput
    connect?: SpeakingSetWhereUniqueInput
  }

  export type ExamResultCreateNestedOneWithoutAttemptInput = {
    create?: XOR<ExamResultCreateWithoutAttemptInput, ExamResultUncheckedCreateWithoutAttemptInput>
    connectOrCreate?: ExamResultCreateOrConnectWithoutAttemptInput
    connect?: ExamResultWhereUniqueInput
  }

  export type CheatingEventCreateNestedManyWithoutAttemptInput = {
    create?: XOR<CheatingEventCreateWithoutAttemptInput, CheatingEventUncheckedCreateWithoutAttemptInput> | CheatingEventCreateWithoutAttemptInput[] | CheatingEventUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: CheatingEventCreateOrConnectWithoutAttemptInput | CheatingEventCreateOrConnectWithoutAttemptInput[]
    createMany?: CheatingEventCreateManyAttemptInputEnvelope
    connect?: CheatingEventWhereUniqueInput | CheatingEventWhereUniqueInput[]
  }

  export type AudioResponseCreateNestedManyWithoutAttemptInput = {
    create?: XOR<AudioResponseCreateWithoutAttemptInput, AudioResponseUncheckedCreateWithoutAttemptInput> | AudioResponseCreateWithoutAttemptInput[] | AudioResponseUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: AudioResponseCreateOrConnectWithoutAttemptInput | AudioResponseCreateOrConnectWithoutAttemptInput[]
    createMany?: AudioResponseCreateManyAttemptInputEnvelope
    connect?: AudioResponseWhereUniqueInput | AudioResponseWhereUniqueInput[]
  }

  export type ActiveExamCreateNestedOneWithoutAttemptInput = {
    create?: XOR<ActiveExamCreateWithoutAttemptInput, ActiveExamUncheckedCreateWithoutAttemptInput>
    connectOrCreate?: ActiveExamCreateOrConnectWithoutAttemptInput
    connect?: ActiveExamWhereUniqueInput
  }

  export type ExamResultUncheckedCreateNestedOneWithoutAttemptInput = {
    create?: XOR<ExamResultCreateWithoutAttemptInput, ExamResultUncheckedCreateWithoutAttemptInput>
    connectOrCreate?: ExamResultCreateOrConnectWithoutAttemptInput
    connect?: ExamResultWhereUniqueInput
  }

  export type CheatingEventUncheckedCreateNestedManyWithoutAttemptInput = {
    create?: XOR<CheatingEventCreateWithoutAttemptInput, CheatingEventUncheckedCreateWithoutAttemptInput> | CheatingEventCreateWithoutAttemptInput[] | CheatingEventUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: CheatingEventCreateOrConnectWithoutAttemptInput | CheatingEventCreateOrConnectWithoutAttemptInput[]
    createMany?: CheatingEventCreateManyAttemptInputEnvelope
    connect?: CheatingEventWhereUniqueInput | CheatingEventWhereUniqueInput[]
  }

  export type AudioResponseUncheckedCreateNestedManyWithoutAttemptInput = {
    create?: XOR<AudioResponseCreateWithoutAttemptInput, AudioResponseUncheckedCreateWithoutAttemptInput> | AudioResponseCreateWithoutAttemptInput[] | AudioResponseUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: AudioResponseCreateOrConnectWithoutAttemptInput | AudioResponseCreateOrConnectWithoutAttemptInput[]
    createMany?: AudioResponseCreateManyAttemptInputEnvelope
    connect?: AudioResponseWhereUniqueInput | AudioResponseWhereUniqueInput[]
  }

  export type ActiveExamUncheckedCreateNestedOneWithoutAttemptInput = {
    create?: XOR<ActiveExamCreateWithoutAttemptInput, ActiveExamUncheckedCreateWithoutAttemptInput>
    connectOrCreate?: ActiveExamCreateOrConnectWithoutAttemptInput
    connect?: ActiveExamWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<UserCreateWithoutAttemptsInput, UserUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttemptsInput
    upsert?: UserUpsertWithoutAttemptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttemptsInput, UserUpdateWithoutAttemptsInput>, UserUncheckedUpdateWithoutAttemptsInput>
  }

  export type ListeningScenarioUpdateOneWithoutAttemptsNestedInput = {
    create?: XOR<ListeningScenarioCreateWithoutAttemptsInput, ListeningScenarioUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: ListeningScenarioCreateOrConnectWithoutAttemptsInput
    upsert?: ListeningScenarioUpsertWithoutAttemptsInput
    disconnect?: ListeningScenarioWhereInput | boolean
    delete?: ListeningScenarioWhereInput | boolean
    connect?: ListeningScenarioWhereUniqueInput
    update?: XOR<XOR<ListeningScenarioUpdateToOneWithWhereWithoutAttemptsInput, ListeningScenarioUpdateWithoutAttemptsInput>, ListeningScenarioUncheckedUpdateWithoutAttemptsInput>
  }

  export type WritingTopicUpdateOneWithoutAttemptsNestedInput = {
    create?: XOR<WritingTopicCreateWithoutAttemptsInput, WritingTopicUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: WritingTopicCreateOrConnectWithoutAttemptsInput
    upsert?: WritingTopicUpsertWithoutAttemptsInput
    disconnect?: WritingTopicWhereInput | boolean
    delete?: WritingTopicWhereInput | boolean
    connect?: WritingTopicWhereUniqueInput
    update?: XOR<XOR<WritingTopicUpdateToOneWithWhereWithoutAttemptsInput, WritingTopicUpdateWithoutAttemptsInput>, WritingTopicUncheckedUpdateWithoutAttemptsInput>
  }

  export type SpeakingSetUpdateOneWithoutAttemptsNestedInput = {
    create?: XOR<SpeakingSetCreateWithoutAttemptsInput, SpeakingSetUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: SpeakingSetCreateOrConnectWithoutAttemptsInput
    upsert?: SpeakingSetUpsertWithoutAttemptsInput
    disconnect?: SpeakingSetWhereInput | boolean
    delete?: SpeakingSetWhereInput | boolean
    connect?: SpeakingSetWhereUniqueInput
    update?: XOR<XOR<SpeakingSetUpdateToOneWithWhereWithoutAttemptsInput, SpeakingSetUpdateWithoutAttemptsInput>, SpeakingSetUncheckedUpdateWithoutAttemptsInput>
  }

  export type ExamResultUpdateOneWithoutAttemptNestedInput = {
    create?: XOR<ExamResultCreateWithoutAttemptInput, ExamResultUncheckedCreateWithoutAttemptInput>
    connectOrCreate?: ExamResultCreateOrConnectWithoutAttemptInput
    upsert?: ExamResultUpsertWithoutAttemptInput
    disconnect?: ExamResultWhereInput | boolean
    delete?: ExamResultWhereInput | boolean
    connect?: ExamResultWhereUniqueInput
    update?: XOR<XOR<ExamResultUpdateToOneWithWhereWithoutAttemptInput, ExamResultUpdateWithoutAttemptInput>, ExamResultUncheckedUpdateWithoutAttemptInput>
  }

  export type CheatingEventUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<CheatingEventCreateWithoutAttemptInput, CheatingEventUncheckedCreateWithoutAttemptInput> | CheatingEventCreateWithoutAttemptInput[] | CheatingEventUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: CheatingEventCreateOrConnectWithoutAttemptInput | CheatingEventCreateOrConnectWithoutAttemptInput[]
    upsert?: CheatingEventUpsertWithWhereUniqueWithoutAttemptInput | CheatingEventUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: CheatingEventCreateManyAttemptInputEnvelope
    set?: CheatingEventWhereUniqueInput | CheatingEventWhereUniqueInput[]
    disconnect?: CheatingEventWhereUniqueInput | CheatingEventWhereUniqueInput[]
    delete?: CheatingEventWhereUniqueInput | CheatingEventWhereUniqueInput[]
    connect?: CheatingEventWhereUniqueInput | CheatingEventWhereUniqueInput[]
    update?: CheatingEventUpdateWithWhereUniqueWithoutAttemptInput | CheatingEventUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: CheatingEventUpdateManyWithWhereWithoutAttemptInput | CheatingEventUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: CheatingEventScalarWhereInput | CheatingEventScalarWhereInput[]
  }

  export type AudioResponseUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<AudioResponseCreateWithoutAttemptInput, AudioResponseUncheckedCreateWithoutAttemptInput> | AudioResponseCreateWithoutAttemptInput[] | AudioResponseUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: AudioResponseCreateOrConnectWithoutAttemptInput | AudioResponseCreateOrConnectWithoutAttemptInput[]
    upsert?: AudioResponseUpsertWithWhereUniqueWithoutAttemptInput | AudioResponseUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: AudioResponseCreateManyAttemptInputEnvelope
    set?: AudioResponseWhereUniqueInput | AudioResponseWhereUniqueInput[]
    disconnect?: AudioResponseWhereUniqueInput | AudioResponseWhereUniqueInput[]
    delete?: AudioResponseWhereUniqueInput | AudioResponseWhereUniqueInput[]
    connect?: AudioResponseWhereUniqueInput | AudioResponseWhereUniqueInput[]
    update?: AudioResponseUpdateWithWhereUniqueWithoutAttemptInput | AudioResponseUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: AudioResponseUpdateManyWithWhereWithoutAttemptInput | AudioResponseUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: AudioResponseScalarWhereInput | AudioResponseScalarWhereInput[]
  }

  export type ActiveExamUpdateOneWithoutAttemptNestedInput = {
    create?: XOR<ActiveExamCreateWithoutAttemptInput, ActiveExamUncheckedCreateWithoutAttemptInput>
    connectOrCreate?: ActiveExamCreateOrConnectWithoutAttemptInput
    upsert?: ActiveExamUpsertWithoutAttemptInput
    disconnect?: ActiveExamWhereInput | boolean
    delete?: ActiveExamWhereInput | boolean
    connect?: ActiveExamWhereUniqueInput
    update?: XOR<XOR<ActiveExamUpdateToOneWithWhereWithoutAttemptInput, ActiveExamUpdateWithoutAttemptInput>, ActiveExamUncheckedUpdateWithoutAttemptInput>
  }

  export type ExamResultUncheckedUpdateOneWithoutAttemptNestedInput = {
    create?: XOR<ExamResultCreateWithoutAttemptInput, ExamResultUncheckedCreateWithoutAttemptInput>
    connectOrCreate?: ExamResultCreateOrConnectWithoutAttemptInput
    upsert?: ExamResultUpsertWithoutAttemptInput
    disconnect?: ExamResultWhereInput | boolean
    delete?: ExamResultWhereInput | boolean
    connect?: ExamResultWhereUniqueInput
    update?: XOR<XOR<ExamResultUpdateToOneWithWhereWithoutAttemptInput, ExamResultUpdateWithoutAttemptInput>, ExamResultUncheckedUpdateWithoutAttemptInput>
  }

  export type CheatingEventUncheckedUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<CheatingEventCreateWithoutAttemptInput, CheatingEventUncheckedCreateWithoutAttemptInput> | CheatingEventCreateWithoutAttemptInput[] | CheatingEventUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: CheatingEventCreateOrConnectWithoutAttemptInput | CheatingEventCreateOrConnectWithoutAttemptInput[]
    upsert?: CheatingEventUpsertWithWhereUniqueWithoutAttemptInput | CheatingEventUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: CheatingEventCreateManyAttemptInputEnvelope
    set?: CheatingEventWhereUniqueInput | CheatingEventWhereUniqueInput[]
    disconnect?: CheatingEventWhereUniqueInput | CheatingEventWhereUniqueInput[]
    delete?: CheatingEventWhereUniqueInput | CheatingEventWhereUniqueInput[]
    connect?: CheatingEventWhereUniqueInput | CheatingEventWhereUniqueInput[]
    update?: CheatingEventUpdateWithWhereUniqueWithoutAttemptInput | CheatingEventUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: CheatingEventUpdateManyWithWhereWithoutAttemptInput | CheatingEventUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: CheatingEventScalarWhereInput | CheatingEventScalarWhereInput[]
  }

  export type AudioResponseUncheckedUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<AudioResponseCreateWithoutAttemptInput, AudioResponseUncheckedCreateWithoutAttemptInput> | AudioResponseCreateWithoutAttemptInput[] | AudioResponseUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: AudioResponseCreateOrConnectWithoutAttemptInput | AudioResponseCreateOrConnectWithoutAttemptInput[]
    upsert?: AudioResponseUpsertWithWhereUniqueWithoutAttemptInput | AudioResponseUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: AudioResponseCreateManyAttemptInputEnvelope
    set?: AudioResponseWhereUniqueInput | AudioResponseWhereUniqueInput[]
    disconnect?: AudioResponseWhereUniqueInput | AudioResponseWhereUniqueInput[]
    delete?: AudioResponseWhereUniqueInput | AudioResponseWhereUniqueInput[]
    connect?: AudioResponseWhereUniqueInput | AudioResponseWhereUniqueInput[]
    update?: AudioResponseUpdateWithWhereUniqueWithoutAttemptInput | AudioResponseUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: AudioResponseUpdateManyWithWhereWithoutAttemptInput | AudioResponseUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: AudioResponseScalarWhereInput | AudioResponseScalarWhereInput[]
  }

  export type ActiveExamUncheckedUpdateOneWithoutAttemptNestedInput = {
    create?: XOR<ActiveExamCreateWithoutAttemptInput, ActiveExamUncheckedCreateWithoutAttemptInput>
    connectOrCreate?: ActiveExamCreateOrConnectWithoutAttemptInput
    upsert?: ActiveExamUpsertWithoutAttemptInput
    disconnect?: ActiveExamWhereInput | boolean
    delete?: ActiveExamWhereInput | boolean
    connect?: ActiveExamWhereUniqueInput
    update?: XOR<XOR<ActiveExamUpdateToOneWithWhereWithoutAttemptInput, ActiveExamUpdateWithoutAttemptInput>, ActiveExamUncheckedUpdateWithoutAttemptInput>
  }

  export type UserCreateNestedOneWithoutActiveExamInput = {
    create?: XOR<UserCreateWithoutActiveExamInput, UserUncheckedCreateWithoutActiveExamInput>
    connectOrCreate?: UserCreateOrConnectWithoutActiveExamInput
    connect?: UserWhereUniqueInput
  }

  export type ExamAttemptCreateNestedOneWithoutActiveExamInput = {
    create?: XOR<ExamAttemptCreateWithoutActiveExamInput, ExamAttemptUncheckedCreateWithoutActiveExamInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutActiveExamInput
    connect?: ExamAttemptWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActiveExamNestedInput = {
    create?: XOR<UserCreateWithoutActiveExamInput, UserUncheckedCreateWithoutActiveExamInput>
    connectOrCreate?: UserCreateOrConnectWithoutActiveExamInput
    upsert?: UserUpsertWithoutActiveExamInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActiveExamInput, UserUpdateWithoutActiveExamInput>, UserUncheckedUpdateWithoutActiveExamInput>
  }

  export type ExamAttemptUpdateOneRequiredWithoutActiveExamNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutActiveExamInput, ExamAttemptUncheckedCreateWithoutActiveExamInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutActiveExamInput
    upsert?: ExamAttemptUpsertWithoutActiveExamInput
    connect?: ExamAttemptWhereUniqueInput
    update?: XOR<XOR<ExamAttemptUpdateToOneWithWhereWithoutActiveExamInput, ExamAttemptUpdateWithoutActiveExamInput>, ExamAttemptUncheckedUpdateWithoutActiveExamInput>
  }

  export type UserCreateNestedOneWithoutExamResultsInput = {
    create?: XOR<UserCreateWithoutExamResultsInput, UserUncheckedCreateWithoutExamResultsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExamResultsInput
    connect?: UserWhereUniqueInput
  }

  export type ExamAttemptCreateNestedOneWithoutResultInput = {
    create?: XOR<ExamAttemptCreateWithoutResultInput, ExamAttemptUncheckedCreateWithoutResultInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutResultInput
    connect?: ExamAttemptWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutExamResultsNestedInput = {
    create?: XOR<UserCreateWithoutExamResultsInput, UserUncheckedCreateWithoutExamResultsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExamResultsInput
    upsert?: UserUpsertWithoutExamResultsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExamResultsInput, UserUpdateWithoutExamResultsInput>, UserUncheckedUpdateWithoutExamResultsInput>
  }

  export type ExamAttemptUpdateOneRequiredWithoutResultNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutResultInput, ExamAttemptUncheckedCreateWithoutResultInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutResultInput
    upsert?: ExamAttemptUpsertWithoutResultInput
    connect?: ExamAttemptWhereUniqueInput
    update?: XOR<XOR<ExamAttemptUpdateToOneWithWhereWithoutResultInput, ExamAttemptUpdateWithoutResultInput>, ExamAttemptUncheckedUpdateWithoutResultInput>
  }

  export type ListeningQuestionCreateNestedManyWithoutScenarioInput = {
    create?: XOR<ListeningQuestionCreateWithoutScenarioInput, ListeningQuestionUncheckedCreateWithoutScenarioInput> | ListeningQuestionCreateWithoutScenarioInput[] | ListeningQuestionUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: ListeningQuestionCreateOrConnectWithoutScenarioInput | ListeningQuestionCreateOrConnectWithoutScenarioInput[]
    createMany?: ListeningQuestionCreateManyScenarioInputEnvelope
    connect?: ListeningQuestionWhereUniqueInput | ListeningQuestionWhereUniqueInput[]
  }

  export type ExamAttemptCreateNestedManyWithoutListeningScenarioInput = {
    create?: XOR<ExamAttemptCreateWithoutListeningScenarioInput, ExamAttemptUncheckedCreateWithoutListeningScenarioInput> | ExamAttemptCreateWithoutListeningScenarioInput[] | ExamAttemptUncheckedCreateWithoutListeningScenarioInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutListeningScenarioInput | ExamAttemptCreateOrConnectWithoutListeningScenarioInput[]
    createMany?: ExamAttemptCreateManyListeningScenarioInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type ListeningQuestionUncheckedCreateNestedManyWithoutScenarioInput = {
    create?: XOR<ListeningQuestionCreateWithoutScenarioInput, ListeningQuestionUncheckedCreateWithoutScenarioInput> | ListeningQuestionCreateWithoutScenarioInput[] | ListeningQuestionUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: ListeningQuestionCreateOrConnectWithoutScenarioInput | ListeningQuestionCreateOrConnectWithoutScenarioInput[]
    createMany?: ListeningQuestionCreateManyScenarioInputEnvelope
    connect?: ListeningQuestionWhereUniqueInput | ListeningQuestionWhereUniqueInput[]
  }

  export type ExamAttemptUncheckedCreateNestedManyWithoutListeningScenarioInput = {
    create?: XOR<ExamAttemptCreateWithoutListeningScenarioInput, ExamAttemptUncheckedCreateWithoutListeningScenarioInput> | ExamAttemptCreateWithoutListeningScenarioInput[] | ExamAttemptUncheckedCreateWithoutListeningScenarioInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutListeningScenarioInput | ExamAttemptCreateOrConnectWithoutListeningScenarioInput[]
    createMany?: ExamAttemptCreateManyListeningScenarioInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type ListeningQuestionUpdateManyWithoutScenarioNestedInput = {
    create?: XOR<ListeningQuestionCreateWithoutScenarioInput, ListeningQuestionUncheckedCreateWithoutScenarioInput> | ListeningQuestionCreateWithoutScenarioInput[] | ListeningQuestionUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: ListeningQuestionCreateOrConnectWithoutScenarioInput | ListeningQuestionCreateOrConnectWithoutScenarioInput[]
    upsert?: ListeningQuestionUpsertWithWhereUniqueWithoutScenarioInput | ListeningQuestionUpsertWithWhereUniqueWithoutScenarioInput[]
    createMany?: ListeningQuestionCreateManyScenarioInputEnvelope
    set?: ListeningQuestionWhereUniqueInput | ListeningQuestionWhereUniqueInput[]
    disconnect?: ListeningQuestionWhereUniqueInput | ListeningQuestionWhereUniqueInput[]
    delete?: ListeningQuestionWhereUniqueInput | ListeningQuestionWhereUniqueInput[]
    connect?: ListeningQuestionWhereUniqueInput | ListeningQuestionWhereUniqueInput[]
    update?: ListeningQuestionUpdateWithWhereUniqueWithoutScenarioInput | ListeningQuestionUpdateWithWhereUniqueWithoutScenarioInput[]
    updateMany?: ListeningQuestionUpdateManyWithWhereWithoutScenarioInput | ListeningQuestionUpdateManyWithWhereWithoutScenarioInput[]
    deleteMany?: ListeningQuestionScalarWhereInput | ListeningQuestionScalarWhereInput[]
  }

  export type ExamAttemptUpdateManyWithoutListeningScenarioNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutListeningScenarioInput, ExamAttemptUncheckedCreateWithoutListeningScenarioInput> | ExamAttemptCreateWithoutListeningScenarioInput[] | ExamAttemptUncheckedCreateWithoutListeningScenarioInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutListeningScenarioInput | ExamAttemptCreateOrConnectWithoutListeningScenarioInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutListeningScenarioInput | ExamAttemptUpsertWithWhereUniqueWithoutListeningScenarioInput[]
    createMany?: ExamAttemptCreateManyListeningScenarioInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutListeningScenarioInput | ExamAttemptUpdateWithWhereUniqueWithoutListeningScenarioInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutListeningScenarioInput | ExamAttemptUpdateManyWithWhereWithoutListeningScenarioInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type ListeningQuestionUncheckedUpdateManyWithoutScenarioNestedInput = {
    create?: XOR<ListeningQuestionCreateWithoutScenarioInput, ListeningQuestionUncheckedCreateWithoutScenarioInput> | ListeningQuestionCreateWithoutScenarioInput[] | ListeningQuestionUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: ListeningQuestionCreateOrConnectWithoutScenarioInput | ListeningQuestionCreateOrConnectWithoutScenarioInput[]
    upsert?: ListeningQuestionUpsertWithWhereUniqueWithoutScenarioInput | ListeningQuestionUpsertWithWhereUniqueWithoutScenarioInput[]
    createMany?: ListeningQuestionCreateManyScenarioInputEnvelope
    set?: ListeningQuestionWhereUniqueInput | ListeningQuestionWhereUniqueInput[]
    disconnect?: ListeningQuestionWhereUniqueInput | ListeningQuestionWhereUniqueInput[]
    delete?: ListeningQuestionWhereUniqueInput | ListeningQuestionWhereUniqueInput[]
    connect?: ListeningQuestionWhereUniqueInput | ListeningQuestionWhereUniqueInput[]
    update?: ListeningQuestionUpdateWithWhereUniqueWithoutScenarioInput | ListeningQuestionUpdateWithWhereUniqueWithoutScenarioInput[]
    updateMany?: ListeningQuestionUpdateManyWithWhereWithoutScenarioInput | ListeningQuestionUpdateManyWithWhereWithoutScenarioInput[]
    deleteMany?: ListeningQuestionScalarWhereInput | ListeningQuestionScalarWhereInput[]
  }

  export type ExamAttemptUncheckedUpdateManyWithoutListeningScenarioNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutListeningScenarioInput, ExamAttemptUncheckedCreateWithoutListeningScenarioInput> | ExamAttemptCreateWithoutListeningScenarioInput[] | ExamAttemptUncheckedCreateWithoutListeningScenarioInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutListeningScenarioInput | ExamAttemptCreateOrConnectWithoutListeningScenarioInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutListeningScenarioInput | ExamAttemptUpsertWithWhereUniqueWithoutListeningScenarioInput[]
    createMany?: ExamAttemptCreateManyListeningScenarioInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutListeningScenarioInput | ExamAttemptUpdateWithWhereUniqueWithoutListeningScenarioInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutListeningScenarioInput | ExamAttemptUpdateManyWithWhereWithoutListeningScenarioInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type ListeningScenarioCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<ListeningScenarioCreateWithoutQuestionsInput, ListeningScenarioUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ListeningScenarioCreateOrConnectWithoutQuestionsInput
    connect?: ListeningScenarioWhereUniqueInput
  }

  export type ListeningScenarioUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<ListeningScenarioCreateWithoutQuestionsInput, ListeningScenarioUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ListeningScenarioCreateOrConnectWithoutQuestionsInput
    upsert?: ListeningScenarioUpsertWithoutQuestionsInput
    connect?: ListeningScenarioWhereUniqueInput
    update?: XOR<XOR<ListeningScenarioUpdateToOneWithWhereWithoutQuestionsInput, ListeningScenarioUpdateWithoutQuestionsInput>, ListeningScenarioUncheckedUpdateWithoutQuestionsInput>
  }

  export type ExamAttemptCreateNestedManyWithoutWritingTopicInput = {
    create?: XOR<ExamAttemptCreateWithoutWritingTopicInput, ExamAttemptUncheckedCreateWithoutWritingTopicInput> | ExamAttemptCreateWithoutWritingTopicInput[] | ExamAttemptUncheckedCreateWithoutWritingTopicInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutWritingTopicInput | ExamAttemptCreateOrConnectWithoutWritingTopicInput[]
    createMany?: ExamAttemptCreateManyWritingTopicInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type ExamAttemptUncheckedCreateNestedManyWithoutWritingTopicInput = {
    create?: XOR<ExamAttemptCreateWithoutWritingTopicInput, ExamAttemptUncheckedCreateWithoutWritingTopicInput> | ExamAttemptCreateWithoutWritingTopicInput[] | ExamAttemptUncheckedCreateWithoutWritingTopicInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutWritingTopicInput | ExamAttemptCreateOrConnectWithoutWritingTopicInput[]
    createMany?: ExamAttemptCreateManyWritingTopicInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type ExamAttemptUpdateManyWithoutWritingTopicNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutWritingTopicInput, ExamAttemptUncheckedCreateWithoutWritingTopicInput> | ExamAttemptCreateWithoutWritingTopicInput[] | ExamAttemptUncheckedCreateWithoutWritingTopicInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutWritingTopicInput | ExamAttemptCreateOrConnectWithoutWritingTopicInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutWritingTopicInput | ExamAttemptUpsertWithWhereUniqueWithoutWritingTopicInput[]
    createMany?: ExamAttemptCreateManyWritingTopicInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutWritingTopicInput | ExamAttemptUpdateWithWhereUniqueWithoutWritingTopicInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutWritingTopicInput | ExamAttemptUpdateManyWithWhereWithoutWritingTopicInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type ExamAttemptUncheckedUpdateManyWithoutWritingTopicNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutWritingTopicInput, ExamAttemptUncheckedCreateWithoutWritingTopicInput> | ExamAttemptCreateWithoutWritingTopicInput[] | ExamAttemptUncheckedCreateWithoutWritingTopicInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutWritingTopicInput | ExamAttemptCreateOrConnectWithoutWritingTopicInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutWritingTopicInput | ExamAttemptUpsertWithWhereUniqueWithoutWritingTopicInput[]
    createMany?: ExamAttemptCreateManyWritingTopicInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutWritingTopicInput | ExamAttemptUpdateWithWhereUniqueWithoutWritingTopicInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutWritingTopicInput | ExamAttemptUpdateManyWithWhereWithoutWritingTopicInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type SpeakingPromptCreateNestedManyWithoutSetInput = {
    create?: XOR<SpeakingPromptCreateWithoutSetInput, SpeakingPromptUncheckedCreateWithoutSetInput> | SpeakingPromptCreateWithoutSetInput[] | SpeakingPromptUncheckedCreateWithoutSetInput[]
    connectOrCreate?: SpeakingPromptCreateOrConnectWithoutSetInput | SpeakingPromptCreateOrConnectWithoutSetInput[]
    createMany?: SpeakingPromptCreateManySetInputEnvelope
    connect?: SpeakingPromptWhereUniqueInput | SpeakingPromptWhereUniqueInput[]
  }

  export type ExamAttemptCreateNestedManyWithoutSpeakingSetInput = {
    create?: XOR<ExamAttemptCreateWithoutSpeakingSetInput, ExamAttemptUncheckedCreateWithoutSpeakingSetInput> | ExamAttemptCreateWithoutSpeakingSetInput[] | ExamAttemptUncheckedCreateWithoutSpeakingSetInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutSpeakingSetInput | ExamAttemptCreateOrConnectWithoutSpeakingSetInput[]
    createMany?: ExamAttemptCreateManySpeakingSetInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type SpeakingPromptUncheckedCreateNestedManyWithoutSetInput = {
    create?: XOR<SpeakingPromptCreateWithoutSetInput, SpeakingPromptUncheckedCreateWithoutSetInput> | SpeakingPromptCreateWithoutSetInput[] | SpeakingPromptUncheckedCreateWithoutSetInput[]
    connectOrCreate?: SpeakingPromptCreateOrConnectWithoutSetInput | SpeakingPromptCreateOrConnectWithoutSetInput[]
    createMany?: SpeakingPromptCreateManySetInputEnvelope
    connect?: SpeakingPromptWhereUniqueInput | SpeakingPromptWhereUniqueInput[]
  }

  export type ExamAttemptUncheckedCreateNestedManyWithoutSpeakingSetInput = {
    create?: XOR<ExamAttemptCreateWithoutSpeakingSetInput, ExamAttemptUncheckedCreateWithoutSpeakingSetInput> | ExamAttemptCreateWithoutSpeakingSetInput[] | ExamAttemptUncheckedCreateWithoutSpeakingSetInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutSpeakingSetInput | ExamAttemptCreateOrConnectWithoutSpeakingSetInput[]
    createMany?: ExamAttemptCreateManySpeakingSetInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type SpeakingPromptUpdateManyWithoutSetNestedInput = {
    create?: XOR<SpeakingPromptCreateWithoutSetInput, SpeakingPromptUncheckedCreateWithoutSetInput> | SpeakingPromptCreateWithoutSetInput[] | SpeakingPromptUncheckedCreateWithoutSetInput[]
    connectOrCreate?: SpeakingPromptCreateOrConnectWithoutSetInput | SpeakingPromptCreateOrConnectWithoutSetInput[]
    upsert?: SpeakingPromptUpsertWithWhereUniqueWithoutSetInput | SpeakingPromptUpsertWithWhereUniqueWithoutSetInput[]
    createMany?: SpeakingPromptCreateManySetInputEnvelope
    set?: SpeakingPromptWhereUniqueInput | SpeakingPromptWhereUniqueInput[]
    disconnect?: SpeakingPromptWhereUniqueInput | SpeakingPromptWhereUniqueInput[]
    delete?: SpeakingPromptWhereUniqueInput | SpeakingPromptWhereUniqueInput[]
    connect?: SpeakingPromptWhereUniqueInput | SpeakingPromptWhereUniqueInput[]
    update?: SpeakingPromptUpdateWithWhereUniqueWithoutSetInput | SpeakingPromptUpdateWithWhereUniqueWithoutSetInput[]
    updateMany?: SpeakingPromptUpdateManyWithWhereWithoutSetInput | SpeakingPromptUpdateManyWithWhereWithoutSetInput[]
    deleteMany?: SpeakingPromptScalarWhereInput | SpeakingPromptScalarWhereInput[]
  }

  export type ExamAttemptUpdateManyWithoutSpeakingSetNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutSpeakingSetInput, ExamAttemptUncheckedCreateWithoutSpeakingSetInput> | ExamAttemptCreateWithoutSpeakingSetInput[] | ExamAttemptUncheckedCreateWithoutSpeakingSetInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutSpeakingSetInput | ExamAttemptCreateOrConnectWithoutSpeakingSetInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutSpeakingSetInput | ExamAttemptUpsertWithWhereUniqueWithoutSpeakingSetInput[]
    createMany?: ExamAttemptCreateManySpeakingSetInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutSpeakingSetInput | ExamAttemptUpdateWithWhereUniqueWithoutSpeakingSetInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutSpeakingSetInput | ExamAttemptUpdateManyWithWhereWithoutSpeakingSetInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type SpeakingPromptUncheckedUpdateManyWithoutSetNestedInput = {
    create?: XOR<SpeakingPromptCreateWithoutSetInput, SpeakingPromptUncheckedCreateWithoutSetInput> | SpeakingPromptCreateWithoutSetInput[] | SpeakingPromptUncheckedCreateWithoutSetInput[]
    connectOrCreate?: SpeakingPromptCreateOrConnectWithoutSetInput | SpeakingPromptCreateOrConnectWithoutSetInput[]
    upsert?: SpeakingPromptUpsertWithWhereUniqueWithoutSetInput | SpeakingPromptUpsertWithWhereUniqueWithoutSetInput[]
    createMany?: SpeakingPromptCreateManySetInputEnvelope
    set?: SpeakingPromptWhereUniqueInput | SpeakingPromptWhereUniqueInput[]
    disconnect?: SpeakingPromptWhereUniqueInput | SpeakingPromptWhereUniqueInput[]
    delete?: SpeakingPromptWhereUniqueInput | SpeakingPromptWhereUniqueInput[]
    connect?: SpeakingPromptWhereUniqueInput | SpeakingPromptWhereUniqueInput[]
    update?: SpeakingPromptUpdateWithWhereUniqueWithoutSetInput | SpeakingPromptUpdateWithWhereUniqueWithoutSetInput[]
    updateMany?: SpeakingPromptUpdateManyWithWhereWithoutSetInput | SpeakingPromptUpdateManyWithWhereWithoutSetInput[]
    deleteMany?: SpeakingPromptScalarWhereInput | SpeakingPromptScalarWhereInput[]
  }

  export type ExamAttemptUncheckedUpdateManyWithoutSpeakingSetNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutSpeakingSetInput, ExamAttemptUncheckedCreateWithoutSpeakingSetInput> | ExamAttemptCreateWithoutSpeakingSetInput[] | ExamAttemptUncheckedCreateWithoutSpeakingSetInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutSpeakingSetInput | ExamAttemptCreateOrConnectWithoutSpeakingSetInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutSpeakingSetInput | ExamAttemptUpsertWithWhereUniqueWithoutSpeakingSetInput[]
    createMany?: ExamAttemptCreateManySpeakingSetInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutSpeakingSetInput | ExamAttemptUpdateWithWhereUniqueWithoutSpeakingSetInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutSpeakingSetInput | ExamAttemptUpdateManyWithWhereWithoutSpeakingSetInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type SpeakingSetCreateNestedOneWithoutPromptsInput = {
    create?: XOR<SpeakingSetCreateWithoutPromptsInput, SpeakingSetUncheckedCreateWithoutPromptsInput>
    connectOrCreate?: SpeakingSetCreateOrConnectWithoutPromptsInput
    connect?: SpeakingSetWhereUniqueInput
  }

  export type SpeakingSetUpdateOneRequiredWithoutPromptsNestedInput = {
    create?: XOR<SpeakingSetCreateWithoutPromptsInput, SpeakingSetUncheckedCreateWithoutPromptsInput>
    connectOrCreate?: SpeakingSetCreateOrConnectWithoutPromptsInput
    upsert?: SpeakingSetUpsertWithoutPromptsInput
    connect?: SpeakingSetWhereUniqueInput
    update?: XOR<XOR<SpeakingSetUpdateToOneWithWhereWithoutPromptsInput, SpeakingSetUpdateWithoutPromptsInput>, SpeakingSetUncheckedUpdateWithoutPromptsInput>
  }

  export type ExamAttemptCreateNestedOneWithoutCheatingEventsInput = {
    create?: XOR<ExamAttemptCreateWithoutCheatingEventsInput, ExamAttemptUncheckedCreateWithoutCheatingEventsInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutCheatingEventsInput
    connect?: ExamAttemptWhereUniqueInput
  }

  export type ExamAttemptUpdateOneRequiredWithoutCheatingEventsNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutCheatingEventsInput, ExamAttemptUncheckedCreateWithoutCheatingEventsInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutCheatingEventsInput
    upsert?: ExamAttemptUpsertWithoutCheatingEventsInput
    connect?: ExamAttemptWhereUniqueInput
    update?: XOR<XOR<ExamAttemptUpdateToOneWithWhereWithoutCheatingEventsInput, ExamAttemptUpdateWithoutCheatingEventsInput>, ExamAttemptUncheckedUpdateWithoutCheatingEventsInput>
  }

  export type ExamAttemptCreateNestedOneWithoutAudioResponsesInput = {
    create?: XOR<ExamAttemptCreateWithoutAudioResponsesInput, ExamAttemptUncheckedCreateWithoutAudioResponsesInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutAudioResponsesInput
    connect?: ExamAttemptWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ExamAttemptUpdateOneRequiredWithoutAudioResponsesNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutAudioResponsesInput, ExamAttemptUncheckedCreateWithoutAudioResponsesInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutAudioResponsesInput
    upsert?: ExamAttemptUpsertWithoutAudioResponsesInput
    connect?: ExamAttemptWhereUniqueInput
    update?: XOR<XOR<ExamAttemptUpdateToOneWithWhereWithoutAudioResponsesInput, ExamAttemptUpdateWithoutAudioResponsesInput>, ExamAttemptUncheckedUpdateWithoutAudioResponsesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutResetTokensInput = {
    create?: XOR<UserCreateWithoutResetTokensInput, UserUncheckedCreateWithoutResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutResetTokensInput, UserUncheckedCreateWithoutResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutResetTokensInput
    upsert?: UserUpsertWithoutResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResetTokensInput, UserUpdateWithoutResetTokensInput>, UserUncheckedUpdateWithoutResetTokensInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ExamResultCreateWithoutUserInput = {
    score: number
    grammarScore: number
    writingScore: number
    speakingScore: number
    listeningScore: number
    level?: string
    createdAt?: Date | string
    attempt: ExamAttemptCreateNestedOneWithoutResultInput
  }

  export type ExamResultUncheckedCreateWithoutUserInput = {
    id?: number
    attemptId: number
    score: number
    grammarScore: number
    writingScore: number
    speakingScore: number
    listeningScore: number
    level?: string
    createdAt?: Date | string
  }

  export type ExamResultCreateOrConnectWithoutUserInput = {
    where: ExamResultWhereUniqueInput
    create: XOR<ExamResultCreateWithoutUserInput, ExamResultUncheckedCreateWithoutUserInput>
  }

  export type ExamResultCreateManyUserInputEnvelope = {
    data: ExamResultCreateManyUserInput | ExamResultCreateManyUserInput[]
  }

  export type ExamAttemptCreateWithoutUserInput = {
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    listeningScenario?: ListeningScenarioCreateNestedOneWithoutAttemptsInput
    writingTopic?: WritingTopicCreateNestedOneWithoutAttemptsInput
    speakingSet?: SpeakingSetCreateNestedOneWithoutAttemptsInput
    result?: ExamResultCreateNestedOneWithoutAttemptInput
    cheatingEvents?: CheatingEventCreateNestedManyWithoutAttemptInput
    audioResponses?: AudioResponseCreateNestedManyWithoutAttemptInput
    activeExam?: ActiveExamCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutUserInput = {
    id?: number
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    listeningScenarioId?: number | null
    writingTopicId?: number | null
    speakingSetId?: number | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    result?: ExamResultUncheckedCreateNestedOneWithoutAttemptInput
    cheatingEvents?: CheatingEventUncheckedCreateNestedManyWithoutAttemptInput
    audioResponses?: AudioResponseUncheckedCreateNestedManyWithoutAttemptInput
    activeExam?: ActiveExamUncheckedCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutUserInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput>
  }

  export type ExamAttemptCreateManyUserInputEnvelope = {
    data: ExamAttemptCreateManyUserInput | ExamAttemptCreateManyUserInput[]
  }

  export type ActiveExamCreateWithoutUserInput = {
    createdAt?: Date | string
    mcqCorrect: string
    listeningCorrect: string
    attempt: ExamAttemptCreateNestedOneWithoutActiveExamInput
  }

  export type ActiveExamUncheckedCreateWithoutUserInput = {
    attemptId: number
    createdAt?: Date | string
    mcqCorrect: string
    listeningCorrect: string
  }

  export type ActiveExamCreateOrConnectWithoutUserInput = {
    where: ActiveExamWhereUniqueInput
    create: XOR<ActiveExamCreateWithoutUserInput, ActiveExamUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutUserInput = {
    channel: string
    type: string
    title: string
    message: string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    channel: string
    type: string
    title: string
    message: string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
  }

  export type ExamResultUpsertWithWhereUniqueWithoutUserInput = {
    where: ExamResultWhereUniqueInput
    update: XOR<ExamResultUpdateWithoutUserInput, ExamResultUncheckedUpdateWithoutUserInput>
    create: XOR<ExamResultCreateWithoutUserInput, ExamResultUncheckedCreateWithoutUserInput>
  }

  export type ExamResultUpdateWithWhereUniqueWithoutUserInput = {
    where: ExamResultWhereUniqueInput
    data: XOR<ExamResultUpdateWithoutUserInput, ExamResultUncheckedUpdateWithoutUserInput>
  }

  export type ExamResultUpdateManyWithWhereWithoutUserInput = {
    where: ExamResultScalarWhereInput
    data: XOR<ExamResultUpdateManyMutationInput, ExamResultUncheckedUpdateManyWithoutUserInput>
  }

  export type ExamResultScalarWhereInput = {
    AND?: ExamResultScalarWhereInput | ExamResultScalarWhereInput[]
    OR?: ExamResultScalarWhereInput[]
    NOT?: ExamResultScalarWhereInput | ExamResultScalarWhereInput[]
    id?: IntFilter<"ExamResult"> | number
    attemptId?: IntFilter<"ExamResult"> | number
    userId?: IntFilter<"ExamResult"> | number
    score?: IntFilter<"ExamResult"> | number
    grammarScore?: IntFilter<"ExamResult"> | number
    writingScore?: IntFilter<"ExamResult"> | number
    speakingScore?: IntFilter<"ExamResult"> | number
    listeningScore?: IntFilter<"ExamResult"> | number
    level?: StringFilter<"ExamResult"> | string
    createdAt?: DateTimeFilter<"ExamResult"> | Date | string
  }

  export type ExamAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: ExamAttemptWhereUniqueInput
    update: XOR<ExamAttemptUpdateWithoutUserInput, ExamAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput>
  }

  export type ExamAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: ExamAttemptWhereUniqueInput
    data: XOR<ExamAttemptUpdateWithoutUserInput, ExamAttemptUncheckedUpdateWithoutUserInput>
  }

  export type ExamAttemptUpdateManyWithWhereWithoutUserInput = {
    where: ExamAttemptScalarWhereInput
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type ExamAttemptScalarWhereInput = {
    AND?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
    OR?: ExamAttemptScalarWhereInput[]
    NOT?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
    id?: IntFilter<"ExamAttempt"> | number
    userId?: IntFilter<"ExamAttempt"> | number
    status?: StringFilter<"ExamAttempt"> | string
    createdAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"ExamAttempt"> | Date | string | null
    mcqQuestionIds?: StringNullableFilter<"ExamAttempt"> | string | null
    listeningScenarioId?: IntNullableFilter<"ExamAttempt"> | number | null
    writingTopicId?: IntNullableFilter<"ExamAttempt"> | number | null
    speakingSetId?: IntNullableFilter<"ExamAttempt"> | number | null
    mcqAnswers?: StringNullableFilter<"ExamAttempt"> | string | null
    listeningAnswers?: StringNullableFilter<"ExamAttempt"> | string | null
    writingAnswer?: StringNullableFilter<"ExamAttempt"> | string | null
    speakingTranscript?: StringNullableFilter<"ExamAttempt"> | string | null
    speakingScore?: IntNullableFilter<"ExamAttempt"> | number | null
  }

  export type ActiveExamUpsertWithoutUserInput = {
    update: XOR<ActiveExamUpdateWithoutUserInput, ActiveExamUncheckedUpdateWithoutUserInput>
    create: XOR<ActiveExamCreateWithoutUserInput, ActiveExamUncheckedCreateWithoutUserInput>
    where?: ActiveExamWhereInput
  }

  export type ActiveExamUpdateToOneWithWhereWithoutUserInput = {
    where?: ActiveExamWhereInput
    data: XOR<ActiveExamUpdateWithoutUserInput, ActiveExamUncheckedUpdateWithoutUserInput>
  }

  export type ActiveExamUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mcqCorrect?: StringFieldUpdateOperationsInput | string
    listeningCorrect?: StringFieldUpdateOperationsInput | string
    attempt?: ExamAttemptUpdateOneRequiredWithoutActiveExamNestedInput
  }

  export type ActiveExamUncheckedUpdateWithoutUserInput = {
    attemptId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mcqCorrect?: StringFieldUpdateOperationsInput | string
    listeningCorrect?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    channel?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: IntFilter<"PasswordResetToken"> | number
    userId?: IntFilter<"PasswordResetToken"> | number
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type UserCreateWithoutAttemptsInput = {
    email: string
    password: string
    role?: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerifiedAt?: Date | string | null
    examResults?: ExamResultCreateNestedManyWithoutUserInput
    activeExam?: ActiveExamCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAttemptsInput = {
    id?: number
    email: string
    password: string
    role?: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerifiedAt?: Date | string | null
    examResults?: ExamResultUncheckedCreateNestedManyWithoutUserInput
    activeExam?: ActiveExamUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAttemptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttemptsInput, UserUncheckedCreateWithoutAttemptsInput>
  }

  export type ListeningScenarioCreateWithoutAttemptsInput = {
    topic: string
    passage: string
    difficulty?: string | null
    createdAt?: Date | string
    questions?: ListeningQuestionCreateNestedManyWithoutScenarioInput
  }

  export type ListeningScenarioUncheckedCreateWithoutAttemptsInput = {
    id?: number
    topic: string
    passage: string
    difficulty?: string | null
    createdAt?: Date | string
    questions?: ListeningQuestionUncheckedCreateNestedManyWithoutScenarioInput
  }

  export type ListeningScenarioCreateOrConnectWithoutAttemptsInput = {
    where: ListeningScenarioWhereUniqueInput
    create: XOR<ListeningScenarioCreateWithoutAttemptsInput, ListeningScenarioUncheckedCreateWithoutAttemptsInput>
  }

  export type WritingTopicCreateWithoutAttemptsInput = {
    topic: string
    difficulty?: string | null
    createdAt?: Date | string
  }

  export type WritingTopicUncheckedCreateWithoutAttemptsInput = {
    id?: number
    topic: string
    difficulty?: string | null
    createdAt?: Date | string
  }

  export type WritingTopicCreateOrConnectWithoutAttemptsInput = {
    where: WritingTopicWhereUniqueInput
    create: XOR<WritingTopicCreateWithoutAttemptsInput, WritingTopicUncheckedCreateWithoutAttemptsInput>
  }

  export type SpeakingSetCreateWithoutAttemptsInput = {
    createdAt?: Date | string
    prompts?: SpeakingPromptCreateNestedManyWithoutSetInput
  }

  export type SpeakingSetUncheckedCreateWithoutAttemptsInput = {
    id?: number
    createdAt?: Date | string
    prompts?: SpeakingPromptUncheckedCreateNestedManyWithoutSetInput
  }

  export type SpeakingSetCreateOrConnectWithoutAttemptsInput = {
    where: SpeakingSetWhereUniqueInput
    create: XOR<SpeakingSetCreateWithoutAttemptsInput, SpeakingSetUncheckedCreateWithoutAttemptsInput>
  }

  export type ExamResultCreateWithoutAttemptInput = {
    score: number
    grammarScore: number
    writingScore: number
    speakingScore: number
    listeningScore: number
    level?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutExamResultsInput
  }

  export type ExamResultUncheckedCreateWithoutAttemptInput = {
    id?: number
    userId: number
    score: number
    grammarScore: number
    writingScore: number
    speakingScore: number
    listeningScore: number
    level?: string
    createdAt?: Date | string
  }

  export type ExamResultCreateOrConnectWithoutAttemptInput = {
    where: ExamResultWhereUniqueInput
    create: XOR<ExamResultCreateWithoutAttemptInput, ExamResultUncheckedCreateWithoutAttemptInput>
  }

  export type CheatingEventCreateWithoutAttemptInput = {
    type: string
    details?: string | null
    createdAt?: Date | string
  }

  export type CheatingEventUncheckedCreateWithoutAttemptInput = {
    id?: number
    type: string
    details?: string | null
    createdAt?: Date | string
  }

  export type CheatingEventCreateOrConnectWithoutAttemptInput = {
    where: CheatingEventWhereUniqueInput
    create: XOR<CheatingEventCreateWithoutAttemptInput, CheatingEventUncheckedCreateWithoutAttemptInput>
  }

  export type CheatingEventCreateManyAttemptInputEnvelope = {
    data: CheatingEventCreateManyAttemptInput | CheatingEventCreateManyAttemptInput[]
  }

  export type AudioResponseCreateWithoutAttemptInput = {
    promptIndex: number
    storageUrl: string
    mimeType?: string | null
    durationMs?: number | null
    asrText?: string | null
    asrConfidence?: number | null
    createdAt?: Date | string
  }

  export type AudioResponseUncheckedCreateWithoutAttemptInput = {
    id?: number
    promptIndex: number
    storageUrl: string
    mimeType?: string | null
    durationMs?: number | null
    asrText?: string | null
    asrConfidence?: number | null
    createdAt?: Date | string
  }

  export type AudioResponseCreateOrConnectWithoutAttemptInput = {
    where: AudioResponseWhereUniqueInput
    create: XOR<AudioResponseCreateWithoutAttemptInput, AudioResponseUncheckedCreateWithoutAttemptInput>
  }

  export type AudioResponseCreateManyAttemptInputEnvelope = {
    data: AudioResponseCreateManyAttemptInput | AudioResponseCreateManyAttemptInput[]
  }

  export type ActiveExamCreateWithoutAttemptInput = {
    createdAt?: Date | string
    mcqCorrect: string
    listeningCorrect: string
    user: UserCreateNestedOneWithoutActiveExamInput
  }

  export type ActiveExamUncheckedCreateWithoutAttemptInput = {
    userId: number
    createdAt?: Date | string
    mcqCorrect: string
    listeningCorrect: string
  }

  export type ActiveExamCreateOrConnectWithoutAttemptInput = {
    where: ActiveExamWhereUniqueInput
    create: XOR<ActiveExamCreateWithoutAttemptInput, ActiveExamUncheckedCreateWithoutAttemptInput>
  }

  export type UserUpsertWithoutAttemptsInput = {
    update: XOR<UserUpdateWithoutAttemptsInput, UserUncheckedUpdateWithoutAttemptsInput>
    create: XOR<UserCreateWithoutAttemptsInput, UserUncheckedCreateWithoutAttemptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttemptsInput, UserUncheckedUpdateWithoutAttemptsInput>
  }

  export type UserUpdateWithoutAttemptsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examResults?: ExamResultUpdateManyWithoutUserNestedInput
    activeExam?: ActiveExamUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examResults?: ExamResultUncheckedUpdateManyWithoutUserNestedInput
    activeExam?: ActiveExamUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ListeningScenarioUpsertWithoutAttemptsInput = {
    update: XOR<ListeningScenarioUpdateWithoutAttemptsInput, ListeningScenarioUncheckedUpdateWithoutAttemptsInput>
    create: XOR<ListeningScenarioCreateWithoutAttemptsInput, ListeningScenarioUncheckedCreateWithoutAttemptsInput>
    where?: ListeningScenarioWhereInput
  }

  export type ListeningScenarioUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: ListeningScenarioWhereInput
    data: XOR<ListeningScenarioUpdateWithoutAttemptsInput, ListeningScenarioUncheckedUpdateWithoutAttemptsInput>
  }

  export type ListeningScenarioUpdateWithoutAttemptsInput = {
    topic?: StringFieldUpdateOperationsInput | string
    passage?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ListeningQuestionUpdateManyWithoutScenarioNestedInput
  }

  export type ListeningScenarioUncheckedUpdateWithoutAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    topic?: StringFieldUpdateOperationsInput | string
    passage?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ListeningQuestionUncheckedUpdateManyWithoutScenarioNestedInput
  }

  export type WritingTopicUpsertWithoutAttemptsInput = {
    update: XOR<WritingTopicUpdateWithoutAttemptsInput, WritingTopicUncheckedUpdateWithoutAttemptsInput>
    create: XOR<WritingTopicCreateWithoutAttemptsInput, WritingTopicUncheckedCreateWithoutAttemptsInput>
    where?: WritingTopicWhereInput
  }

  export type WritingTopicUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: WritingTopicWhereInput
    data: XOR<WritingTopicUpdateWithoutAttemptsInput, WritingTopicUncheckedUpdateWithoutAttemptsInput>
  }

  export type WritingTopicUpdateWithoutAttemptsInput = {
    topic?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WritingTopicUncheckedUpdateWithoutAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    topic?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakingSetUpsertWithoutAttemptsInput = {
    update: XOR<SpeakingSetUpdateWithoutAttemptsInput, SpeakingSetUncheckedUpdateWithoutAttemptsInput>
    create: XOR<SpeakingSetCreateWithoutAttemptsInput, SpeakingSetUncheckedCreateWithoutAttemptsInput>
    where?: SpeakingSetWhereInput
  }

  export type SpeakingSetUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: SpeakingSetWhereInput
    data: XOR<SpeakingSetUpdateWithoutAttemptsInput, SpeakingSetUncheckedUpdateWithoutAttemptsInput>
  }

  export type SpeakingSetUpdateWithoutAttemptsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompts?: SpeakingPromptUpdateManyWithoutSetNestedInput
  }

  export type SpeakingSetUncheckedUpdateWithoutAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompts?: SpeakingPromptUncheckedUpdateManyWithoutSetNestedInput
  }

  export type ExamResultUpsertWithoutAttemptInput = {
    update: XOR<ExamResultUpdateWithoutAttemptInput, ExamResultUncheckedUpdateWithoutAttemptInput>
    create: XOR<ExamResultCreateWithoutAttemptInput, ExamResultUncheckedCreateWithoutAttemptInput>
    where?: ExamResultWhereInput
  }

  export type ExamResultUpdateToOneWithWhereWithoutAttemptInput = {
    where?: ExamResultWhereInput
    data: XOR<ExamResultUpdateWithoutAttemptInput, ExamResultUncheckedUpdateWithoutAttemptInput>
  }

  export type ExamResultUpdateWithoutAttemptInput = {
    score?: IntFieldUpdateOperationsInput | number
    grammarScore?: IntFieldUpdateOperationsInput | number
    writingScore?: IntFieldUpdateOperationsInput | number
    speakingScore?: IntFieldUpdateOperationsInput | number
    listeningScore?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExamResultsNestedInput
  }

  export type ExamResultUncheckedUpdateWithoutAttemptInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    grammarScore?: IntFieldUpdateOperationsInput | number
    writingScore?: IntFieldUpdateOperationsInput | number
    speakingScore?: IntFieldUpdateOperationsInput | number
    listeningScore?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheatingEventUpsertWithWhereUniqueWithoutAttemptInput = {
    where: CheatingEventWhereUniqueInput
    update: XOR<CheatingEventUpdateWithoutAttemptInput, CheatingEventUncheckedUpdateWithoutAttemptInput>
    create: XOR<CheatingEventCreateWithoutAttemptInput, CheatingEventUncheckedCreateWithoutAttemptInput>
  }

  export type CheatingEventUpdateWithWhereUniqueWithoutAttemptInput = {
    where: CheatingEventWhereUniqueInput
    data: XOR<CheatingEventUpdateWithoutAttemptInput, CheatingEventUncheckedUpdateWithoutAttemptInput>
  }

  export type CheatingEventUpdateManyWithWhereWithoutAttemptInput = {
    where: CheatingEventScalarWhereInput
    data: XOR<CheatingEventUpdateManyMutationInput, CheatingEventUncheckedUpdateManyWithoutAttemptInput>
  }

  export type CheatingEventScalarWhereInput = {
    AND?: CheatingEventScalarWhereInput | CheatingEventScalarWhereInput[]
    OR?: CheatingEventScalarWhereInput[]
    NOT?: CheatingEventScalarWhereInput | CheatingEventScalarWhereInput[]
    id?: IntFilter<"CheatingEvent"> | number
    attemptId?: IntFilter<"CheatingEvent"> | number
    type?: StringFilter<"CheatingEvent"> | string
    details?: StringNullableFilter<"CheatingEvent"> | string | null
    createdAt?: DateTimeFilter<"CheatingEvent"> | Date | string
  }

  export type AudioResponseUpsertWithWhereUniqueWithoutAttemptInput = {
    where: AudioResponseWhereUniqueInput
    update: XOR<AudioResponseUpdateWithoutAttemptInput, AudioResponseUncheckedUpdateWithoutAttemptInput>
    create: XOR<AudioResponseCreateWithoutAttemptInput, AudioResponseUncheckedCreateWithoutAttemptInput>
  }

  export type AudioResponseUpdateWithWhereUniqueWithoutAttemptInput = {
    where: AudioResponseWhereUniqueInput
    data: XOR<AudioResponseUpdateWithoutAttemptInput, AudioResponseUncheckedUpdateWithoutAttemptInput>
  }

  export type AudioResponseUpdateManyWithWhereWithoutAttemptInput = {
    where: AudioResponseScalarWhereInput
    data: XOR<AudioResponseUpdateManyMutationInput, AudioResponseUncheckedUpdateManyWithoutAttemptInput>
  }

  export type AudioResponseScalarWhereInput = {
    AND?: AudioResponseScalarWhereInput | AudioResponseScalarWhereInput[]
    OR?: AudioResponseScalarWhereInput[]
    NOT?: AudioResponseScalarWhereInput | AudioResponseScalarWhereInput[]
    id?: IntFilter<"AudioResponse"> | number
    attemptId?: IntFilter<"AudioResponse"> | number
    promptIndex?: IntFilter<"AudioResponse"> | number
    storageUrl?: StringFilter<"AudioResponse"> | string
    mimeType?: StringNullableFilter<"AudioResponse"> | string | null
    durationMs?: IntNullableFilter<"AudioResponse"> | number | null
    asrText?: StringNullableFilter<"AudioResponse"> | string | null
    asrConfidence?: FloatNullableFilter<"AudioResponse"> | number | null
    createdAt?: DateTimeFilter<"AudioResponse"> | Date | string
  }

  export type ActiveExamUpsertWithoutAttemptInput = {
    update: XOR<ActiveExamUpdateWithoutAttemptInput, ActiveExamUncheckedUpdateWithoutAttemptInput>
    create: XOR<ActiveExamCreateWithoutAttemptInput, ActiveExamUncheckedCreateWithoutAttemptInput>
    where?: ActiveExamWhereInput
  }

  export type ActiveExamUpdateToOneWithWhereWithoutAttemptInput = {
    where?: ActiveExamWhereInput
    data: XOR<ActiveExamUpdateWithoutAttemptInput, ActiveExamUncheckedUpdateWithoutAttemptInput>
  }

  export type ActiveExamUpdateWithoutAttemptInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mcqCorrect?: StringFieldUpdateOperationsInput | string
    listeningCorrect?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutActiveExamNestedInput
  }

  export type ActiveExamUncheckedUpdateWithoutAttemptInput = {
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mcqCorrect?: StringFieldUpdateOperationsInput | string
    listeningCorrect?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutActiveExamInput = {
    email: string
    password: string
    role?: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerifiedAt?: Date | string | null
    examResults?: ExamResultCreateNestedManyWithoutUserInput
    attempts?: ExamAttemptCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActiveExamInput = {
    id?: number
    email: string
    password: string
    role?: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerifiedAt?: Date | string | null
    examResults?: ExamResultUncheckedCreateNestedManyWithoutUserInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActiveExamInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActiveExamInput, UserUncheckedCreateWithoutActiveExamInput>
  }

  export type ExamAttemptCreateWithoutActiveExamInput = {
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    user: UserCreateNestedOneWithoutAttemptsInput
    listeningScenario?: ListeningScenarioCreateNestedOneWithoutAttemptsInput
    writingTopic?: WritingTopicCreateNestedOneWithoutAttemptsInput
    speakingSet?: SpeakingSetCreateNestedOneWithoutAttemptsInput
    result?: ExamResultCreateNestedOneWithoutAttemptInput
    cheatingEvents?: CheatingEventCreateNestedManyWithoutAttemptInput
    audioResponses?: AudioResponseCreateNestedManyWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutActiveExamInput = {
    id?: number
    userId: number
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    listeningScenarioId?: number | null
    writingTopicId?: number | null
    speakingSetId?: number | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    result?: ExamResultUncheckedCreateNestedOneWithoutAttemptInput
    cheatingEvents?: CheatingEventUncheckedCreateNestedManyWithoutAttemptInput
    audioResponses?: AudioResponseUncheckedCreateNestedManyWithoutAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutActiveExamInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutActiveExamInput, ExamAttemptUncheckedCreateWithoutActiveExamInput>
  }

  export type UserUpsertWithoutActiveExamInput = {
    update: XOR<UserUpdateWithoutActiveExamInput, UserUncheckedUpdateWithoutActiveExamInput>
    create: XOR<UserCreateWithoutActiveExamInput, UserUncheckedCreateWithoutActiveExamInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActiveExamInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActiveExamInput, UserUncheckedUpdateWithoutActiveExamInput>
  }

  export type UserUpdateWithoutActiveExamInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examResults?: ExamResultUpdateManyWithoutUserNestedInput
    attempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActiveExamInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examResults?: ExamResultUncheckedUpdateManyWithoutUserNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExamAttemptUpsertWithoutActiveExamInput = {
    update: XOR<ExamAttemptUpdateWithoutActiveExamInput, ExamAttemptUncheckedUpdateWithoutActiveExamInput>
    create: XOR<ExamAttemptCreateWithoutActiveExamInput, ExamAttemptUncheckedCreateWithoutActiveExamInput>
    where?: ExamAttemptWhereInput
  }

  export type ExamAttemptUpdateToOneWithWhereWithoutActiveExamInput = {
    where?: ExamAttemptWhereInput
    data: XOR<ExamAttemptUpdateWithoutActiveExamInput, ExamAttemptUncheckedUpdateWithoutActiveExamInput>
  }

  export type ExamAttemptUpdateWithoutActiveExamInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutAttemptsNestedInput
    listeningScenario?: ListeningScenarioUpdateOneWithoutAttemptsNestedInput
    writingTopic?: WritingTopicUpdateOneWithoutAttemptsNestedInput
    speakingSet?: SpeakingSetUpdateOneWithoutAttemptsNestedInput
    result?: ExamResultUpdateOneWithoutAttemptNestedInput
    cheatingEvents?: CheatingEventUpdateManyWithoutAttemptNestedInput
    audioResponses?: AudioResponseUpdateManyWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutActiveExamInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    listeningScenarioId?: NullableIntFieldUpdateOperationsInput | number | null
    writingTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    speakingSetId?: NullableIntFieldUpdateOperationsInput | number | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    result?: ExamResultUncheckedUpdateOneWithoutAttemptNestedInput
    cheatingEvents?: CheatingEventUncheckedUpdateManyWithoutAttemptNestedInput
    audioResponses?: AudioResponseUncheckedUpdateManyWithoutAttemptNestedInput
  }

  export type UserCreateWithoutExamResultsInput = {
    email: string
    password: string
    role?: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerifiedAt?: Date | string | null
    attempts?: ExamAttemptCreateNestedManyWithoutUserInput
    activeExam?: ActiveExamCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExamResultsInput = {
    id?: number
    email: string
    password: string
    role?: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerifiedAt?: Date | string | null
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    activeExam?: ActiveExamUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    resetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExamResultsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExamResultsInput, UserUncheckedCreateWithoutExamResultsInput>
  }

  export type ExamAttemptCreateWithoutResultInput = {
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    user: UserCreateNestedOneWithoutAttemptsInput
    listeningScenario?: ListeningScenarioCreateNestedOneWithoutAttemptsInput
    writingTopic?: WritingTopicCreateNestedOneWithoutAttemptsInput
    speakingSet?: SpeakingSetCreateNestedOneWithoutAttemptsInput
    cheatingEvents?: CheatingEventCreateNestedManyWithoutAttemptInput
    audioResponses?: AudioResponseCreateNestedManyWithoutAttemptInput
    activeExam?: ActiveExamCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutResultInput = {
    id?: number
    userId: number
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    listeningScenarioId?: number | null
    writingTopicId?: number | null
    speakingSetId?: number | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    cheatingEvents?: CheatingEventUncheckedCreateNestedManyWithoutAttemptInput
    audioResponses?: AudioResponseUncheckedCreateNestedManyWithoutAttemptInput
    activeExam?: ActiveExamUncheckedCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutResultInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutResultInput, ExamAttemptUncheckedCreateWithoutResultInput>
  }

  export type UserUpsertWithoutExamResultsInput = {
    update: XOR<UserUpdateWithoutExamResultsInput, UserUncheckedUpdateWithoutExamResultsInput>
    create: XOR<UserCreateWithoutExamResultsInput, UserUncheckedCreateWithoutExamResultsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExamResultsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExamResultsInput, UserUncheckedUpdateWithoutExamResultsInput>
  }

  export type UserUpdateWithoutExamResultsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    activeExam?: ActiveExamUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExamResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    activeExam?: ActiveExamUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExamAttemptUpsertWithoutResultInput = {
    update: XOR<ExamAttemptUpdateWithoutResultInput, ExamAttemptUncheckedUpdateWithoutResultInput>
    create: XOR<ExamAttemptCreateWithoutResultInput, ExamAttemptUncheckedCreateWithoutResultInput>
    where?: ExamAttemptWhereInput
  }

  export type ExamAttemptUpdateToOneWithWhereWithoutResultInput = {
    where?: ExamAttemptWhereInput
    data: XOR<ExamAttemptUpdateWithoutResultInput, ExamAttemptUncheckedUpdateWithoutResultInput>
  }

  export type ExamAttemptUpdateWithoutResultInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutAttemptsNestedInput
    listeningScenario?: ListeningScenarioUpdateOneWithoutAttemptsNestedInput
    writingTopic?: WritingTopicUpdateOneWithoutAttemptsNestedInput
    speakingSet?: SpeakingSetUpdateOneWithoutAttemptsNestedInput
    cheatingEvents?: CheatingEventUpdateManyWithoutAttemptNestedInput
    audioResponses?: AudioResponseUpdateManyWithoutAttemptNestedInput
    activeExam?: ActiveExamUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutResultInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    listeningScenarioId?: NullableIntFieldUpdateOperationsInput | number | null
    writingTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    speakingSetId?: NullableIntFieldUpdateOperationsInput | number | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    cheatingEvents?: CheatingEventUncheckedUpdateManyWithoutAttemptNestedInput
    audioResponses?: AudioResponseUncheckedUpdateManyWithoutAttemptNestedInput
    activeExam?: ActiveExamUncheckedUpdateOneWithoutAttemptNestedInput
  }

  export type ListeningQuestionCreateWithoutScenarioInput = {
    qid: string
    text: string
    options: string
    correct: string
  }

  export type ListeningQuestionUncheckedCreateWithoutScenarioInput = {
    id?: number
    qid: string
    text: string
    options: string
    correct: string
  }

  export type ListeningQuestionCreateOrConnectWithoutScenarioInput = {
    where: ListeningQuestionWhereUniqueInput
    create: XOR<ListeningQuestionCreateWithoutScenarioInput, ListeningQuestionUncheckedCreateWithoutScenarioInput>
  }

  export type ListeningQuestionCreateManyScenarioInputEnvelope = {
    data: ListeningQuestionCreateManyScenarioInput | ListeningQuestionCreateManyScenarioInput[]
  }

  export type ExamAttemptCreateWithoutListeningScenarioInput = {
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    user: UserCreateNestedOneWithoutAttemptsInput
    writingTopic?: WritingTopicCreateNestedOneWithoutAttemptsInput
    speakingSet?: SpeakingSetCreateNestedOneWithoutAttemptsInput
    result?: ExamResultCreateNestedOneWithoutAttemptInput
    cheatingEvents?: CheatingEventCreateNestedManyWithoutAttemptInput
    audioResponses?: AudioResponseCreateNestedManyWithoutAttemptInput
    activeExam?: ActiveExamCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutListeningScenarioInput = {
    id?: number
    userId: number
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    writingTopicId?: number | null
    speakingSetId?: number | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    result?: ExamResultUncheckedCreateNestedOneWithoutAttemptInput
    cheatingEvents?: CheatingEventUncheckedCreateNestedManyWithoutAttemptInput
    audioResponses?: AudioResponseUncheckedCreateNestedManyWithoutAttemptInput
    activeExam?: ActiveExamUncheckedCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutListeningScenarioInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutListeningScenarioInput, ExamAttemptUncheckedCreateWithoutListeningScenarioInput>
  }

  export type ExamAttemptCreateManyListeningScenarioInputEnvelope = {
    data: ExamAttemptCreateManyListeningScenarioInput | ExamAttemptCreateManyListeningScenarioInput[]
  }

  export type ListeningQuestionUpsertWithWhereUniqueWithoutScenarioInput = {
    where: ListeningQuestionWhereUniqueInput
    update: XOR<ListeningQuestionUpdateWithoutScenarioInput, ListeningQuestionUncheckedUpdateWithoutScenarioInput>
    create: XOR<ListeningQuestionCreateWithoutScenarioInput, ListeningQuestionUncheckedCreateWithoutScenarioInput>
  }

  export type ListeningQuestionUpdateWithWhereUniqueWithoutScenarioInput = {
    where: ListeningQuestionWhereUniqueInput
    data: XOR<ListeningQuestionUpdateWithoutScenarioInput, ListeningQuestionUncheckedUpdateWithoutScenarioInput>
  }

  export type ListeningQuestionUpdateManyWithWhereWithoutScenarioInput = {
    where: ListeningQuestionScalarWhereInput
    data: XOR<ListeningQuestionUpdateManyMutationInput, ListeningQuestionUncheckedUpdateManyWithoutScenarioInput>
  }

  export type ListeningQuestionScalarWhereInput = {
    AND?: ListeningQuestionScalarWhereInput | ListeningQuestionScalarWhereInput[]
    OR?: ListeningQuestionScalarWhereInput[]
    NOT?: ListeningQuestionScalarWhereInput | ListeningQuestionScalarWhereInput[]
    id?: IntFilter<"ListeningQuestion"> | number
    scenarioId?: IntFilter<"ListeningQuestion"> | number
    qid?: StringFilter<"ListeningQuestion"> | string
    text?: StringFilter<"ListeningQuestion"> | string
    options?: StringFilter<"ListeningQuestion"> | string
    correct?: StringFilter<"ListeningQuestion"> | string
  }

  export type ExamAttemptUpsertWithWhereUniqueWithoutListeningScenarioInput = {
    where: ExamAttemptWhereUniqueInput
    update: XOR<ExamAttemptUpdateWithoutListeningScenarioInput, ExamAttemptUncheckedUpdateWithoutListeningScenarioInput>
    create: XOR<ExamAttemptCreateWithoutListeningScenarioInput, ExamAttemptUncheckedCreateWithoutListeningScenarioInput>
  }

  export type ExamAttemptUpdateWithWhereUniqueWithoutListeningScenarioInput = {
    where: ExamAttemptWhereUniqueInput
    data: XOR<ExamAttemptUpdateWithoutListeningScenarioInput, ExamAttemptUncheckedUpdateWithoutListeningScenarioInput>
  }

  export type ExamAttemptUpdateManyWithWhereWithoutListeningScenarioInput = {
    where: ExamAttemptScalarWhereInput
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyWithoutListeningScenarioInput>
  }

  export type ListeningScenarioCreateWithoutQuestionsInput = {
    topic: string
    passage: string
    difficulty?: string | null
    createdAt?: Date | string
    attempts?: ExamAttemptCreateNestedManyWithoutListeningScenarioInput
  }

  export type ListeningScenarioUncheckedCreateWithoutQuestionsInput = {
    id?: number
    topic: string
    passage: string
    difficulty?: string | null
    createdAt?: Date | string
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutListeningScenarioInput
  }

  export type ListeningScenarioCreateOrConnectWithoutQuestionsInput = {
    where: ListeningScenarioWhereUniqueInput
    create: XOR<ListeningScenarioCreateWithoutQuestionsInput, ListeningScenarioUncheckedCreateWithoutQuestionsInput>
  }

  export type ListeningScenarioUpsertWithoutQuestionsInput = {
    update: XOR<ListeningScenarioUpdateWithoutQuestionsInput, ListeningScenarioUncheckedUpdateWithoutQuestionsInput>
    create: XOR<ListeningScenarioCreateWithoutQuestionsInput, ListeningScenarioUncheckedCreateWithoutQuestionsInput>
    where?: ListeningScenarioWhereInput
  }

  export type ListeningScenarioUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: ListeningScenarioWhereInput
    data: XOR<ListeningScenarioUpdateWithoutQuestionsInput, ListeningScenarioUncheckedUpdateWithoutQuestionsInput>
  }

  export type ListeningScenarioUpdateWithoutQuestionsInput = {
    topic?: StringFieldUpdateOperationsInput | string
    passage?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: ExamAttemptUpdateManyWithoutListeningScenarioNestedInput
  }

  export type ListeningScenarioUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    topic?: StringFieldUpdateOperationsInput | string
    passage?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: ExamAttemptUncheckedUpdateManyWithoutListeningScenarioNestedInput
  }

  export type ExamAttemptCreateWithoutWritingTopicInput = {
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    user: UserCreateNestedOneWithoutAttemptsInput
    listeningScenario?: ListeningScenarioCreateNestedOneWithoutAttemptsInput
    speakingSet?: SpeakingSetCreateNestedOneWithoutAttemptsInput
    result?: ExamResultCreateNestedOneWithoutAttemptInput
    cheatingEvents?: CheatingEventCreateNestedManyWithoutAttemptInput
    audioResponses?: AudioResponseCreateNestedManyWithoutAttemptInput
    activeExam?: ActiveExamCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutWritingTopicInput = {
    id?: number
    userId: number
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    listeningScenarioId?: number | null
    speakingSetId?: number | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    result?: ExamResultUncheckedCreateNestedOneWithoutAttemptInput
    cheatingEvents?: CheatingEventUncheckedCreateNestedManyWithoutAttemptInput
    audioResponses?: AudioResponseUncheckedCreateNestedManyWithoutAttemptInput
    activeExam?: ActiveExamUncheckedCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutWritingTopicInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutWritingTopicInput, ExamAttemptUncheckedCreateWithoutWritingTopicInput>
  }

  export type ExamAttemptCreateManyWritingTopicInputEnvelope = {
    data: ExamAttemptCreateManyWritingTopicInput | ExamAttemptCreateManyWritingTopicInput[]
  }

  export type ExamAttemptUpsertWithWhereUniqueWithoutWritingTopicInput = {
    where: ExamAttemptWhereUniqueInput
    update: XOR<ExamAttemptUpdateWithoutWritingTopicInput, ExamAttemptUncheckedUpdateWithoutWritingTopicInput>
    create: XOR<ExamAttemptCreateWithoutWritingTopicInput, ExamAttemptUncheckedCreateWithoutWritingTopicInput>
  }

  export type ExamAttemptUpdateWithWhereUniqueWithoutWritingTopicInput = {
    where: ExamAttemptWhereUniqueInput
    data: XOR<ExamAttemptUpdateWithoutWritingTopicInput, ExamAttemptUncheckedUpdateWithoutWritingTopicInput>
  }

  export type ExamAttemptUpdateManyWithWhereWithoutWritingTopicInput = {
    where: ExamAttemptScalarWhereInput
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyWithoutWritingTopicInput>
  }

  export type SpeakingPromptCreateWithoutSetInput = {
    text: string
  }

  export type SpeakingPromptUncheckedCreateWithoutSetInput = {
    id?: number
    text: string
  }

  export type SpeakingPromptCreateOrConnectWithoutSetInput = {
    where: SpeakingPromptWhereUniqueInput
    create: XOR<SpeakingPromptCreateWithoutSetInput, SpeakingPromptUncheckedCreateWithoutSetInput>
  }

  export type SpeakingPromptCreateManySetInputEnvelope = {
    data: SpeakingPromptCreateManySetInput | SpeakingPromptCreateManySetInput[]
  }

  export type ExamAttemptCreateWithoutSpeakingSetInput = {
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    user: UserCreateNestedOneWithoutAttemptsInput
    listeningScenario?: ListeningScenarioCreateNestedOneWithoutAttemptsInput
    writingTopic?: WritingTopicCreateNestedOneWithoutAttemptsInput
    result?: ExamResultCreateNestedOneWithoutAttemptInput
    cheatingEvents?: CheatingEventCreateNestedManyWithoutAttemptInput
    audioResponses?: AudioResponseCreateNestedManyWithoutAttemptInput
    activeExam?: ActiveExamCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutSpeakingSetInput = {
    id?: number
    userId: number
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    listeningScenarioId?: number | null
    writingTopicId?: number | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    result?: ExamResultUncheckedCreateNestedOneWithoutAttemptInput
    cheatingEvents?: CheatingEventUncheckedCreateNestedManyWithoutAttemptInput
    audioResponses?: AudioResponseUncheckedCreateNestedManyWithoutAttemptInput
    activeExam?: ActiveExamUncheckedCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutSpeakingSetInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutSpeakingSetInput, ExamAttemptUncheckedCreateWithoutSpeakingSetInput>
  }

  export type ExamAttemptCreateManySpeakingSetInputEnvelope = {
    data: ExamAttemptCreateManySpeakingSetInput | ExamAttemptCreateManySpeakingSetInput[]
  }

  export type SpeakingPromptUpsertWithWhereUniqueWithoutSetInput = {
    where: SpeakingPromptWhereUniqueInput
    update: XOR<SpeakingPromptUpdateWithoutSetInput, SpeakingPromptUncheckedUpdateWithoutSetInput>
    create: XOR<SpeakingPromptCreateWithoutSetInput, SpeakingPromptUncheckedCreateWithoutSetInput>
  }

  export type SpeakingPromptUpdateWithWhereUniqueWithoutSetInput = {
    where: SpeakingPromptWhereUniqueInput
    data: XOR<SpeakingPromptUpdateWithoutSetInput, SpeakingPromptUncheckedUpdateWithoutSetInput>
  }

  export type SpeakingPromptUpdateManyWithWhereWithoutSetInput = {
    where: SpeakingPromptScalarWhereInput
    data: XOR<SpeakingPromptUpdateManyMutationInput, SpeakingPromptUncheckedUpdateManyWithoutSetInput>
  }

  export type SpeakingPromptScalarWhereInput = {
    AND?: SpeakingPromptScalarWhereInput | SpeakingPromptScalarWhereInput[]
    OR?: SpeakingPromptScalarWhereInput[]
    NOT?: SpeakingPromptScalarWhereInput | SpeakingPromptScalarWhereInput[]
    id?: IntFilter<"SpeakingPrompt"> | number
    setId?: IntFilter<"SpeakingPrompt"> | number
    text?: StringFilter<"SpeakingPrompt"> | string
  }

  export type ExamAttemptUpsertWithWhereUniqueWithoutSpeakingSetInput = {
    where: ExamAttemptWhereUniqueInput
    update: XOR<ExamAttemptUpdateWithoutSpeakingSetInput, ExamAttemptUncheckedUpdateWithoutSpeakingSetInput>
    create: XOR<ExamAttemptCreateWithoutSpeakingSetInput, ExamAttemptUncheckedCreateWithoutSpeakingSetInput>
  }

  export type ExamAttemptUpdateWithWhereUniqueWithoutSpeakingSetInput = {
    where: ExamAttemptWhereUniqueInput
    data: XOR<ExamAttemptUpdateWithoutSpeakingSetInput, ExamAttemptUncheckedUpdateWithoutSpeakingSetInput>
  }

  export type ExamAttemptUpdateManyWithWhereWithoutSpeakingSetInput = {
    where: ExamAttemptScalarWhereInput
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyWithoutSpeakingSetInput>
  }

  export type SpeakingSetCreateWithoutPromptsInput = {
    createdAt?: Date | string
    attempts?: ExamAttemptCreateNestedManyWithoutSpeakingSetInput
  }

  export type SpeakingSetUncheckedCreateWithoutPromptsInput = {
    id?: number
    createdAt?: Date | string
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutSpeakingSetInput
  }

  export type SpeakingSetCreateOrConnectWithoutPromptsInput = {
    where: SpeakingSetWhereUniqueInput
    create: XOR<SpeakingSetCreateWithoutPromptsInput, SpeakingSetUncheckedCreateWithoutPromptsInput>
  }

  export type SpeakingSetUpsertWithoutPromptsInput = {
    update: XOR<SpeakingSetUpdateWithoutPromptsInput, SpeakingSetUncheckedUpdateWithoutPromptsInput>
    create: XOR<SpeakingSetCreateWithoutPromptsInput, SpeakingSetUncheckedCreateWithoutPromptsInput>
    where?: SpeakingSetWhereInput
  }

  export type SpeakingSetUpdateToOneWithWhereWithoutPromptsInput = {
    where?: SpeakingSetWhereInput
    data: XOR<SpeakingSetUpdateWithoutPromptsInput, SpeakingSetUncheckedUpdateWithoutPromptsInput>
  }

  export type SpeakingSetUpdateWithoutPromptsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: ExamAttemptUpdateManyWithoutSpeakingSetNestedInput
  }

  export type SpeakingSetUncheckedUpdateWithoutPromptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: ExamAttemptUncheckedUpdateManyWithoutSpeakingSetNestedInput
  }

  export type ExamAttemptCreateWithoutCheatingEventsInput = {
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    user: UserCreateNestedOneWithoutAttemptsInput
    listeningScenario?: ListeningScenarioCreateNestedOneWithoutAttemptsInput
    writingTopic?: WritingTopicCreateNestedOneWithoutAttemptsInput
    speakingSet?: SpeakingSetCreateNestedOneWithoutAttemptsInput
    result?: ExamResultCreateNestedOneWithoutAttemptInput
    audioResponses?: AudioResponseCreateNestedManyWithoutAttemptInput
    activeExam?: ActiveExamCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutCheatingEventsInput = {
    id?: number
    userId: number
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    listeningScenarioId?: number | null
    writingTopicId?: number | null
    speakingSetId?: number | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    result?: ExamResultUncheckedCreateNestedOneWithoutAttemptInput
    audioResponses?: AudioResponseUncheckedCreateNestedManyWithoutAttemptInput
    activeExam?: ActiveExamUncheckedCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutCheatingEventsInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutCheatingEventsInput, ExamAttemptUncheckedCreateWithoutCheatingEventsInput>
  }

  export type ExamAttemptUpsertWithoutCheatingEventsInput = {
    update: XOR<ExamAttemptUpdateWithoutCheatingEventsInput, ExamAttemptUncheckedUpdateWithoutCheatingEventsInput>
    create: XOR<ExamAttemptCreateWithoutCheatingEventsInput, ExamAttemptUncheckedCreateWithoutCheatingEventsInput>
    where?: ExamAttemptWhereInput
  }

  export type ExamAttemptUpdateToOneWithWhereWithoutCheatingEventsInput = {
    where?: ExamAttemptWhereInput
    data: XOR<ExamAttemptUpdateWithoutCheatingEventsInput, ExamAttemptUncheckedUpdateWithoutCheatingEventsInput>
  }

  export type ExamAttemptUpdateWithoutCheatingEventsInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutAttemptsNestedInput
    listeningScenario?: ListeningScenarioUpdateOneWithoutAttemptsNestedInput
    writingTopic?: WritingTopicUpdateOneWithoutAttemptsNestedInput
    speakingSet?: SpeakingSetUpdateOneWithoutAttemptsNestedInput
    result?: ExamResultUpdateOneWithoutAttemptNestedInput
    audioResponses?: AudioResponseUpdateManyWithoutAttemptNestedInput
    activeExam?: ActiveExamUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutCheatingEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    listeningScenarioId?: NullableIntFieldUpdateOperationsInput | number | null
    writingTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    speakingSetId?: NullableIntFieldUpdateOperationsInput | number | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    result?: ExamResultUncheckedUpdateOneWithoutAttemptNestedInput
    audioResponses?: AudioResponseUncheckedUpdateManyWithoutAttemptNestedInput
    activeExam?: ActiveExamUncheckedUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptCreateWithoutAudioResponsesInput = {
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    user: UserCreateNestedOneWithoutAttemptsInput
    listeningScenario?: ListeningScenarioCreateNestedOneWithoutAttemptsInput
    writingTopic?: WritingTopicCreateNestedOneWithoutAttemptsInput
    speakingSet?: SpeakingSetCreateNestedOneWithoutAttemptsInput
    result?: ExamResultCreateNestedOneWithoutAttemptInput
    cheatingEvents?: CheatingEventCreateNestedManyWithoutAttemptInput
    activeExam?: ActiveExamCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutAudioResponsesInput = {
    id?: number
    userId: number
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    listeningScenarioId?: number | null
    writingTopicId?: number | null
    speakingSetId?: number | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
    result?: ExamResultUncheckedCreateNestedOneWithoutAttemptInput
    cheatingEvents?: CheatingEventUncheckedCreateNestedManyWithoutAttemptInput
    activeExam?: ActiveExamUncheckedCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutAudioResponsesInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutAudioResponsesInput, ExamAttemptUncheckedCreateWithoutAudioResponsesInput>
  }

  export type ExamAttemptUpsertWithoutAudioResponsesInput = {
    update: XOR<ExamAttemptUpdateWithoutAudioResponsesInput, ExamAttemptUncheckedUpdateWithoutAudioResponsesInput>
    create: XOR<ExamAttemptCreateWithoutAudioResponsesInput, ExamAttemptUncheckedCreateWithoutAudioResponsesInput>
    where?: ExamAttemptWhereInput
  }

  export type ExamAttemptUpdateToOneWithWhereWithoutAudioResponsesInput = {
    where?: ExamAttemptWhereInput
    data: XOR<ExamAttemptUpdateWithoutAudioResponsesInput, ExamAttemptUncheckedUpdateWithoutAudioResponsesInput>
  }

  export type ExamAttemptUpdateWithoutAudioResponsesInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutAttemptsNestedInput
    listeningScenario?: ListeningScenarioUpdateOneWithoutAttemptsNestedInput
    writingTopic?: WritingTopicUpdateOneWithoutAttemptsNestedInput
    speakingSet?: SpeakingSetUpdateOneWithoutAttemptsNestedInput
    result?: ExamResultUpdateOneWithoutAttemptNestedInput
    cheatingEvents?: CheatingEventUpdateManyWithoutAttemptNestedInput
    activeExam?: ActiveExamUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutAudioResponsesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    listeningScenarioId?: NullableIntFieldUpdateOperationsInput | number | null
    writingTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    speakingSetId?: NullableIntFieldUpdateOperationsInput | number | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    result?: ExamResultUncheckedUpdateOneWithoutAttemptNestedInput
    cheatingEvents?: CheatingEventUncheckedUpdateManyWithoutAttemptNestedInput
    activeExam?: ActiveExamUncheckedUpdateOneWithoutAttemptNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    email: string
    password: string
    role?: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerifiedAt?: Date | string | null
    examResults?: ExamResultCreateNestedManyWithoutUserInput
    attempts?: ExamAttemptCreateNestedManyWithoutUserInput
    activeExam?: ActiveExamCreateNestedOneWithoutUserInput
    resetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    email: string
    password: string
    role?: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerifiedAt?: Date | string | null
    examResults?: ExamResultUncheckedCreateNestedManyWithoutUserInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    activeExam?: ActiveExamUncheckedCreateNestedOneWithoutUserInput
    resetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examResults?: ExamResultUpdateManyWithoutUserNestedInput
    attempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    activeExam?: ActiveExamUpdateOneWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examResults?: ExamResultUncheckedUpdateManyWithoutUserNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    activeExam?: ActiveExamUncheckedUpdateOneWithoutUserNestedInput
    resetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutResetTokensInput = {
    email: string
    password: string
    role?: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerifiedAt?: Date | string | null
    examResults?: ExamResultCreateNestedManyWithoutUserInput
    attempts?: ExamAttemptCreateNestedManyWithoutUserInput
    activeExam?: ActiveExamCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResetTokensInput = {
    id?: number
    email: string
    password: string
    role?: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerifiedAt?: Date | string | null
    examResults?: ExamResultUncheckedCreateNestedManyWithoutUserInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    activeExam?: ActiveExamUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResetTokensInput, UserUncheckedCreateWithoutResetTokensInput>
  }

  export type UserUpsertWithoutResetTokensInput = {
    update: XOR<UserUpdateWithoutResetTokensInput, UserUncheckedUpdateWithoutResetTokensInput>
    create: XOR<UserCreateWithoutResetTokensInput, UserUncheckedCreateWithoutResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResetTokensInput, UserUncheckedUpdateWithoutResetTokensInput>
  }

  export type UserUpdateWithoutResetTokensInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examResults?: ExamResultUpdateManyWithoutUserNestedInput
    attempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    activeExam?: ActiveExamUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResetTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examResults?: ExamResultUncheckedUpdateManyWithoutUserNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    activeExam?: ActiveExamUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExamResultCreateManyUserInput = {
    id?: number
    attemptId: number
    score: number
    grammarScore: number
    writingScore: number
    speakingScore: number
    listeningScore: number
    level?: string
    createdAt?: Date | string
  }

  export type ExamAttemptCreateManyUserInput = {
    id?: number
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    listeningScenarioId?: number | null
    writingTopicId?: number | null
    speakingSetId?: number | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    channel: string
    type: string
    title: string
    message: string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ExamResultUpdateWithoutUserInput = {
    score?: IntFieldUpdateOperationsInput | number
    grammarScore?: IntFieldUpdateOperationsInput | number
    writingScore?: IntFieldUpdateOperationsInput | number
    speakingScore?: IntFieldUpdateOperationsInput | number
    listeningScore?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: ExamAttemptUpdateOneRequiredWithoutResultNestedInput
  }

  export type ExamResultUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    grammarScore?: IntFieldUpdateOperationsInput | number
    writingScore?: IntFieldUpdateOperationsInput | number
    speakingScore?: IntFieldUpdateOperationsInput | number
    listeningScore?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamResultUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    attemptId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    grammarScore?: IntFieldUpdateOperationsInput | number
    writingScore?: IntFieldUpdateOperationsInput | number
    speakingScore?: IntFieldUpdateOperationsInput | number
    listeningScore?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamAttemptUpdateWithoutUserInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    listeningScenario?: ListeningScenarioUpdateOneWithoutAttemptsNestedInput
    writingTopic?: WritingTopicUpdateOneWithoutAttemptsNestedInput
    speakingSet?: SpeakingSetUpdateOneWithoutAttemptsNestedInput
    result?: ExamResultUpdateOneWithoutAttemptNestedInput
    cheatingEvents?: CheatingEventUpdateManyWithoutAttemptNestedInput
    audioResponses?: AudioResponseUpdateManyWithoutAttemptNestedInput
    activeExam?: ActiveExamUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    listeningScenarioId?: NullableIntFieldUpdateOperationsInput | number | null
    writingTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    speakingSetId?: NullableIntFieldUpdateOperationsInput | number | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    result?: ExamResultUncheckedUpdateOneWithoutAttemptNestedInput
    cheatingEvents?: CheatingEventUncheckedUpdateManyWithoutAttemptNestedInput
    audioResponses?: AudioResponseUncheckedUpdateManyWithoutAttemptNestedInput
    activeExam?: ActiveExamUncheckedUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    listeningScenarioId?: NullableIntFieldUpdateOperationsInput | number | null
    writingTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    speakingSetId?: NullableIntFieldUpdateOperationsInput | number | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotificationUpdateWithoutUserInput = {
    channel?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    channel?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheatingEventCreateManyAttemptInput = {
    id?: number
    type: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AudioResponseCreateManyAttemptInput = {
    id?: number
    promptIndex: number
    storageUrl: string
    mimeType?: string | null
    durationMs?: number | null
    asrText?: string | null
    asrConfidence?: number | null
    createdAt?: Date | string
  }

  export type CheatingEventUpdateWithoutAttemptInput = {
    type?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheatingEventUncheckedUpdateWithoutAttemptInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheatingEventUncheckedUpdateManyWithoutAttemptInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioResponseUpdateWithoutAttemptInput = {
    promptIndex?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    asrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioResponseUncheckedUpdateWithoutAttemptInput = {
    id?: IntFieldUpdateOperationsInput | number
    promptIndex?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    asrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioResponseUncheckedUpdateManyWithoutAttemptInput = {
    id?: IntFieldUpdateOperationsInput | number
    promptIndex?: IntFieldUpdateOperationsInput | number
    storageUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    asrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListeningQuestionCreateManyScenarioInput = {
    id?: number
    qid: string
    text: string
    options: string
    correct: string
  }

  export type ExamAttemptCreateManyListeningScenarioInput = {
    id?: number
    userId: number
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    writingTopicId?: number | null
    speakingSetId?: number | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
  }

  export type ListeningQuestionUpdateWithoutScenarioInput = {
    qid?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct?: StringFieldUpdateOperationsInput | string
  }

  export type ListeningQuestionUncheckedUpdateWithoutScenarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    qid?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct?: StringFieldUpdateOperationsInput | string
  }

  export type ListeningQuestionUncheckedUpdateManyWithoutScenarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    qid?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    options?: StringFieldUpdateOperationsInput | string
    correct?: StringFieldUpdateOperationsInput | string
  }

  export type ExamAttemptUpdateWithoutListeningScenarioInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutAttemptsNestedInput
    writingTopic?: WritingTopicUpdateOneWithoutAttemptsNestedInput
    speakingSet?: SpeakingSetUpdateOneWithoutAttemptsNestedInput
    result?: ExamResultUpdateOneWithoutAttemptNestedInput
    cheatingEvents?: CheatingEventUpdateManyWithoutAttemptNestedInput
    audioResponses?: AudioResponseUpdateManyWithoutAttemptNestedInput
    activeExam?: ActiveExamUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutListeningScenarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    writingTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    speakingSetId?: NullableIntFieldUpdateOperationsInput | number | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    result?: ExamResultUncheckedUpdateOneWithoutAttemptNestedInput
    cheatingEvents?: CheatingEventUncheckedUpdateManyWithoutAttemptNestedInput
    audioResponses?: AudioResponseUncheckedUpdateManyWithoutAttemptNestedInput
    activeExam?: ActiveExamUncheckedUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateManyWithoutListeningScenarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    writingTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    speakingSetId?: NullableIntFieldUpdateOperationsInput | number | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExamAttemptCreateManyWritingTopicInput = {
    id?: number
    userId: number
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    listeningScenarioId?: number | null
    speakingSetId?: number | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
  }

  export type ExamAttemptUpdateWithoutWritingTopicInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutAttemptsNestedInput
    listeningScenario?: ListeningScenarioUpdateOneWithoutAttemptsNestedInput
    speakingSet?: SpeakingSetUpdateOneWithoutAttemptsNestedInput
    result?: ExamResultUpdateOneWithoutAttemptNestedInput
    cheatingEvents?: CheatingEventUpdateManyWithoutAttemptNestedInput
    audioResponses?: AudioResponseUpdateManyWithoutAttemptNestedInput
    activeExam?: ActiveExamUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutWritingTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    listeningScenarioId?: NullableIntFieldUpdateOperationsInput | number | null
    speakingSetId?: NullableIntFieldUpdateOperationsInput | number | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    result?: ExamResultUncheckedUpdateOneWithoutAttemptNestedInput
    cheatingEvents?: CheatingEventUncheckedUpdateManyWithoutAttemptNestedInput
    audioResponses?: AudioResponseUncheckedUpdateManyWithoutAttemptNestedInput
    activeExam?: ActiveExamUncheckedUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateManyWithoutWritingTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    listeningScenarioId?: NullableIntFieldUpdateOperationsInput | number | null
    speakingSetId?: NullableIntFieldUpdateOperationsInput | number | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SpeakingPromptCreateManySetInput = {
    id?: number
    text: string
  }

  export type ExamAttemptCreateManySpeakingSetInput = {
    id?: number
    userId: number
    status?: string
    createdAt?: Date | string
    submittedAt?: Date | string | null
    mcqQuestionIds?: string | null
    listeningScenarioId?: number | null
    writingTopicId?: number | null
    mcqAnswers?: string | null
    listeningAnswers?: string | null
    writingAnswer?: string | null
    speakingTranscript?: string | null
    speakingScore?: number | null
  }

  export type SpeakingPromptUpdateWithoutSetInput = {
    text?: StringFieldUpdateOperationsInput | string
  }

  export type SpeakingPromptUncheckedUpdateWithoutSetInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type SpeakingPromptUncheckedUpdateManyWithoutSetInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type ExamAttemptUpdateWithoutSpeakingSetInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutAttemptsNestedInput
    listeningScenario?: ListeningScenarioUpdateOneWithoutAttemptsNestedInput
    writingTopic?: WritingTopicUpdateOneWithoutAttemptsNestedInput
    result?: ExamResultUpdateOneWithoutAttemptNestedInput
    cheatingEvents?: CheatingEventUpdateManyWithoutAttemptNestedInput
    audioResponses?: AudioResponseUpdateManyWithoutAttemptNestedInput
    activeExam?: ActiveExamUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutSpeakingSetInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    listeningScenarioId?: NullableIntFieldUpdateOperationsInput | number | null
    writingTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
    result?: ExamResultUncheckedUpdateOneWithoutAttemptNestedInput
    cheatingEvents?: CheatingEventUncheckedUpdateManyWithoutAttemptNestedInput
    audioResponses?: AudioResponseUncheckedUpdateManyWithoutAttemptNestedInput
    activeExam?: ActiveExamUncheckedUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateManyWithoutSpeakingSetInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcqQuestionIds?: NullableStringFieldUpdateOperationsInput | string | null
    listeningScenarioId?: NullableIntFieldUpdateOperationsInput | number | null
    writingTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    mcqAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    listeningAnswers?: NullableStringFieldUpdateOperationsInput | string | null
    writingAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    speakingTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    speakingScore?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamAttemptCountOutputTypeDefaultArgs instead
     */
    export type ExamAttemptCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamAttemptCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ListeningScenarioCountOutputTypeDefaultArgs instead
     */
    export type ListeningScenarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ListeningScenarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WritingTopicCountOutputTypeDefaultArgs instead
     */
    export type WritingTopicCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WritingTopicCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpeakingSetCountOutputTypeDefaultArgs instead
     */
    export type SpeakingSetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpeakingSetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamAttemptDefaultArgs instead
     */
    export type ExamAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamAttemptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActiveExamDefaultArgs instead
     */
    export type ActiveExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActiveExamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamResultDefaultArgs instead
     */
    export type ExamResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamResultDefaultArgs<ExtArgs>
    /**
     * @deprecated Use McqQuestionDefaultArgs instead
     */
    export type McqQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = McqQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ListeningScenarioDefaultArgs instead
     */
    export type ListeningScenarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ListeningScenarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ListeningQuestionDefaultArgs instead
     */
    export type ListeningQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ListeningQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WritingTopicDefaultArgs instead
     */
    export type WritingTopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WritingTopicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpeakingSetDefaultArgs instead
     */
    export type SpeakingSetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpeakingSetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpeakingPromptDefaultArgs instead
     */
    export type SpeakingPromptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpeakingPromptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CheatingEventDefaultArgs instead
     */
    export type CheatingEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CheatingEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudioResponseDefaultArgs instead
     */
    export type AudioResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioResponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PasswordResetTokenDefaultArgs instead
     */
    export type PasswordResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PasswordResetTokenDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}