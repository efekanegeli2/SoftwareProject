from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional

app = FastAPI(title="AI Scoring Service", version="1.0.0")

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify exact origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Request/Response models
class ScoreRequest(BaseModel):
    mcq_answers: List[str] = []
    writing_text: str = ""
    speaking_text: str = ""

class ScoreResponse(BaseModel):
    overall_score: int
    cefr_level: str
    feedback: str

# Hardcoded answer key for MCQ (20 questions)
# Matches the questions generated by the server
MCQ_ANSWER_KEY = [
    "went",           # Q1: She ___ to the store yesterday
    "on",             # Q2: working ___ this project
    "The",            # Q3: ___ sun rises
    "more interesting", # Q4: comparative form
    "had studied",    # Q5: conditional
    "is read",        # Q6: passive voice
    "should",         # Q7: modal verb
    "whom",           # Q8: relative pronoun
    "will have finished", # Q9: future perfect
    "have lived",     # Q10: present perfect
    "went",           # Q11: (repeat)
    "on",             # Q12: (repeat)
    "The",            # Q13: (repeat)
    "more interesting", # Q14: (repeat)
    "had studied",    # Q15: (repeat)
    "is read",        # Q16: (repeat)
    "should",         # Q17: (repeat)
    "whom",           # Q18: (repeat)
    "will have finished", # Q19: (repeat)
    "have lived"      # Q20: (repeat)
]

def calculate_mcq_score(answers: List[str]) -> int:
    """Calculate MCQ score based on answer key."""
    if not answers or len(answers) == 0:
        return 0
    
    correct = 0
    for i, answer in enumerate(answers):
        if i < len(MCQ_ANSWER_KEY) and answer == MCQ_ANSWER_KEY[i]:
            correct += 1
    
    # Score out of 100 (each question worth 5 points)
    return min(100, (correct * 5))

def calculate_writing_score(text: str) -> int:
    """Mock writing score based on length and vocabulary complexity."""
    if not text or len(text.strip()) == 0:
        return 0
    
    word_count = len(text.split())
    char_count = len(text)
    
    # Base score on length
    length_score = min(50, (word_count * 2))
    
    # Mock vocabulary complexity (check for advanced words)
    advanced_words = ["artificial", "intelligence", "technology", "innovation", 
                     "revolutionary", "transform", "efficiency", "automation",
                     "sophisticated", "capabilities", "enhancement", "optimization"]
    
    complexity_score = 0
    text_lower = text.lower()
    for word in advanced_words:
        if word in text_lower:
            complexity_score += 5
    
    complexity_score = min(50, complexity_score)
    
    return min(100, length_score + complexity_score)

def calculate_speaking_score(text: str) -> int:
    """Mock speaking score based on pronunciation indicators."""
    if not text or len(text.strip()) == 0:
        return 0
    
    # Mock logic: check for proper sentence structure
    sentences = text.split('.')
    sentence_count = len([s for s in sentences if s.strip()])
    
    # Base score on sentence count
    base_score = min(60, sentence_count * 20)
    
    # Check for proper capitalization and punctuation
    punctuation_score = 0
    if any(c in text for c in ['.', '!', '?']):
        punctuation_score = 20
    
    # Check for proper spacing
    spacing_score = 20 if ' ' in text else 0
    
    return min(100, base_score + punctuation_score + spacing_score)

def determine_cefr_level(score: int) -> str:
    """Determine CEFR level based on overall score."""
    if score >= 90:
        return "C2"
    elif score >= 80:
        return "C1"
    elif score >= 70:
        return "B2"
    elif score >= 60:
        return "B1"
    elif score >= 40:
        return "A2"
    else:
        return "A1"

def generate_feedback(score: int, cefr_level: str) -> str:
    """Generate feedback based on score and level."""
    if score >= 90:
        return f"Excellent performance! You've achieved {cefr_level} level. Your English proficiency is at an advanced level with strong command of complex language structures."
    elif score >= 70:
        return f"Good work! You've achieved {cefr_level} level. You demonstrate solid understanding of English with room for improvement in advanced topics."
    elif score >= 40:
        return f"Fair performance. You've achieved {cefr_level} level. Continue practicing to improve your vocabulary and grammar skills."
    else:
        return f"You've achieved {cefr_level} level. Focus on building foundational vocabulary and basic grammar structures. Keep practicing!"

@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {"status": "ok", "service": "ai-service"}

@app.post("/score", response_model=ScoreResponse)
async def score_assessment(request: ScoreRequest):
    """
    Score the English proficiency assessment.
    
    Zero Score Rule: If payload is empty or user answered nothing, return Score: 0, Level: A1.
    """
    # Check if payload is empty
    is_empty = (
        (not request.mcq_answers or len(request.mcq_answers) == 0) and
        (not request.writing_text or len(request.writing_text.strip()) == 0) and
        (not request.speaking_text or len(request.speaking_text.strip()) == 0)
    )
    
    if is_empty:
        return ScoreResponse(
            overall_score=0,
            cefr_level="A1",
            feedback="No answers provided. Please complete the assessment to receive a score."
        )
    
    # Calculate individual scores
    mcq_score = calculate_mcq_score(request.mcq_answers)
    writing_score = calculate_writing_score(request.writing_text)
    speaking_score = calculate_speaking_score(request.speaking_text)
    
    # Calculate weighted overall score
    # MCQ: 40%, Writing: 35%, Speaking: 25%
    overall_score = int(
        (mcq_score * 0.40) +
        (writing_score * 0.35) +
        (speaking_score * 0.25)
    )
    
    # Determine CEFR level
    cefr_level = determine_cefr_level(overall_score)
    
    # Generate feedback
    feedback = generate_feedback(overall_score, cefr_level)
    
    return ScoreResponse(
        overall_score=overall_score,
        cefr_level=cefr_level,
        feedback=feedback
    )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8001)
